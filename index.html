<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <!-- AWS SDK for Polly -->
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1372.0.min.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Kanit', sans-serif;
            background-color: #f3e8ff; /* Light lavender background */
        }
        .modal {
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #ede9fe; /* Lighter purple for modal content */
            color: #5b21b6; /* Dark purple text */
        }
        .btn-primary {
            background-color: #7c3aed; /* Purple-600 */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #6d28d9; /* Purple-700 */
        }
        .btn-secondary {
            background-color: #a78bfa; /* Purple-400 */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-secondary:hover {
            background-color: #8b5cf6; /* Purple-500 */
        }
        .section-title {
            color: #5b21b6;
            border-bottom: 2px solid #7c3aed;
            padding-bottom: 8px;
        }
        .tab-button {
            background-color: #ddd6fe; /* Lighter purple for inactive tabs */
            color: #5b21b6;
            border-color: #c4b5fd;
        }
        .tab-button.active {
            background-color: #7c3aed;
            color: white;
            border-color: #7c3aed;
        }
        .disabled-section {
            opacity: 0.5;
            pointer-events: none;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f3e8ff; }
        ::-webkit-scrollbar-thumb { background: #a78bfa; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #8b5cf6; }

        .pedigree-chart ul { padding-left: 20px; list-style-type: none; position: relative; }
        .pedigree-chart li { margin: 10px 0; position: relative; padding-left: 25px; }
        .pedigree-chart li::before, .pedigree-chart li::after { content: ''; position: absolute; left: 0; }
        .pedigree-chart li::before { border-top: 1px solid #7c3aed; top: 10px; width: 20px; height: 0; }
        .pedigree-chart li:not(:last-child)::after { border-left: 1px solid #7c3aed; height: 100%; width: 0px; top: 0px; }
        .pedigree-chart li:last-child::after { border-left: 1px solid #7c3aed; height: 10px; width: 0px; top: 0px; }
        .pedigree-node { background-color: #ede9fe; padding: 5px 10px; border-radius: 5px; border: 1px solid #c4b5fd; display: inline-block; }
        .pedigree-node.searched { background-color: #d8b4fe; /* Light purple for searched term */ }
        .pedigree-node.descendant { background-color: #c4b5fd; /* Lighter blue/purple for descendants */ }
        .pedigree-node.external-node { background-color: #e2e8f0; border-color: #cbd5e1; color: #4a5568; }
        
        .word-evolution-flow-container { display: flex; flex-direction: column; align-items: flex-start; }
        .evolution-era-row { display: flex; align-items: center; margin-bottom: 10px; }
        .evolution-era-node { background-color: #a78bfa; color: white; padding: 8px 12px; border-radius: 8px; margin: 0 5px; text-align: center; min-width: 150px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .evolution-era-node strong { display: block; font-size: 0.9em; margin-bottom: 3px; }
        .evolution-era-node .ortho { font-family: monospace; font-size: 1.1em;}
        .evolution-era-node .phonetic { font-family: monospace; font-size: 0.8em; color: #e9d5ff;}
        .evolution-arrow { color: #7c3aed; font-size: 1.8em; margin: 0 10px; }


        .animated-emoji { display: inline-block; animation: pulse 2.5s infinite ease-in-out; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

        #hamburgerMenu { transition: transform 0.3s ease-in-out; }
        #hamburgerMenu.open { transform: translateX(0); }
        #hamburgerMenu.closed { transform: translateX(-100%); }

        .word-detail-popup-field:not(:empty) { padding-bottom: 0.5rem; margin-bottom: 0.5rem; border-bottom: 1px solid #d1d5db; }
        .word-detail-popup-field:last-child { border-bottom: none; margin-bottom: 0; }

        .autocomplete-suggestions { position: absolute; border: 1px solid #ddd; background-color: white; z-index: 1000; max-height: 150px; overflow-y: auto; }
        .autocomplete-suggestion { padding: 8px; cursor: pointer; }
        .autocomplete-suggestion:hover { background-color: #f0f0f0; }

        #languageSelector {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; padding-right: 2.5em;
        }
        .table-sm th, .table-sm td { padding: 0.25rem 0.5rem; font-size: 0.875rem; }
        .ipa-table { border-collapse: collapse; margin: 10px 0; font-size: 0.9em; }
        .ipa-table th, .ipa-table td { border: 1px solid #c4b5fd; padding: 4px 8px; text-align: center; }
        .ipa-table th { background-color: #ddd6fe; }
        .ipa-table td span.highlighted-phoneme { background-color: #d8b4fe; padding: 2px 4px; border-radius: 3px; }
        .draggable-item { cursor: grab; }
        .draggable-item:active { cursor: grabbing; }
        .tone-sup { vertical-align: super; font-size: 0.75em; }
        .grapheme-mapping-display {
            padding: 0.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.375rem; /* rounded-md */
            background-color: #f9fafb; /* gray-50 */
        }
        .grapheme-mapping-display strong {
            color: #4b5563; /* gray-600 */
        }
        .grapheme-mapping-display .mapping-type {
            font-size: 0.8em;
            color: #6b7280; /* gray-500 */
            display: block; margin-top:2px;
        }
        .grapheme-mapping-display .mapping-values-container { /* Container for multiple value items */
            font-family: monospace;
        }
        .grapheme-mapping-display .mapping-values-container .mapping-value-item { /* Individual grapheme item */
            background-color: #d8b4fe; /* Light purple */
            padding: 1px 3px;
            border-radius: 3px;
            font-family: monospace; /* Ensure monospace is inherited or set */
            margin: 0 1px; /* Optional: space between items */
        }
        .rule-step-item { /* Style for individual rule steps */
            transition: background-color 0.2s ease-in-out;
        }
        .rule-step-item:hover {
            background-color: #e0d8f0 !important; /* Slightly darker purple when hovered */
        }

        /* Styles for inflection category backgrounds in conjugation test table */
        .inflection-category-bg-0 { background-color: #f3e8ff; } /* Light Lavender */
        .inflection-category-bg-1 { background-color: #e9d5ff; } /* Lighter Purple */
        .inflection-category-bg-2 { background-color: #ddd6fe; } /* Even Lighter Purple */

    </style>
</head>
<body class="text-gray-800">

    <div id="languageNameModal" class="fixed inset-0 z-50 flex items-center justify-center modal hidden">
        <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-md relative">
            <button id="closeLanguageNameModalBtn" class="absolute top-3 right-4 text-2xl text-purple-500 hover:text-purple-700">&times;</button>
            <h2 class="text-2xl font-bold mb-4 text-center">üëã ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤!</h2>
            <p class="mb-4 text-center">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</p>
            <input type="text" id="languageNameInput" class="w-full p-2 border border-purple-300 rounded-md mb-4 focus:ring-2 focus:ring-purple-500 focus:border-transparent" placeholder="‡πÄ‡∏ä‡πà‡∏ô '‡∏û‡∏≤‡∏£‡πÄ‡∏ã‡∏•', '‡∏ß‡∏¥‡∏ó‡∏¢‡∏†‡∏≤‡∏©‡∏≤'">
            <button id="submitLanguageName" class="w-full btn-primary py-2 px-4 rounded-md font-semibold">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤ ‚ú®</button>
        </div>
    </div>

    <div id="aboutModal" class="fixed inset-0 z-50 flex items-center justify-center modal hidden">
        <div class="modal-content p-8 rounded-lg shadow-xl w-full max-w-lg text-center">
            <h2 class="text-2xl font-bold mb-4">‡∏ô‡∏ß‡∏±‡∏ï‡∏Å‡∏£‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤</h2>
            <p class="mb-2 text-lg">‚Äú‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏ß‡∏¥‡∏ä‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏©‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‚Äù</p>
            <hr class="my-4 border-purple-300">
            <h3 class="text-xl font-semibold mb-2">‡∏à‡∏±‡∏î‡∏ó‡∏≥‡πÇ‡∏î‡∏¢</h3>
            <ul class="list-none mb-4">
                <li>‡∏ô‡∏≤‡∏¢‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ ‡∏´‡∏°‡∏≤‡∏¢‡∏°‡∏±‡πà‡∏ô</li><li>‡∏ô‡∏≤‡∏¢‡∏ä‡∏≤‡∏ï‡∏£‡∏µ ‡πÅ‡∏™‡∏ô‡∏¢‡∏≤‡∏Å‡∏∏‡∏•</li><li>‡∏ô‡∏≤‡∏¢‡∏ì‡∏±‡∏ê‡∏Å‡∏≤‡∏ô‡∏ï‡πå ‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡πÇ‡∏¢</li>
                <li>‡∏ô‡∏≤‡∏á‡∏™‡∏≤‡∏ß‡∏ô‡∏¥‡∏ä‡∏ô‡∏¥‡∏†‡∏≤ ‡∏û‡∏±‡πâ‡∏ß‡∏ó‡∏±‡∏î</li><li>‡∏ô‡∏≤‡∏á‡∏™‡∏≤‡∏ß‡∏ó‡∏¥‡∏û‡∏¢‡∏£‡∏±‡∏ï‡∏ô‡πå ‡πÅ‡∏™‡∏ô‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå</li>
            </ul>
            <h3 class="text-xl font-semibold mb-2">‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏ô‡∏ß‡∏±‡∏ï‡∏Å‡∏£‡∏£‡∏°</h3>
            <p class="mb-6">‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå ‡∏î‡∏£. ‡∏û‡∏£‡∏ó‡∏¥‡∏û‡∏¢‡πå ‡∏Ñ‡∏£‡∏≤‡∏°‡∏à‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>
             <h3 class="text-xl font-semibold mb-2">‡∏Ñ‡∏£‡∏π‡∏û‡∏µ‡πà‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏á</h3>
              <p class="mb-6">‡∏Ñ‡∏£‡∏π‡∏î‡∏ß‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô ‡∏Å‡∏¥‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ó</p>
             <h4 class="text-xl font-semibold mb-2">‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡πâ‡∏≤‡∏ö‡πâ‡∏≤‡∏á ‡∏Å‡πá‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏°‡∏≤ ‡∏ì ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡∏î‡πâ‡∏ß‡∏¢</h4>
             <p class="mb-6">‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ browser ‡∏à‡∏≤‡∏Å microsoft edge ‡∏´‡∏£‡∏∑‡∏≠ Google chrome ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£</p>
            <p class="mb-6">‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏•‡πá‡∏õ‡∏ó‡πá‡∏≠‡∏õ ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö</p>
            
            <button id="closeAboutModal" class="btn-secondary py-2 px-6 rounded-md font-semibold">‡∏õ‡∏¥‡∏î</button>
        </div>
    </div>

    <div id="wordDetailModal" class="fixed inset-0 z-50 flex items-center justify-center modal hidden p-4">
        <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 id="wordDetailTitle" class="text-2xl font-bold text-purple-700"></h3>
                <button id="closeWordDetailModal" class="text-purple-500 hover:text-purple-700 text-2xl">&times;</button>
            </div>
            <div id="wordDetailContent" class="space-y-3"></div>
            <div id="wordDetailButtons" class="mt-4 flex flex-wrap gap-2">
                 </div>
        </div>
    </div>

    <div id="genericModal" class="fixed inset-0 z-[60] flex items-center justify-center modal hidden p-4">
        <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 id="genericModalTitle" class="text-2xl font-bold text-purple-700"></h3>
                <button id="closeGenericModal" class="text-purple-500 hover:text-purple-700 text-2xl">&times;</button>
            </div>
            <div id="genericModalContent" class="space-y-3"></div>
            <div id="genericModalFooter" class="mt-6 flex justify-end space-x-3"></div>
        </div>
    </div>


    <div id="hamburgerMenu" class="fixed top-0 left-0 h-full w-64 bg-purple-700 text-white p-5 z-40 closed shadow-lg">
        <button id="closeHamburgerMenu" class="absolute top-3 right-3 text-2xl text-purple-200 hover:text-white">&times;</button>
        <h2 class="text-xl font-semibold mb-6 mt-8">‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</h2>
        <nav>
            <ul id="mainMenuNav"></ul>
        </nav>
    </div>

    <div id="appWrapper" class="min-h-screen flex flex-col">
        <header class="bg-purple-600 text-white p-4 shadow-md">
            <div class="container mx-auto flex justify-between items-center">
                <button id="openHamburgerMenu" class="text-2xl p-2 hover:bg-purple-500 rounded-md"><i class="fas fa-bars"></i></button>
                <h1 id="mainTitle" class="text-xl sm:text-3xl font-bold text-center flex-grow px-2">‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡∏†‡∏≤‡∏©‡∏≤ <span class="animated-emoji">üß†</span></h1>
                <div class="flex items-center space-x-2">
                    <div class="relative">
                        <select id="languageSelector" class="bg-purple-500 text-white py-2 pl-3 pr-8 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-purple-300 appearance-none">
                            <option value="" class="bg-white text-gray-700">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>
                        </select>
                    </div>
                    <button id="addNewLangButton" class="btn-secondary py-2 px-3 rounded-md font-semibold text-sm whitespace-nowrap"><i class="fas fa-plus-circle mr-1"></i> ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà</button>
                    <button id="deleteLangButton" class="btn-secondary py-2 px-3 rounded-md font-semibold text-sm whitespace-nowrap">
    <i class="fas fa-trash-alt mr-1"></i> ‡∏•‡∏ö‡∏†‡∏≤‡∏©‡∏≤
</button>
                    <button id="aboutButton" class="btn-secondary py-2 px-3 rounded-md font-semibold text-sm hidden sm:inline-block">üìú ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö</button>
                </div>
            </div>
        </header>

        <main id="mainContent" class="container mx-auto p-4 flex-grow disabled-section">
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-2xl font-semibold mb-2">‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: <span id="currentLanguageNameDisplay" class="text-purple-600">N/A</span></h2>
                <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-1 overflow-x-auto pb-2" aria-label="Tabs"></nav>
                </div>
                <div id="tabContent"></div>
            </div>
        </main>

        <footer class="bg-purple-700 text-white text-center p-4 mt-auto">
            <p>Developer: ‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ ‡∏´‡∏°‡∏≤‡∏¢‡∏°‡∏±‡πà‡∏ô ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ì‡∏∞</p>
            <p>‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏ô‡∏ß‡∏±‡∏ï‡∏Å‡∏£‡∏£‡∏°: ‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå ‡∏î‡∏£. ‡∏û‡∏£‡∏ó‡∏¥‡∏û‡∏¢‡πå ‡∏Ñ‡∏£‡∏≤‡∏°‡∏à‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>
             <p>‡∏Ñ‡∏ì‡∏∞‡∏Ñ‡∏£‡∏∏‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå ‡∏™‡∏≤‡∏Ç‡∏≤‡∏ß‡∏¥‡∏ä‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ ‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢‡∏£‡∏≤‡∏ä‡∏†‡∏±‡∏è‡∏û‡∏¥‡∏ö‡∏π‡∏•‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏°</p>
            <p>______________________________________________________________</p>
            <p>‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡πâ‡∏≤‡∏ö‡πâ‡∏≤‡∏á ‡∏Å‡πá‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏°‡∏≤ ‡∏ì ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡∏î‡πâ‡∏ß‡∏¢</p>
              <p>‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡πÄ‡∏ß‡πá‡∏õ‡πÑ‡∏ã‡∏ï‡πå ‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ</p>
             <p>‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô‡∏ï‡πâ‡∏ô‡πÅ‡∏ö‡∏ö: <a href="https://arthur2548.github.io/conlang-/" target="_blank" class="hover:underline">https://arthur2548.github.io/conlang-/</a></p>  
            <p>‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠: <a href="https://kruarthurclassroom.blogspot.com/" target="_blank" class="hover:underline">kruarthurclassroom.blogspot.com</a></p>
            <p>¬© 2025-2026 All Rights Reserved</p>
        </footer>
    </div>

    <script>
        // --- Global State and Data Structures ---
        const DEFAULT_LANGUAGE_STATE = Object.freeze({
            name: '',
            parentLangName: null,
            phonology: {
                consonants: ['p', 't', 'k'],
                vowels: ['a', 'e', 'i', 'o', 'u'],
                
                allowedInitialConsonants: [], 
                allowVowelInitial: false,
                forbiddenInitialSounds: [],

                allowedConsonantClusters: [], 
                forbiddenConsonantClusters: [],
                maxClusterLength: 2,

                allowedFinalConsonants: [], 
                allowNoCoda: true,
                forbiddenFinalSounds: [],
                allowClusterCoda: false, 
                allowedCodaClusters: [], 

                hasTones: false,
                tones: [], // { id: 'tone_1', name: '‡πÄ‡∏≠‡∏Å', symbol: '¬π', number: 1, representation: '\u00B9', hideInOrthography: false }
                
                tonePhonotactics: [], 

                graphemeMappings: [], 
                
                activeSoundChanges: [], 

                syllableStructures: ['CV', 'CVC', 'VC'],
                phonotactics: [ 
                    { rule: "‡∏´‡πâ‡∏≤‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ã‡πâ‡∏≠‡∏ô‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏ä‡πà‡∏ô CVC ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô CCVC)", type: "no_internal_cluster_in_base_syllable", enabled: true, custom: false, pattern: "" },
                ]
            },
            lexicon: [], // Words will have id, word (base phonemic form), customOrthography (optional), phonetics (detailed IPA), meaning, pos, gender, etymology, evolutionTimeline, dialectalForms, manualInflections
            /**
             * A collection of saved sentences for the language. Each sentence contains an
             * identifier, a structure string (e.g. "SVO"), and an array of components.
             * Each component stores which role it fulfills (S, V, O, etc), the
             * dictionary word‚Äôs ID, and any selected inflection options for that word.  This
             * property is initialized as an empty array for new languages and will be
             * persisted in local storage alongside other language data.  When
             * loading existing languages the ensureDeepStructure function will copy
             * whatever sentences exist or fall back to this empty array if none are
             * defined.
             */
            sentences: [],
            grammar: {
                sentenceStructure: 'SVO',
                partsOfSpeech: ['‡∏ô‡∏≤‡∏°', '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤', '‡∏ß‡∏¥‡πÄ‡∏®‡∏©‡∏ì‡πå', '‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå', '‡∏™‡∏£‡∏£‡∏û‡∏ô‡∏≤‡∏°', '‡∏™‡∏±‡∏ô‡∏ò‡∏≤‡∏ô', '‡∏ö‡∏∏‡∏û‡∏ö‡∏ó', '‡∏≠‡∏∏‡∏ó‡∏≤‡∏ô', ], 
                hasGender: false,
                genders: ['‡∏õ‡∏∏‡∏á‡∏•‡∏¥‡∏á‡∏Ñ‡πå', '‡∏≠‡∏¥‡∏ï‡∏ñ‡∏µ‡∏•‡∏¥‡∏á‡∏Ñ‡πå', '‡∏ô‡∏õ‡∏∏‡∏á‡∏™‡∏Å‡∏•‡∏¥‡∏á‡∏Ñ‡πå'],
                morphology: {
                    conjugationCategories: [
                        { id: 'cat_tense', name: '‡∏Å‡∏≤‡∏•', appliesToPOS: ['‡∏Å‡∏£‡∏¥‡∏¢‡∏≤'], options: ['‡∏≠‡∏î‡∏µ‡∏ï‡∏Å‡∏≤‡∏•', '‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Å‡∏≤‡∏•', '‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï‡∏Å‡∏≤‡∏•'] },
                        { id: 'cat_number', name: '‡∏û‡∏à‡∏ô‡πå', appliesToPOS: ['‡∏ô‡∏≤‡∏°', '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤'], options: ['‡πÄ‡∏≠‡∏Å‡∏û‡∏à‡∏ô‡πå', '‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå'] }
                    ],
                    conjugationRules: [], // Each rule now has ruleSteps: [{id, order, ruleType, ruleValue}]
                    nounPluralization: { 
                        ruleSteps: [{ id: 'default_plural_step_1', order: 0, ruleType: 'suffix', value: 's' }] // 'value' for nounPluralization steps
                    }
                },
                particles: []
            },
            orthography: {
                writingSystem: 'latin',
                customSymbols: [], 
                displayTonesInOrthography: true, 
                direction: 'ltr'
            },
            evolution: { 
                baseEra: null, 
                wordEra: null, 
                eras: [ 
                    { id: 'era_proto', name: '‡∏¢‡∏∏‡∏Ñ‡πÇ‡∏ö‡∏£‡∏≤‡∏ì', order: 0, soundChangeRules: [] }, 
                    { id: 'era_old', name: '‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô', order: 1, soundChangeRules: [] },
                    { id: 'era_modern', name: '‡∏¢‡∏∏‡∏Ñ‡πÉ‡∏´‡∏°‡πà', order: 2, soundChangeRules: [] }
                ]
            },
            eras: [ 
                { id: 'era_proto', name: '‡∏¢‡∏∏‡∏Ñ‡πÇ‡∏ö‡∏£‡∏≤‡∏ì', order: 0, soundChangeRules: [] }, 
                { id: 'era_old', name: '‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô', order: 1, soundChangeRules: [] },
                { id: 'era_modern', name: '‡∏¢‡∏∏‡∏Ñ‡πÉ‡∏´‡∏°‡πà', order: 2, soundChangeRules: [] }
            ],
            regions: ['(M) ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô', '(N) ‡∏ñ‡∏¥‡πà‡∏ô‡πÄ‡∏´‡∏ô‡∏∑‡∏≠', '(S) ‡∏ñ‡∏¥‡πà‡∏ô‡πÉ‡∏ï‡πâ', '(E) ‡∏ñ‡∏¥‡πà‡∏ô‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å', '(W) ‡∏ñ‡∏¥‡πà‡∏ô‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏ï‡∏Å'], 
            dialectSoundChanges: {}, 
            languageFamily: { 
                externalNodes: [] 
            },
            interLangSoundChangePairs: [], 
            theme: 'default'
        });

        let currentLanguage = JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE));
        let allLanguages = [];
        let globalInterLangRules = []; 

        let nextWordId = 1;
        let nextConjCategoryId = 1;
        let nextConjRuleId = 1;
        let nextRuleStepId = 1; // For unique IDs for rule steps (both general and plural)
        let nextExternalNodeId = 1;
        let nextInterLangPairId = 1;
        let nextActiveSoundChangeId = 1; 
        let nextToneId = 1;
        let nextTonePhonotacticId = 1;
        // Unique ID generator for sentences in the sentence system. This counter will increment
        // whenever a new sentence is saved. It helps assign a stable identifier to each
        // sentence stored in the current language‚Äôs `sentences` array.  Without a separate
        // counter the application would need to scan existing sentences to compute the next
        // ID, which is inefficient when many sentences exist.  The counter is initialized
        // when the page loads and persists for the session.  When loading existing
        // languages the code will still respect the IDs stored on each sentence object.
        let nextSentenceId = 1;


        let activeTab = 'phonology';

        const localThaiMeaningsDatabase = [ 
            "‡πÄ‡∏î‡∏¥‡∏ô", "‡∏ß‡∏¥‡πà‡∏á", "‡∏Å‡∏¥‡∏ô", "‡∏ô‡∏≠‡∏ô", "‡∏û‡∏π‡∏î", "‡∏´‡∏±‡∏ß‡πÄ‡∏£‡∏≤‡∏∞", "‡∏£‡πâ‡∏≠‡∏á‡πÑ‡∏´‡πâ", "‡∏£‡∏±‡∏Å", "‡πÄ‡∏Å‡∏•‡∏µ‡∏¢‡∏î", "‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°", "‡∏´‡∏•‡πà‡∏≠‡πÄ‡∏´‡∏•‡∏≤",
            "‡∏ö‡πâ‡∏≤‡∏ô", "‡πÄ‡∏°‡∏∑‡∏≠‡∏á", "‡∏†‡∏π‡πÄ‡∏Ç‡∏≤", "‡πÅ‡∏°‡πà‡∏ô‡πâ‡∏≥", "‡∏ó‡∏∞‡πÄ‡∏•", "‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤", "‡∏î‡∏ß‡∏á‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå", "‡∏î‡∏ß‡∏á‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå", "‡∏î‡∏ß‡∏á‡∏î‡∏≤‡∏ß",
            "‡∏´‡∏¥‡∏ô", "‡∏î‡∏¥‡∏ô", "‡∏ó‡∏£‡∏≤‡∏¢", "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ", "‡∏î‡∏≠‡∏Å‡πÑ‡∏°‡πâ", "‡∏ú‡∏•‡πÑ‡∏°‡πâ", "‡∏™‡∏±‡∏ï‡∏ß‡πå", "‡∏ô‡∏Å", "‡∏õ‡∏•‡∏≤", "‡πÅ‡∏°‡∏•‡∏á",
            "‡∏ö‡∏¥‡∏î‡∏≤", "‡∏°‡∏≤‡∏£‡∏î‡∏≤", "‡∏û‡∏µ‡πà‡∏ä‡∏≤‡∏¢", "‡∏ô‡πâ‡∏≠‡∏á‡∏™‡∏≤‡∏ß", "‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô", "‡∏Ñ‡∏£‡∏π", "‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡πÅ‡∏û‡∏ó‡∏¢‡πå", "‡∏ó‡∏´‡∏≤‡∏£", "‡∏ï‡∏≥‡∏£‡∏ß‡∏à",
            "‡πÉ‡∏´‡∏ç‡πà", "‡πÄ‡∏•‡πá‡∏Å", "‡∏™‡∏π‡∏á", "‡∏ï‡πà‡∏≥", "‡∏¢‡∏≤‡∏ß", "‡∏™‡∏±‡πâ‡∏ô", "‡∏£‡πâ‡∏≠‡∏ô", "‡πÄ‡∏¢‡πá‡∏ô", "‡∏™‡∏ß‡πà‡∏≤‡∏á", "‡∏°‡∏∑‡∏î", "‡∏î‡∏µ", "‡πÄ‡∏•‡∏ß"
        ];
        let apiThaiMeaningsDatabase = []; 

        const API_URL = "https://script.google.com/macros/s/AKfycbyQt6pWFF_y0LZBA38C8VheADB-bud0PshyYiUehFTWZxWUqzB5d0n_EzmMA7MDwAYnwQ/exec";

        // --- UI Elements ---
        const languageNameModal = document.getElementById('languageNameModal');
        const closeLanguageNameModalButton = document.getElementById('closeLanguageNameModalBtn');
        const languageNameInput = document.getElementById('languageNameInput');
        const submitLanguageNameButton = document.getElementById('submitLanguageName');
        const mainContent = document.getElementById('mainContent');
        const currentLanguageNameDisplay = document.getElementById('currentLanguageNameDisplay');
        const aboutModal = document.getElementById('aboutModal');
        const aboutButton = document.getElementById('aboutButton');
        const closeAboutModalButton = document.getElementById('closeAboutModal');
        const tabContainer = document.querySelector('nav[aria-label="Tabs"]');
        const tabContentContainer = document.getElementById('tabContent');
        const addNewLangButton = document.getElementById('addNewLangButton');
        const languageSelector = document.getElementById('languageSelector');

        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const openHamburgerMenuButton = document.getElementById('openHamburgerMenu');
        const closeHamburgerMenuButton = document.getElementById('closeHamburgerMenu');
        const mainMenuNav = document.getElementById('mainMenuNav');

        const wordDetailModal = document.getElementById('wordDetailModal');
        const wordDetailTitle = document.getElementById('wordDetailTitle');
        const wordDetailContent = document.getElementById('wordDetailContent');
        const wordDetailButtons = document.getElementById('wordDetailButtons');
        const closeWordDetailModalButton = document.getElementById('closeWordDetailModal');

        const genericModal = document.getElementById('genericModal');
        const genericModalTitle = document.getElementById('genericModalTitle');
        const genericModalContent = document.getElementById('genericModalContent');
        const genericModalFooter = document.getElementById('genericModalFooter');
        const closeGenericModalButton = document.getElementById('closeGenericModal');


        // --- Tabs Configuration ---
        const tabs = [
            { id: 'phonology', name: 'üé∂ ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á', icon: 'fas fa-volume-up', contentFunc: renderPhonologyUI, menu: true },
            { id: 'wordGen', name: '‚úçÔ∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥', icon: 'fas fa-pencil-alt', contentFunc: renderWordGeneratorUI, menu: true },
            { id: 'grammar', name: 'üìñ ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå', icon: 'fas fa-book', contentFunc: renderGrammarUI, menu: true },
            { id: 'dictionary', name: 'üìö ‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°', icon: 'fas fa-atlas', contentFunc: renderDictionaryUI, menu: true },
            // A dedicated tab for working with sentences.  Users can build sentences
            // manually or randomly from the lexicon, apply inflection rules to each
            // component, and save their creations.  See `renderSentenceUI` for the
            // implementation details.
            { id: 'sentence', name: 'üìù ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ', icon: 'fas fa-paragraph', contentFunc: renderSentenceUI, menu: true },
            { id: 'orthography', name: 'üî§ ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏Å‡∏©‡∏£', icon: 'fas fa-spell-check', contentFunc: renderOrthographyUI, menu: true },
            { id: 'etymology', name: 'üå± ‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤', icon: 'fas fa-seedling', contentFunc: renderEtymologyUI, menu: true },
            { id: 'evolution', name: '‚è≥ ‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥', icon: 'fas fa-history', contentFunc: (container) => { renderEvolutionUI(container); }, menu: true },
            { id: 'dialects', name: 'üó∫Ô∏è ‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô', icon: 'fas fa-map-signs', contentFunc: renderDialectsUI, menu: true },
            { id: 'langFamily', name: 'üå≥ ‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤', icon: 'fas fa-sitemap', contentFunc: renderLangFamilyUI, menu: true },
            { id: 'soundChanges', name: 'üîÑ ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤)', icon: 'fas fa-exchange-alt', contentFunc: renderSoundChangesInterLangUI, menu: true },
            { id: 'tools', name: 'üõ†Ô∏è ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠', icon: 'fas fa-tools', contentFunc: renderToolsUI, menu: true },
            { id: 'ipaProgram', name: 'üó£Ô∏è ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏™‡∏±‡∏ó‡∏≠‡∏±‡∏Å‡∏©‡∏£', icon: 'fas fa-microphone-alt', contentFunc: () => tabContentContainer.innerHTML = '<p>‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏±‡∏ó‡∏≠‡∏±‡∏Å‡∏©‡∏£ (‡∏£‡∏≠‡∏û‡∏±‡∏í‡∏ô‡∏≤)</p>', menu: true, disabled: true },
            { id: 'thaiApp', name: 'üáπüá≠ ‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢', icon: 'fas fa-chalkboard-teacher', contentFunc: () => tabContentContainer.innerHTML = '<p>‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ß‡∏¥‡∏ä‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (‡∏£‡∏≠‡∏û‡∏±‡∏í‡∏ô‡∏≤)</p>', menu: true, disabled: true },
        ];

        // --- API Functions ---
        async function fetchThaiMeaningsFromAPI() {
            try {
                const response = await fetch(`${API_URL}?action=findAllRegister`);
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                const result = await response.json();
                if (result.success && Array.isArray(result.data)) {
                    apiThaiMeaningsDatabase = result.data.map(item => item.‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå).filter(meaning => meaning && meaning.trim() !== '');
                    console.log(`Fetched ${apiThaiMeaningsDatabase.length} meanings from API.`);
                    if (apiThaiMeaningsDatabase.length === 0) {
                         console.warn("API returned no valid meanings. Falling back to local meanings.");
                    }
                } else {
                    console.error("API call was successful but data is not in expected format or success=false:", result.message, result.error);
                    apiThaiMeaningsDatabase = []; 
                }
            } catch (error) {
                console.error("Error fetching Thai meanings from API:", error);
                apiThaiMeaningsDatabase = []; 
            }
        }

        // --- Initialization ---
        window.onload = async () => {
            await fetchThaiMeaningsFromAPI();
            loadData(); 
            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÉ‡∏´‡∏°‡πà: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏•‡∏¢ (allLanguages.length === 0) ‡πÅ‡∏•‡∏∞ currentLanguage ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠ ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á modal
            if (!currentLanguage.name && allLanguages.length === 0) {
                languageNameModal.classList.remove('hidden');
                mainContent.classList.add('disabled-section');
            } else {
                // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏™‡∏î‡∏á pop-up ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤
                if (!currentLanguage.name && allLanguages.length > 0) {
                    switchLanguage(allLanguages[0].name); 
                }
                mainContent.classList.remove('disabled-section');
                currentLanguageNameDisplay.textContent = currentLanguage.name;
                if (languageSelector.value !== currentLanguage.name) {
                   languageSelector.value = currentLanguage.name;
                }
                updateUI();
            }

            submitLanguageNameButton.addEventListener('click', handleNewLanguageNameSubmission);
            closeLanguageNameModalButton.addEventListener('click', () => {
                languageNameModal.classList.add('hidden');
                if (!currentLanguage.name && allLanguages.length === 0) {
                    // Stays disabled
                } else if (!currentLanguage.name && allLanguages.length > 0) {
                    const lastSelected = languageSelector.value;
                    if (lastSelected && allLanguages.some(l => l.name === lastSelected)) {
                        switchLanguage(lastSelected);
                    } else if(allLanguages.length > 0) {
                        switchLanguage(allLanguages[0].name);
                    }
                     mainContent.classList.remove('disabled-section');
                } else { 
                    mainContent.classList.remove('disabled-section');
                }
            });
            addNewLangButton.addEventListener('click', promptForNewLanguage);
            languageSelector.addEventListener('change', handleLanguageSelectionChange);

            aboutButton.addEventListener('click', () => aboutModal.classList.remove('hidden'));
            closeAboutModalButton.addEventListener('click', () => aboutModal.classList.add('hidden'));

            openHamburgerMenuButton.addEventListener('click', () => hamburgerMenu.classList.replace('closed', 'open') );
            closeHamburgerMenuButton.addEventListener('click', () => hamburgerMenu.classList.replace('open', 'closed') );

            closeWordDetailModalButton.addEventListener('click', () => wordDetailModal.classList.add('hidden'));
            closeGenericModalButton.addEventListener('click', () => genericModal.classList.add('hidden'));

            renderMainMenu();
            renderTabs();
            if (currentLanguage.name) {
                switchTab(activeTab);
            }
        };
        const deleteLangButton = document.getElementById('deleteLangButton');
deleteLangButton.addEventListener('click', () => {
    if (!currentLanguage.name) {
        alert("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà");
        return;
    }
    const confirmDelete = confirm(`‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏†‡∏≤‡∏©‡∏≤ "${currentLanguage.name}"? ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏∞‡∏´‡∏≤‡∏¢‡πÑ‡∏õ`);
    if (confirmDelete) {
        // ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å allLanguages
        allLanguages = allLanguages.filter(lang => lang.name !== currentLanguage.name);

        // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå currentLanguage
        currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE);

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI
        localStorage.setItem('allLanguagesData', JSON.stringify(allLanguages));
        localStorage.removeItem('currentLanguageData');

        renderLanguageSelector();
        updateUI();
    }
});

        // --- Loading Overlay ---
        const loadingOverlay = document.createElement('div');
        loadingOverlay.id = 'loadingOverlay';
        loadingOverlay.style.position = 'fixed';
        loadingOverlay.style.top = '0';
        loadingOverlay.style.left = '0';
        loadingOverlay.style.width = '100vw';
        loadingOverlay.style.height = '100vh';
        loadingOverlay.style.background = 'rgba(255,255,255,0.85)';
        loadingOverlay.style.display = 'flex';
        loadingOverlay.style.flexDirection = 'column';
        loadingOverlay.style.alignItems = 'center';
        loadingOverlay.style.justifyContent = 'center';
        loadingOverlay.style.zIndex = '9999';
        loadingOverlay.innerHTML = `
            <div style="display:flex;flex-direction:column;align-items:center;gap:16px;">
                <div class="animate-spin" style="border:6px solid #e9d5ff;border-top:6px solid #a21caf;border-radius:50%;width:48px;height:48px;"></div>
                <div id="loadingPercentText" style="font-size:1.2rem;color:#a21caf;font-weight:600;">0%</div>
                <div style="font-size:1.1rem;color:#7c3aed;font-weight:500;">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...</div>
            </div>
        `;
        function setLoadingPercent(percent) {
            const percentEl = document.getElementById('loadingPercentText');
            if (percentEl) percentEl.textContent = `${percent}%`;
        }
        document.body.appendChild(loadingOverlay);

        function hideLoadingOverlay() {
            const el = document.getElementById('loadingOverlay');
            if (el) el.remove();
        }

        // --- End Loading Overlay ---
        function ensureDeepStructure(langData, defaultStructure) {
            const newLangData = JSON.parse(JSON.stringify(defaultStructure)); 
        
            function merge(target, source, defaultSrc = defaultStructure) {
                for (const key in source) {
                    if (source.hasOwnProperty(key)) {
                        if (source[key] !== null && typeof source[key] === 'object' && !Array.isArray(source[key]) && key !== 'phonology' && key !== 'grammar' && key !== 'lexicon' && key !== 'orthography' /* etc, handle special structures below */ ) {
                             if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key])) {
                                target[key] = JSON.parse(JSON.stringify(defaultSrc[key] || {})); 
                            }
                            merge(target[key], source[key], defaultSrc[key] || {});
                        } else if (key === 'conjugationRules' && Array.isArray(source[key])) { // START MIGRATION LOGIC for conjugationRules
                            target[key] = source[key].map(rule => {
                                if (rule.hasOwnProperty('ruleType') && !rule.hasOwnProperty('ruleSteps')) { // Old format: ruleType/ruleValue directly on rule
                                    // Migrate to new format: ruleSteps array
                                    return {
                                        ...rule, // Keep id, description, pos, catId, catOpt
                                        ruleSteps: [{ 
                                            id: `step_${nextRuleStepId++}`, 
                                            order: 0, 
                                            ruleType: rule.ruleType, 
                                            ruleValue: rule.ruleValue 
                                        }],
                                        ruleType: undefined, // Remove old properties
                                        ruleValue: undefined // Remove old properties
                                    };
                                }
                                // Ensure all steps in the new format have IDs and order
                                if (rule.ruleSteps && Array.isArray(rule.ruleSteps)) {
                                    rule.ruleSteps = rule.ruleSteps.map((step, index) => ({
                                        id: step.id || `step_${nextRuleStepId++}`, // Assign ID if missing
                                        order: step.order !== undefined ? step.order : index, // Assign order if missing
                                        ...step
                                    }));
                                } else if (!rule.ruleSteps) { // If rule exists but ruleSteps is missing somehow
                                    rule.ruleSteps = [];
                                }
                                return rule;
                            }); // END MIGRATION LOGIC for conjugationRules
                        } else if (key === 'nounPluralization' && source[key] && typeof source[key] === 'object') { // START MIGRATION for nounPluralization
                             if (source[key].hasOwnProperty('rule') && !source[key].hasOwnProperty('ruleSteps')) { // Old format: rule/value directly
                                target[key] = {
                                    ruleSteps: [{
                                        id: `plural_step_${nextRuleStepId++}`,
                                        order: 0,
                                        ruleType: source[key].rule,
                                        value: source[key].value // 'value' for noun plural steps
                                    }]
                                };
                            } else if (source[key].ruleSteps && Array.isArray(source[key].ruleSteps)) { // New format from source
                                target[key] = {
                                    ruleSteps: source[key].ruleSteps.map((step, index) => ({
                                        id: step.id || `plural_step_${nextRuleStepId++}`,
                                        order: step.order !== undefined ? step.order : index,
                                        ruleType: step.ruleType,
                                        value: step.value // 'value' for noun plural steps
                                    }))
                                };
                            } else if (defaultSrc && defaultSrc[key] && defaultSrc[key].ruleSteps) { // Fallback to default if source is malformed
                                target[key] = JSON.parse(JSON.stringify(defaultSrc[key]));
                            } else { // Absolute fallback
                                target[key] = { ruleSteps: [{ id: `default_plural_step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', value: 's' }] };
                            } // END MIGRATION for nounPluralization
                        } else if (Array.isArray(source[key])) {
                             if (source[key].length > 0 || !target.hasOwnProperty(key) || target[key] === undefined) {
                                target[key] = JSON.parse(JSON.stringify(source[key]));
                            } else if (target[key] && target[key].length === 0 && source[key].length === 0 && defaultSrc[key] && defaultSrc[key].length > 0) {
                                // If target is empty array, source is empty array, but default has items, use default.
                                target[key] = JSON.parse(JSON.stringify(defaultSrc[key])); 
                            } else if (!target.hasOwnProperty(key) || target[key] === undefined) { // if target doesn't have key, copy from source
                                 target[key] = JSON.parse(JSON.stringify(source[key]));
                            } else { // Default case: target exists, source exists, copy from source
                                target[key] = JSON.parse(JSON.stringify(source[key]));
                             }
                        } else if (source[key] !== undefined) { // Handle primitive types or null
                            target[key] = source[key];
                        }
                    }
                }
                // Ensure all default keys are present if not in source
                for (const key in defaultSrc) {
                    if (defaultSrc.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                         if (key === 'grammar' || key === 'phonology' || key === 'lexicon' || key === 'orthography') { // Don't overwrite special structures if partially merged
                            // These are handled below
                         } else {
                            target[key] = JSON.parse(JSON.stringify(defaultSrc[key]));
                         }
                    }
                }
            }
        
            merge(newLangData, langData); 
        
            // Ensure specific nested structures exist and have all default keys
            newLangData.phonology = newLangData.phonology || { ...defaultStructure.phonology };
            const phonoKeys = ['consonants', 'vowels', 'allowedInitialConsonants', 'allowVowelInitial', 'forbiddenInitialSounds', 
                               'allowedConsonantClusters', 'forbiddenConsonantClusters', 'maxClusterLength', 
                               'allowedFinalConsonants', 'allowNoCoda', 'forbiddenFinalSounds', 'allowClusterCoda', 'allowedCodaClusters',
                               'hasTones', 'tones', 'tonePhonotactics', 'graphemeMappings', 
                               'activeSoundChanges', 'syllableStructures', 'phonotactics'];
            phonoKeys.forEach(key => {
                if (!newLangData.phonology.hasOwnProperty(key) || newLangData.phonology[key] === undefined) {
                    newLangData.phonology[key] = JSON.parse(JSON.stringify(defaultStructure.phonology[key]));
                }
                // Ensure arrays are arrays, booleans are booleans, etc.
                if(Array.isArray(defaultStructure.phonology[key]) && !Array.isArray(newLangData.phonology[key])) {
                    newLangData.phonology[key] = JSON.parse(JSON.stringify(defaultStructure.phonology[key]));
                }
                 if (typeof defaultStructure.phonology[key] === 'boolean' && typeof newLangData.phonology[key] !== 'boolean') {
                    newLangData.phonology[key] = defaultStructure.phonology[key];
                }
                if (typeof defaultStructure.phonology[key] === 'number' && typeof newLangData.phonology[key] !== 'number') {
                    newLangData.phonology[key] = defaultStructure.phonology[key];
                }
            });
             // If allowedInitialConsonants is empty after load but consonants are not, populate it from consonants (common scenario for older data)
             if (newLangData.phonology.allowedInitialConsonants.length === 0 && newLangData.phonology.consonants.length > 0) {
                 newLangData.phonology.allowedInitialConsonants = [...newLangData.phonology.consonants];
             }
             // Same for allowedFinalConsonants, populate with common finals if empty
             if (newLangData.phonology.allowedFinalConsonants.length === 0 && newLangData.phonology.consonants.length > 0) {
                 const commonFinals = ['m', 'n', '≈ã', 'p', 't', 'k', 's', 'l', 'r']; // Example common finals
                 newLangData.phonology.allowedFinalConsonants = newLangData.phonology.consonants.filter(c => commonFinals.includes(c));
             }


            newLangData.lexicon = (newLangData.lexicon || []).map(word => ({
                id: word.id || 0, 
                word: word.word || '',
                customOrthography: word.customOrthography || null,
                phonetics: word.phonetics || '',
                meaning: word.meaning || '',
                partOfSpeech: word.partOfSpeech || '',
                gender: word.gender || '', // Added gender field
                etymology: word.etymology || { roots: [], notes: '' },
                evolutionTimeline: word.evolutionTimeline || [],
                dialectalForms: word.dialectalForms || [],
                manualInflections: word.manualInflections || {},
                ...word 
            }));
            
            newLangData.grammar = newLangData.grammar || { ...defaultStructure.grammar };
            newLangData.grammar.morphology = newLangData.grammar.morphology || { ...defaultStructure.grammar.morphology };
            newLangData.grammar.morphology.conjugationCategories = (newLangData.grammar.morphology.conjugationCategories && newLangData.grammar.morphology.conjugationCategories.length > 0) ? newLangData.grammar.morphology.conjugationCategories : JSON.parse(JSON.stringify(defaultStructure.grammar.morphology.conjugationCategories));
            // ConjugationRules are handled by the merge function's specific logic
            if (!newLangData.grammar.morphology.conjugationRules) { // Ensure it's an array if merge didn't create it
                newLangData.grammar.morphology.conjugationRules = [];
            }
            // NounPluralization is handled by the merge function's specific logic
            if (!newLangData.grammar.morphology.nounPluralization || typeof newLangData.grammar.morphology.nounPluralization !== 'object' || !Array.isArray(newLangData.grammar.morphology.nounPluralization.ruleSteps)) {
                 console.warn("Re-initializing nounPluralization to default in ensureDeepStructure due to missing/invalid structure post-merge.");
                 newLangData.grammar.morphology.nounPluralization = JSON.parse(JSON.stringify(defaultStructure.grammar.morphology.nounPluralization));
            }
             // Ensure ruleSteps in nounPluralization have proper IDs and order after everything
            if (newLangData.grammar.morphology.nounPluralization.ruleSteps) {
                newLangData.grammar.morphology.nounPluralization.ruleSteps = newLangData.grammar.morphology.nounPluralization.ruleSteps.map((step, index) => ({
                    id: step.id || `plural_step_${nextRuleStepId++}`,
                    order: step.order !== undefined ? step.order : index,
                    ruleType: step.ruleType,
                    value: step.value // Noun plural steps use 'value'
                }));
            }


            newLangData.grammar.partsOfSpeech = (newLangData.grammar.partsOfSpeech && newLangData.grammar.partsOfSpeech.length > 0) ? newLangData.grammar.partsOfSpeech : JSON.parse(JSON.stringify(defaultStructure.grammar.partsOfSpeech));
            newLangData.grammar.genders = (newLangData.grammar.genders && newLangData.grammar.genders.length > 0) ? newLangData.grammar.genders : JSON.parse(JSON.stringify(defaultStructure.grammar.genders));


            newLangData.orthography = newLangData.orthography || { ...defaultStructure.orthography };
            newLangData.orthography.customSymbols = newLangData.orthography.customSymbols || [];
            if (newLangData.orthography.displayTonesInOrthography === undefined) { // Ensure boolean exists
                newLangData.orthography.displayTonesInOrthography = defaultStructure.orthography.displayTonesInOrthography;
            }
            
            newLangData.eras = (newLangData.eras && newLangData.eras.length > 0) ? newLangData.eras : JSON.parse(JSON.stringify(defaultStructure.eras));
            newLangData.eras.forEach(era => era.soundChangeRules = era.soundChangeRules || []);

            // Ensure evolution structure
            newLangData.evolution = newLangData.evolution || JSON.parse(JSON.stringify(defaultStructure.evolution));
            newLangData.evolution.eras = (newLangData.evolution.eras && newLangData.evolution.eras.length > 0) ? newLangData.evolution.eras : JSON.parse(JSON.stringify(defaultStructure.evolution.eras));
            if (!newLangData.evolution.baseEra && newLangData.evolution.eras.length > 0) newLangData.evolution.baseEra = newLangData.evolution.eras[0].id;
            if (!newLangData.evolution.wordEra && newLangData.evolution.eras.length > 0) newLangData.evolution.wordEra = newLangData.evolution.eras[0].id;


            newLangData.regions = (newLangData.regions && newLangData.regions.length > 0) ? newLangData.regions : JSON.parse(JSON.stringify(defaultStructure.regions));
            
            newLangData.dialectSoundChanges = newLangData.dialectSoundChanges || {};
            const currentRegions = newLangData.regions || defaultStructure.regions; // Use the ones actually in the lang data
            currentRegions.forEach(region => { // Ensure every current region has an entry in dialectSoundChanges
                if (!newLangData.dialectSoundChanges[region]) {
                    newLangData.dialectSoundChanges[region] = [];
                }
            });
            // Remove dialectSoundChanges for regions that no longer exist
            for (const regionInRules in newLangData.dialectSoundChanges) {
                if (!currentRegions.includes(regionInRules)) {
                    delete newLangData.dialectSoundChanges[regionInRules];
                }
            }

            newLangData.languageFamily = newLangData.languageFamily || { ...defaultStructure.languageFamily };
            newLangData.languageFamily.externalNodes = newLangData.languageFamily.externalNodes || [];

            newLangData.interLangSoundChangePairs = newLangData.interLangSoundChangePairs || [];

            // Recalculate nextRuleStepId based on the fully processed langData
            let maxStepIdNum = 0;
            (newLangData.grammar.morphology.conjugationRules || []).forEach(rule => {
                (rule.ruleSteps || []).forEach(step => {
                    if (step.id) {
                        const num = parseInt(String(step.id).replace(/^(step_|plural_step_)/, ''));
                        if (!isNaN(num)) maxStepIdNum = Math.max(maxStepIdNum, num);
                    }
                });
            });
            if (newLangData.grammar.morphology.nounPluralization && newLangData.grammar.morphology.nounPluralization.ruleSteps) {
                 newLangData.grammar.morphology.nounPluralization.ruleSteps.forEach(step => {
                     if (step.id) {
                        const num = parseInt(String(step.id).replace(/^(step_|plural_step_)/, ''));
                        if (!isNaN(num)) maxStepIdNum = Math.max(maxStepIdNum, num);
                    }
                 });
            }
            nextRuleStepId = maxStepIdNum + 1;


            return newLangData;
        }


        function renderMainMenu() {
            mainMenuNav.innerHTML = '';
            tabs.filter(tab => tab.menu).forEach(tab => {
                const li = document.createElement('li');
                li.className = 'mb-3';
                const a = document.createElement('a');
                a.href = '#';
                a.className = `hover:text-purple-300 block py-2 px-1 rounded ${tab.disabled ? 'text-gray-400 cursor-not-allowed' : ''}`;
                a.innerHTML = `<i class="${tab.icon} mr-2"></i> ${tab.name} ${tab.disabled ? '<span class="text-xs">(‡∏£‡∏≠‡∏û‡∏±‡∏í‡∏ô‡∏≤)</span>' : ''}`;
                if (!tab.disabled) {
                    a.onclick = (e) => {
                        e.preventDefault();
                        switchTab(tab.id);
                        hamburgerMenu.classList.replace('open', 'closed');
                    };
                } else {
                    a.onclick = (e) => { e.preventDefault(); alert(`${tab.name} (‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤)`); };
                }
                li.appendChild(a);
                mainMenuNav.appendChild(li);
            });
        }

        function handleNewLanguageNameSubmission() {
            const name = languageNameInput.value.trim();
            if (name) {
                if (allLanguages.some(lang => lang.name === name)) {
                    alert("‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏∑‡πà‡∏ô");
                    return;
                }
                if (currentLanguage.name === '') { // Initial creation for the session
                    currentLanguage.name = name;
                } else { // User clicked "Add New Language" button while another was active
                    currentLanguage = ensureDeepStructure({ name: name }, DEFAULT_LANGUAGE_STATE);
                }
                
                languageNameModal.classList.add('hidden');
                mainContent.classList.remove('disabled-section');
                currentLanguageNameDisplay.textContent = currentLanguage.name;
                
                 // Populate initial phonotactics for new language if needed
                 if (currentLanguage.phonology.allowedInitialConsonants.length === 0 && currentLanguage.phonology.consonants.length > 0) {
                    currentLanguage.phonology.allowedInitialConsonants = [...currentLanguage.phonology.consonants];
                }
                if (currentLanguage.phonology.allowedFinalConsonants.length === 0 && currentLanguage.phonology.consonants.length > 0) {
                    const commonFinals = ['m', 'n', '≈ã', 'p', 't', 'k', 's', 'l', 'r']; 
                    currentLanguage.phonology.allowedFinalConsonants = currentLanguage.phonology.consonants.filter(c => commonFinals.includes(c));
                }

                saveData(); // This will add/update it in allLanguages
                updateUI(); // This will re-render tabs, selector, etc.
            } else {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì');
            }
        }

        function promptForNewLanguage() {
            const confirmMsg = currentLanguage.name ? 
                '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß)' : 
                '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?';
            if (!confirm(confirmMsg)) {
                return;
            }

            if (currentLanguage.name) { // Save current before switching
                saveData(); // This updates `allLanguages`
            }

            currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE); // Reset to default for new lang
            nextWordId = 1; // Reset relevant counters FOR THIS NEW LANGUAGE CONTEXT
            nextActiveSoundChangeId = 1;
            nextToneId = 1;
            nextTonePhonotacticId = 1;
            nextConjCategoryId = 1;
            nextConjRuleId = 1;
            nextRuleStepId = 1; // Reset for the new language context
            nextExternalNodeId = 1; // This might need to be global if external nodes are shared, or per-language if not

            languageNameInput.value = ''; // Clear input for new name
            languageNameModal.classList.remove('hidden'); // Show modal
            mainContent.classList.add('disabled-section'); // Disable content until named
            currentLanguageNameDisplay.textContent = 'N/A';
            languageSelector.value = ""; // Reflect that no language is selected for current editing context

            tabContentContainer.innerHTML = ''; // Clear current tab content
            activeTab = tabs[0].id; // Reset to first tab
            renderTabs(); // Render tabs (they'll be mostly functionless until lang is named)
        }

        function handleLanguageSelectionChange(event) {
            const selectedLangName = event.target.value;
            if (selectedLangName && selectedLangName !== currentLanguage.name) {
                switchLanguage(selectedLangName);
            } else if (!selectedLangName) {
                // User selected "-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --"
                // If a language is currently active, revert selector to it.
                // Or, decide if this means "unload current language". For now, revert.
                if (currentLanguage.name) {
                    languageSelector.value = currentLanguage.name;
                }
            }
        }

        function switchLanguage(langName) {
            if (currentLanguage.name && currentLanguage.name !== langName) { // Save current language if it's named and different
                saveData();
            }
            const targetLanguageData = allLanguages.find(lang => lang.name === langName);
            if (targetLanguageData) {
                currentLanguage = ensureDeepStructure(JSON.parse(JSON.stringify(targetLanguageData)), DEFAULT_LANGUAGE_STATE);
                
                // Recalculate next IDs based on the loaded language's content
                nextWordId = calculateNextWordId(currentLanguage.lexicon);
                nextConjCategoryId = calculateNextId(currentLanguage.grammar.morphology.conjugationCategories || [], 'cat_');
                nextConjRuleId = calculateNextId(currentLanguage.grammar.morphology.conjugationRules || [], 'rule_');
                // nextRuleStepId is handled by ensureDeepStructure for the loaded language context
                nextExternalNodeId = calculateNextId(currentLanguage.languageFamily.externalNodes || [], 'ext_');
                nextActiveSoundChangeId = calculateNextId(currentLanguage.phonology.activeSoundChanges || [], 'asc_');
                nextToneId = calculateNextId(currentLanguage.phonology.tones || [], 'tone_');
                nextTonePhonotacticId = calculateNextId(currentLanguage.phonology.tonePhonotactics || [], 'tp_');


                currentLanguageNameDisplay.textContent = currentLanguage.name;
                if (languageSelector.value !== currentLanguage.name) {
                     languageSelector.value = currentLanguage.name; // Ensure selector matches
                }

                mainContent.classList.remove('disabled-section');
                localStorage.setItem('currentLanguageData', JSON.stringify(currentLanguage)); // Save as "active"
                updateUI(); // This will render tabs and switch to the active one.
                console.log(`Switched to language: ${currentLanguage.name}`);
            } else {
                console.error(`Language ${langName} not found.`);
                if (currentLanguage.name && languageSelector.value !== currentLanguage.name) {
                    languageSelector.value = currentLanguage.name; // Revert selector if switch failed
                }
            }
        }

        function saveData() {
            if (currentLanguage.name) { // Only save to allLanguages if current lang is named
                const existingLangIndex = allLanguages.findIndex(lang => lang.name === currentLanguage.name);
                const langToSave = JSON.parse(JSON.stringify(currentLanguage)); // Deep copy

                if (existingLangIndex > -1) {
                    allLanguages[existingLangIndex] = langToSave;
                } else {
                    allLanguages.push(langToSave);
                }
                renderLanguageSelector(); // Update dropdown if new lang added or name changed (though name change isn't UI implemented yet)
                localStorage.setItem('allLanguagesData', JSON.stringify(allLanguages));
            }
            localStorage.setItem('currentLanguageData', JSON.stringify(currentLanguage));
            localStorage.setItem('globalInterLangRules', JSON.stringify(globalInterLangRules)); // Save global rules
            console.log("Autosaved. Current lang:", currentLanguage.name, "All langs count:", allLanguages.length);
        }

        function loadData() {
            // Simulate progress for localStorage loading (since it's fast, this is for UX only)
            setLoadingPercent(10);
            setTimeout(() => {
                const savedAllLangs = localStorage.getItem('allLanguagesData');
                setLoadingPercent(30);
                if (savedAllLangs) {
                    const parsedAllLangs = JSON.parse(savedAllLangs);
                    allLanguages = parsedAllLangs.map(lang => ensureDeepStructure(lang, DEFAULT_LANGUAGE_STATE));
                } else {
                    allLanguages = [];
                }
                setLoadingPercent(50);
                setTimeout(() => {
                    const savedGlobalRules = localStorage.getItem('globalInterLangRules');
                    setLoadingPercent(65);
                    if (savedGlobalRules) {
                        globalInterLangRules = JSON.parse(savedGlobalRules);
                        nextInterLangPairId = calculateNextId(globalInterLangRules || [], 'il_pair_');
                    } else {
                        globalInterLangRules = [];
                    }
                    setLoadingPercent(80);
                    setTimeout(() => {
                        const savedLangData = localStorage.getItem('currentLanguageData');
                        let langToLoad = null;
                        if (savedLangData) {
                            const parsedSavedLang = JSON.parse(savedLangData);
                            if (parsedSavedLang.name) {
                                // Try to find the version from allLanguages first, as it might be more "canonical" if currentLanguageData was stale
                                const foundInAll = allLanguages.find(l => l.name === parsedSavedLang.name);
                                langToLoad = foundInAll ? JSON.parse(JSON.stringify(foundInAll)) : parsedSavedLang;
                            } else {
                                langToLoad = parsedSavedLang;
                            }
                        } else if (allLanguages.length > 0) {
                            langToLoad = JSON.parse(JSON.stringify(allLanguages[0]));
                        }
                        setLoadingPercent(90);
                        if (langToLoad) {
                            currentLanguage = ensureDeepStructure(langToLoad, DEFAULT_LANGUAGE_STATE);
                        } else {
                            currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE); // Fresh default state
                        }
                        // Initialize next IDs based on the loaded currentLanguage
                        nextWordId = calculateNextWordId(currentLanguage.lexicon);
                        nextConjCategoryId = calculateNextId(currentLanguage.grammar.morphology.conjugationCategories || [], 'cat_');
                        nextConjRuleId = calculateNextId(currentLanguage.grammar.morphology.conjugationRules || [], 'rule_');
                        // nextRuleStepId is recalculated within ensureDeepStructure based on the loaded language's content.
                        nextExternalNodeId = calculateNextId(currentLanguage.languageFamily.externalNodes || [], 'ext_');
                        nextActiveSoundChangeId = calculateNextId(currentLanguage.phonology.activeSoundChanges || [], 'asc_');
                        nextToneId = calculateNextId(currentLanguage.phonology.tones || [], 'tone_');
                        nextTonePhonotacticId = calculateNextId(currentLanguage.phonology.tonePhonotactics || [], 'tp_');
                        setLoadingPercent(100);
                        setTimeout(() => {
                            console.log("Data loaded. Current Lang:", currentLanguage.name, "Next Word ID:", nextWordId, "Next RuleStep ID (after load):", nextRuleStepId);
                            renderLanguageSelector(); // Populate dropdown
                            hideLoadingOverlay();
                        }, 200);
                    }, 200);
                }, 200);
            }, 200);
        }
        
        function calculateNextId(itemsArray = [], prefix = '') {
            if (!itemsArray || itemsArray.length === 0) return 1;
            const maxId = itemsArray.reduce((max, item) => {
                // Extract numeric part of ID, e.g., "cat_123" -> 123
                const numPart = item && item.id ? parseInt(String(item.id).replace(prefix, '').match(/\d+$/)?.[0]) : 0;
                return Math.max(max, isNaN(numPart) ? 0 : numPart);
            }, 0);
            return maxId + 1;
        }


        function calculateNextWordId(lexicon = []) {
            if (lexicon && lexicon.length > 0) {
                return lexicon.reduce((max, word) => Math.max(max, word.id || 0), 0) + 1;
            }
            return 1;
        }

        function renderLanguageSelector() {
            if (!languageSelector) return;
            const currentSelectedValue = languageSelector.value; // Preserve selection if possible
            languageSelector.innerHTML = '<option value="" class="bg-white text-gray-700">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>';
            allLanguages.forEach(lang => {
                if (lang.name) { // Only add named languages
                    const option = document.createElement('option');
                    option.value = lang.name;
                    option.textContent = lang.name;
                    option.className = "bg-white text-gray-700";
                    languageSelector.appendChild(option);
                }
            });
            // Try to re-select what was active or previously selected
            if (currentLanguage.name && allLanguages.some(l => l.name === currentLanguage.name)) {
                languageSelector.value = currentLanguage.name;
            } else if (currentSelectedValue && allLanguages.some(l => l.name === currentSelectedValue)) {
                 languageSelector.value = currentSelectedValue; // e.g. after deleting current, reselect previous
            } else if (allLanguages.length > 0 && !currentLanguage.name) { 
                 // If current lang is unnamed (being created) but others exist, selector should show none
                 languageSelector.value = ""; 
            } else { // No current lang name, no previous selection, or current not in list
                 languageSelector.value = "";
            }
        }

        function updateUI() {
            if (currentLanguage && currentLanguage.name) {
                 currentLanguageNameDisplay.textContent = currentLanguage.name;
                 if (languageSelector.value !== currentLanguage.name) languageSelector.value = currentLanguage.name;
                 mainContent.classList.remove('disabled-section');
                 renderTabs(); // Re-render tabs (buttons)
                 switchTab(activeTab); // Re-render content of current tab
            } else if (allLanguages.length === 0 && !currentLanguage.name) { // No languages exist, current is unnamed (fresh start)
                currentLanguageNameDisplay.textContent = 'N/A';
                mainContent.classList.add('disabled-section');
                if (languageNameModal.classList.contains('hidden')) { // If modal was closed somehow without naming
                     languageNameModal.classList.remove('hidden'); // Re-show it
                }
                tabContainer.innerHTML = ''; // No tabs to show
                tabContentContainer.innerHTML = ''; // No content
            } else { // Current language is unnamed (e.g. "Add New" clicked), but other languages might exist
                currentLanguageNameDisplay.textContent = 'N/A';
                if (!languageNameModal.classList.contains('hidden')) { // If name modal is up for the new lang
                    mainContent.classList.add('disabled-section');
                    tabContainer.innerHTML = ''; // No tabs until named
                    tabContentContainer.innerHTML = '';
                } else { // Name modal is hidden (e.g. user closed it, or selected "--‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤--")
                     mainContent.classList.remove('disabled-section'); // Allow interaction with header (like lang selector)
                     tabContainer.innerHTML = ''; // No tabs active for "no language" state
                     tabContentContainer.innerHTML = '<p class="text-center text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏°‡∏ô‡∏π‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà</p>';
                }
            }
        }

        function renderTabs() {
            tabContainer.innerHTML = '';
            tabs.filter(t => !t.disabled).forEach(tab => { // Only render non-disabled tabs
                const button = document.createElement('button');
                button.className = `tab-button py-2 px-4 font-medium text-sm rounded-t-lg border-b-2 whitespace-nowrap ${activeTab === tab.id ? 'active' : ''}`;
                button.innerHTML = `<i class="${tab.icon} mr-2"></i>${tab.name}`;
                button.addEventListener('click', () => switchTab(tab.id));
                tabContainer.appendChild(button);
            });
        }

        function switchTab(tabId) {
            // Prevent tab switching if language name modal is active and language is not yet named
            if (!currentLanguage.name && !languageNameModal.classList.contains('hidden')) {
                console.log("Language not named yet (modal visible), tab switch prevented.");
                return;
            }
             // If language is unnamed, modal is hidden, and no languages exist at all (first run, user closed modal)
             if (!currentLanguage.name && languageNameModal.classList.contains('hidden') && allLanguages.length === 0) {
                 tabContentContainer.innerHTML = '<p class="text-center text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÇ‡∏î‡∏¢‡∏Ñ‡∏•‡∏¥‡∏Å "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà" ‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô</p>';
                 activeTab = tabId; // Still update activeTab conceptually
                 renderTabs(); // Re-render tab buttons to reflect active state
                 return;
            }
             // If language is unnamed, modal is hidden, but other languages *do* exist (e.g. user hit "Add New" then closed modal)
             if (!currentLanguage.name && languageNameModal.classList.contains('hidden') && allLanguages.length > 0) {
                 tabContentContainer.innerHTML = '<p class="text-center text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà</p>';
                 activeTab = tabId;
                 renderTabs();
                 return;
             }


            activeTab = tabId;
            const currentTabDef = tabs.find(t => t.id === tabId);
            const actualContentContainer = document.getElementById('tabContent'); // Ensure we are using the correct one
            if (actualContentContainer) {
                 actualContentContainer.innerHTML = ''; // Clear previous content
                 if (currentTabDef) {
                    const titleEl = document.createElement('h3');
                    titleEl.className = "text-xl font-semibold mb-4 text-purple-700";
                    titleEl.innerHTML = `<i class="${currentTabDef.icon} mr-2"></i>${currentTabDef.name}`;
                    actualContentContainer.appendChild(titleEl);

                    if (typeof currentTabDef.contentFunc === 'function') {
                        currentTabDef.contentFunc(actualContentContainer); // Pass the content container
                    } else {
                        const errorP = document.createElement('p');
                        errorP.textContent = 'Error: Content function not found for this tab.';
                        actualContentContainer.appendChild(errorP);
                    }
                }
            }
            renderTabs(); // Re-render tab buttons to update active state
        }

        function createTextInput(container, label, id, value, placeholder = '', helpText = '', inputType = 'text', listId = null) {
            const div = document.createElement('div');
            div.className = 'mb-3';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-gray-700 mb-1';
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;
            div.appendChild(labelEl);
            const inputEl = document.createElement(inputType === 'textarea' ? 'textarea' : 'input');
            inputEl.type = inputType === 'textarea' ? undefined : inputType;
            inputEl.id = id;
            inputEl.name = id;
            inputEl.className = 'w-full p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500';
            inputEl.placeholder = placeholder;
            if (inputType === 'textarea') inputEl.rows = 3;
            if (listId) inputEl.setAttribute('list', listId);
            inputEl.value = value;
            div.appendChild(inputEl);
            if (helpText) {
                const helpEl = document.createElement('p');
                helpEl.className = 'mt-1 text-xs text-gray-500';
                helpEl.innerHTML = helpText; // Use innerHTML to allow for simple tags in helptext if needed
                div.appendChild(helpEl);
            }
            container.appendChild(div);
            return inputEl;
        }

        function createSelectInput(container, label, id, value, optionsArray, helpText = '', multiple = false) {
            const div = document.createElement('div');
            div.className = 'mb-3';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-gray-700 mb-1';
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;
            div.appendChild(labelEl);
            const selectEl = document.createElement('select');
            selectEl.id = id;
            selectEl.name = id;
            selectEl.className = 'w-full p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500';
            if (multiple) {
                selectEl.multiple = true;
                selectEl.size = Math.min(5, optionsArray.length); // Show a few items for multi-select
            }

            optionsArray.forEach(opt => {
                const option = document.createElement('option');
                if (typeof opt === 'string') {
                    option.value = opt;
                    option.textContent = opt;
                } else { // Expect {value: 'val', text: 'Display Text'}
                    option.value = opt.value;
                    option.textContent = opt.text;
                }
                selectEl.appendChild(option);
            });
            // Set selected value(s)
            if (multiple && Array.isArray(value)) {
                 Array.from(selectEl.options).forEach(opt => {
                    if (value.includes(opt.value)) {
                        opt.selected = true;
                    }
                });
            } else {
                selectEl.value = value;
            }
            div.appendChild(selectEl);
             if (helpText) {
                const helpEl = document.createElement('p');
                helpEl.className = 'mt-1 text-xs text-gray-500';
                helpEl.innerHTML = helpText;
                div.appendChild(helpEl);
            }
            container.appendChild(div);
            return selectEl;
        }
        
        function createCheckboxInput(container, label, id, checked, helpText = '', onChangeCallback = null) {
            const div = document.createElement('div');
            div.className = 'mb-3 flex items-center';
            const inputEl = document.createElement('input');
            inputEl.type = 'checkbox';
            inputEl.id = id;
            inputEl.name = id;
            inputEl.className = 'h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 mr-2';
            inputEl.checked = checked;
            if (onChangeCallback) {
                inputEl.onchange = onChangeCallback;
            }
            div.appendChild(inputEl);
            const labelEl = document.createElement('label');
            labelEl.className = 'text-sm font-medium text-gray-700';
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;
            div.appendChild(labelEl);
            if (helpText) {
                const helpEl = document.createElement('p');
                helpEl.className = 'ml-2 text-xs text-gray-500'; // Adjust margin if needed
                helpEl.innerHTML = helpText;
                div.appendChild(helpEl);
            }
            container.appendChild(div);
            return inputEl;
        }

        function createListInput(container, label, itemsArray, placeholder, addItemCallback, removeItemCallback, itemDisplayFunc = null, helpText = '', inputType = 'text', datalistId = null) {
            const section = document.createElement('div');
            section.className = 'mb-4 p-3 border border-purple-200 rounded-md bg-purple-50';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-purple-700 mb-1';
            labelEl.textContent = label;
            section.appendChild(labelEl);
            if (helpText) {
                const helpP = document.createElement('p');
                helpP.className = 'text-xs text-gray-500 mb-2';
                helpP.innerHTML = helpText;
                section.appendChild(helpP);
            }

            const listContainer = document.createElement('div');
            listContainer.className = 'flex flex-wrap gap-2 mb-2';
            (itemsArray || []).forEach((item, index) => {
                const chip = document.createElement('span');
                chip.className = 'bg-purple-500 text-white px-2 py-1 rounded-full text-xs flex items-center';
                chip.innerHTML = itemDisplayFunc ? itemDisplayFunc(item) : (typeof item === 'string' ? item : JSON.stringify(item));
                const removeBtn = document.createElement('button');
                removeBtn.className = 'ml-2 text-purple-200 hover:text-white';
                removeBtn.innerHTML = '&times;';
                removeBtn.onclick = (e) => { e.stopPropagation(); removeItemCallback(index); }; // Prevent form submission if inside form
                chip.appendChild(removeBtn);
                listContainer.appendChild(chip);
            });
            section.appendChild(listContainer);

            const inputGroup = document.createElement('div');
            inputGroup.className = 'flex gap-2';
            const inputEl = document.createElement('input');
            inputEl.type = inputType;
            if (datalistId) inputEl.setAttribute('list', datalistId);
            inputEl.className = 'w-full p-2 border border-purple-300 rounded-md focus:ring-purple-500 focus:border-transparent';
            inputEl.placeholder = placeholder;
            inputEl.onkeypress = (e) => { if (e.key === 'Enter') { addBtn.click(); e.preventDefault(); }}; // Add on Enter
            const addBtn = document.createElement('button');
            addBtn.type = "button"; // Ensure it doesn't submit forms by default
            addBtn.className = 'btn-secondary px-3 py-1 rounded-md text-sm';
            addBtn.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°';
            addBtn.onclick = () => {
                if (inputEl.value.trim()) {
                    addItemCallback(inputEl.value.trim());
                    inputEl.value = ''; // Clear after adding
                }
            };
            inputGroup.appendChild(inputEl);
            inputGroup.appendChild(addBtn);
            section.appendChild(inputGroup);
            container.appendChild(section);
            return section; // Return the whole section for further manipulation if needed
        }
        
        function createCheckboxList(container, label, allItems, selectedItems, updateCallback, helpText = '', options = {}) {
            const section = document.createElement('div');
            section.className = 'mb-4 p-3 border border-purple-200 rounded-md bg-purple-50';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center mb-2';
            const labelEl = document.createElement('label');
            labelEl.className = 'block text-sm font-medium text-purple-700';
            labelEl.textContent = label;
            headerDiv.appendChild(labelEl);

            if (options.showSelectAll) {
                const selectButtonsDiv = document.createElement('div');
                selectButtonsDiv.className = 'flex gap-2';
                const selectAllBtn = document.createElement('button');
                selectAllBtn.type = "button";
                selectAllBtn.textContent = '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
                selectAllBtn.className = 'text-xs btn-secondary bg-purple-300 hover:bg-purple-400 text-purple-800 px-2 py-0.5 rounded';
                selectAllBtn.onclick = () => {
                    allItems.forEach(item => {
                        if (!selectedItems.includes(item)) {
                            updateCallback(item, true, true); // true for batch update
                        }
                    });
                    if (options.onSelectAllDeselectAll) options.onSelectAllDeselectAll(); // Call general refresh
                };
                selectButtonsDiv.appendChild(selectAllBtn);

                const deselectAllBtn = document.createElement('button');
                deselectAllBtn.type = "button";
                deselectAllBtn.textContent = '‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
                deselectAllBtn.className = 'text-xs btn-secondary bg-gray-300 hover:bg-gray-400 text-gray-800 px-2 py-0.5 rounded';
                deselectAllBtn.onclick = () => {
                    allItems.forEach(item => {
                        if (selectedItems.includes(item)) {
                             updateCallback(item, false, true); // true for batch update
                        }
                    });
                    if (options.onSelectAllDeselectAll) options.onSelectAllDeselectAll();
                };
                selectButtonsDiv.appendChild(deselectAllBtn);
                headerDiv.appendChild(selectButtonsDiv);
            }
            section.appendChild(headerDiv);

            if (helpText) {
                const helpP = document.createElement('p');
                helpP.className = 'text-xs text-gray-500 mb-2';
                helpP.innerHTML = helpText;
                section.appendChild(helpP);
            }

            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2';
            
            allItems.forEach(item => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'flex items-center';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `chk_${label.replace(/\s+/g, '')}_${item.replace(/[^a-zA-Z0-9]/g, "")}`; // Make ID more robust
                checkbox.value = item;
                checkbox.className = 'h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 mr-1.5';
                checkbox.checked = selectedItems.includes(item);
                checkbox.onchange = (e) => {
                    updateCallback(item, e.target.checked); // Individual update
                };
                
                const itemLabel = document.createElement('label');
                itemLabel.setAttribute('for', checkbox.id);
                itemLabel.className = 'text-sm text-gray-700';
                itemLabel.textContent = item;
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(itemLabel);
                gridContainer.appendChild(checkboxDiv);
            });
            section.appendChild(gridContainer);
            container.appendChild(section);
        }




        function renderPhonologyUI(container) {
            

            const phonology = currentLanguage.phonology;

            // Section: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∞
            let countSection = container.querySelector('#phonemeCountSection');
            if (!countSection) {
                countSection = document.createElement('div');
                countSection.id = 'phonemeCountSection';
                countSection.className = 'flex gap-4 mb-2';
                container.prepend(countSection);
            }
            function updatePhonemeCounts() {
                const cCount = (phonology.consonants || []).length;
                const vCount = (phonology.vowels || []).length;
                let html = `
                    <span class='text-sm'>‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ <span class='px-2 py-1 rounded bg-purple-100 text-purple-700 font-semibold'>${cCount}</span> ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
                    <span class='text-sm'>‡∏™‡∏£‡∏∞ <span class='px-2 py-1 rounded bg-purple-100 text-purple-700 font-semibold'>${vCount}</span> ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
                `;
                if (phonology.hasTones && Array.isArray(phonology.tones) && phonology.tones.length > 0) {
                    html += `<span class='text-sm'>‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå <span class='px-2 py-1 rounded bg-purple-100 text-purple-700 font-semibold'>${phonology.tones.length}</span> ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>`;
                }
                countSection.innerHTML = html;
            }
            updatePhonemeCounts();

            // Ensure all phonology sub-properties exist, defaulting from DEFAULT_LANGUAGE_STATE
            phonology.allowedInitialConsonants = phonology.allowedInitialConsonants || [...(DEFAULT_LANGUAGE_STATE.phonology.allowedInitialConsonants.length > 0 ? DEFAULT_LANGUAGE_STATE.phonology.allowedInitialConsonants : phonology.consonants)];
            phonology.allowVowelInitial = phonology.allowVowelInitial === undefined ? DEFAULT_LANGUAGE_STATE.phonology.allowVowelInitial : phonology.allowVowelInitial;
            phonology.forbiddenInitialSounds = phonology.forbiddenInitialSounds || [...DEFAULT_LANGUAGE_STATE.phonology.forbiddenInitialSounds];
            phonology.allowedConsonantClusters = phonology.allowedConsonantClusters || [...DEFAULT_LANGUAGE_STATE.phonology.allowedConsonantClusters];
            phonology.forbiddenConsonantClusters = phonology.forbiddenConsonantClusters || [...DEFAULT_LANGUAGE_STATE.phonology.forbiddenConsonantClusters];
            phonology.maxClusterLength = phonology.maxClusterLength || DEFAULT_LANGUAGE_STATE.phonology.maxClusterLength;
            phonology.allowedFinalConsonants = phonology.allowedFinalConsonants || [...(DEFAULT_LANGUAGE_STATE.phonology.allowedFinalConsonants.length > 0 ? DEFAULT_LANGUAGE_STATE.phonology.allowedFinalConsonants : phonology.consonants.filter(c => ['m','n','≈ã','p','t','k','s'].includes(c)))];
            phonology.allowNoCoda = phonology.allowNoCoda === undefined ? DEFAULT_LANGUAGE_STATE.phonology.allowNoCoda : phonology.allowNoCoda;
            phonology.forbiddenFinalSounds = phonology.forbiddenFinalSounds || [...DEFAULT_LANGUAGE_STATE.phonology.forbiddenFinalSounds];
            phonology.allowClusterCoda = phonology.allowClusterCoda === undefined ? DEFAULT_LANGUAGE_STATE.phonology.allowClusterCoda : phonology.allowClusterCoda;
            phonology.allowedCodaClusters = phonology.allowedCodaClusters || [...DEFAULT_LANGUAGE_STATE.phonology.allowedCodaClusters];
            phonology.hasTones = phonology.hasTones === undefined ? DEFAULT_LANGUAGE_STATE.phonology.hasTones : phonology.hasTones;
            phonology.tones = phonology.tones || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.tones));
             phonology.tones.forEach(tone => { // Ensure new property exists on old data
                if (tone.hideInOrthography === undefined) tone.hideInOrthography = false;
            });
            phonology.tonePhonotactics = phonology.tonePhonotactics || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.tonePhonotactics));
            phonology.graphemeMappings = phonology.graphemeMappings || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.graphemeMappings));
            phonology.activeSoundChanges = phonology.activeSoundChanges || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.activeSoundChanges));
            phonology.syllableStructures = phonology.syllableStructures || [...DEFAULT_LANGUAGE_STATE.phonology.syllableStructures];
            phonology.phonotactics = phonology.phonotactics || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.phonology.phonotactics));

            // Data cleaning: ensure selected phonemes/clusters exist in the main inventory
            const currentConsonants = phonology.consonants || [];
            const currentVowels = phonology.vowels || [];
            const allCurrentPhonemes = [...currentConsonants, ...currentVowels];

            phonology.allowedInitialConsonants = (phonology.allowedInitialConsonants || []).filter(c => currentConsonants.includes(c));
            phonology.forbiddenInitialSounds = (phonology.forbiddenInitialSounds || []).filter(s => allCurrentPhonemes.includes(s));
            phonology.allowedConsonantClusters = (phonology.allowedConsonantClusters || []).filter(cl => cl.split('').every(c => currentConsonants.includes(c)));
            
            phonology.allowedFinalConsonants = (phonology.allowedFinalConsonants || []).filter(c => currentConsonants.includes(c));
            phonology.forbiddenFinalSounds = (phonology.forbiddenFinalSounds || []).filter(s => allCurrentPhonemes.includes(s));
            phonology.allowedCodaClusters = (phonology.allowedCodaClusters || []).filter(cl => cl.split('').every(c => currentConsonants.includes(c)));
            
            phonology.graphemeMappings = (phonology.graphemeMappings || []).filter(gm => allCurrentPhonemes.includes(gm.sound));

            phonology.tonePhonotactics = (phonology.tonePhonotactics || []).map(tpRule => ({
                ...tpRule,
                initials: (tpRule.initials || []).filter(i => currentConsonants.includes(i)),
                finals: (tpRule.finals || []).filter(f => currentConsonants.includes(f))
            })).filter(tpRule => (tpRule.initials && tpRule.initials.length > 0) || (tpRule.finals && tpRule.finals.length > 0) || (tpRule.forbiddenTones && tpRule.forbiddenTones.length > 0) || (tpRule.description && tpRule.description.length > 0) ); // Keep if any part has data


            const phonologyContainerId = 'phonologyTabSpecificContent';
            let phonologyContainer = container.querySelector(`#${phonologyContainerId}`);
            if (!phonologyContainer) {
                phonologyContainer = document.createElement('div');
                phonologyContainer.id = phonologyContainerId;
                container.appendChild(phonologyContainer);
            }
            phonologyContainer.innerHTML = ''; // Clear for re-render

            // Datalist for phoneme suggestions
            const phonemeDatalistId = `phonemeDatalist_${Date.now()}`;
            let phonemeOptions = '';
            const allPhonemes = [...new Set([...phonology.consonants, ...phonology.vowels])];
            allPhonemes.forEach(p => phonemeOptions += `<option value="${p}"></option>`);
            phonologyContainer.innerHTML += `<datalist id="${phonemeDatalistId}">${phonemeOptions}</datalist>`;

            const basicPhonemesSection = document.createElement('div');
            basicPhonemesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            basicPhonemesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">1. ‡∏ä‡∏∏‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (Phonemic Inventory)</h4>`;
            createListInput(basicPhonemesSection, 'üó£Ô∏è ‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ (Consonants)', phonology.consonants, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ (‡πÄ‡∏ä‡πà‡∏ô p, t, k)",
                (item) => { phonology.consonants.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.consonants.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            createListInput(basicPhonemesSection, 'üé§ ‡∏™‡∏£‡∏∞ (Vowels)', phonology.vowels, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞ (‡πÄ‡∏ä‡πà‡∏ô a, i, u)",
                (item) => { phonology.vowels.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.vowels.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            phonologyContainer.appendChild(basicPhonemesSection);

            const ipaChartsSection = document.createElement('div');
            ipaChartsSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            ipaChartsSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">2. ‡∏ï‡∏≤‡∏£‡∏≤‡∏á IPA (‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•)</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><h5 class="font-medium text-purple-600 mb-1">‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞ IPA</h5><div id="ipaConsonantChartContainerPhonology"></div></div>
                    <div><h5 class="font-medium text-purple-600 mb-1">‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏£‡∏∞ IPA</h5><div id="ipaVowelChartContainerPhonology"></div></div>
                </div>`;
            phonologyContainer.appendChild(ipaChartsSection);
            renderDynamicIPACharts(phonology.consonants, phonology.vowels); // Call to render charts

            const consonantRolesSection = document.createElement('div');
            consonantRolesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            consonantRolesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">3. ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå</h4>`;
            
            const initialCSection = document.createElement('div');
            initialCSection.className = 'mb-3 p-2 border-t pt-3';
            createCheckboxList(initialCSection, '‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Allowed Initial Consonants):', phonology.consonants, phonology.allowedInitialConsonants, 
                (item, isChecked, batchUpdate) => {
                    if (isChecked) { if (!phonology.allowedInitialConsonants.includes(item)) phonology.allowedInitialConsonants.push(item); } 
                    else { phonology.allowedInitialConsonants = phonology.allowedInitialConsonants.filter(c => c !== item); }
                    if (!batchUpdate) { saveData(); renderPhonologyUI(container); } // Re-render only if not batch
                }, '', { showSelectAll: true, onSelectAllDeselectAll: () => { saveData(); renderPhonologyUI(container); } }
            );
            createCheckboxInput(initialCSection, '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏™‡∏£‡∏∞ (Vowel-Initial Words)', 'allowVowelInitialPhonology', phonology.allowVowelInitial, '', (e) => {
                phonology.allowVowelInitial = e.target.checked; saveData();
            });
            createListInput(initialCSection, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≤‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô (Forbidden Initial Sounds)', phonology.forbiddenInitialSounds, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏ä‡πà‡∏ô ≈ã)",
                (item) => { phonology.forbiddenInitialSounds.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.forbiddenInitialSounds.splice(index, 1); renderPhonologyUI(container); saveData(); }, null, '', 'text', phonemeDatalistId
            );
            consonantRolesSection.appendChild(initialCSection);

            const clusterSection = document.createElement('div');
            clusterSection.className = 'mb-3 p-2 border-t pt-3';
            clusterSection.innerHTML = `<h5 class="font-medium text-purple-600 mb-2">‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥ (Consonant Clusters)</h5>`;
             createListInput(clusterSection, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Allowed Clusters)', phonology.allowedConsonantClusters, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏° (‡πÄ‡∏ä‡πà‡∏ô kr, spl)",
                (item) => { phonology.allowedConsonantClusters.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.allowedConsonantClusters.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            createListInput(clusterSection, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Forbidden Clusters)', phonology.forbiddenConsonantClusters, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏´‡πâ‡∏≤‡∏° (‡πÄ‡∏ä‡πà‡∏ô tl)",
                (item) => { phonology.forbiddenConsonantClusters.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.forbiddenConsonantClusters.splice(index, 1); renderPhonologyUI(container); saveData(); }
            );
            const maxClusterLengthInput = createTextInput(clusterSection, '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥:', 'maxClusterLengthPhonology', phonology.maxClusterLength, '‡πÄ‡∏ä‡πà‡∏ô 2 ‡∏´‡∏£‡∏∑‡∏≠ 3', '', 'number');
            maxClusterLengthInput.min = 2; maxClusterLengthInput.max = 5; // Sensible limits
            maxClusterLengthInput.onchange = (e) => { phonology.maxClusterLength = parseInt(e.target.value) || 2; saveData(); };
            consonantRolesSection.appendChild(clusterSection);

            const finalCSection = document.createElement('div');
            finalCSection.className = 'mb-3 p-2 border-t pt-3';
            createCheckboxList(finalCSection, '‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (Allowed Final Consonants):', phonology.consonants, phonology.allowedFinalConsonants,
                (item, isChecked, batchUpdate) => {
                    if (isChecked) { if (!phonology.allowedFinalConsonants.includes(item)) phonology.allowedFinalConsonants.push(item); }
                    else { phonology.allowedFinalConsonants = phonology.allowedFinalConsonants.filter(c => c !== item); }
                    if (!batchUpdate) { saveData(); renderPhonologyUI(container); }
                }, '', { showSelectAll: true, onSelectAllDeselectAll: () => { saveData(); renderPhonologyUI(container); } }
            );
            createCheckboxInput(finalCSection, '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Allow No Coda / Open Syllables)', 'allowNoCodaPhonology', phonology.allowNoCoda, '', (e) => {
                phonology.allowNoCoda = e.target.checked; saveData();
            });
            createListInput(finalCSection, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Forbidden Final Sounds)', phonology.forbiddenFinalSounds, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏ä‡πà‡∏ô s ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ /s/ ‡∏™‡∏∞‡∏Å‡∏î)",
                (item) => { phonology.forbiddenFinalSounds.push(item); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.forbiddenFinalSounds.splice(index, 1); renderPhonologyUI(container); saveData(); }, null, '', 'text', phonemeDatalistId
            );
            createCheckboxInput(finalCSection, '‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Allow Consonant Clusters as Coda)', 'allowClusterCodaPhonology', phonology.allowClusterCoda, '', (e) => {
                phonology.allowClusterCoda = e.target.checked; renderPhonologyUI(container); saveData();
            });
            if (phonology.allowClusterCoda) {
                 createListInput(finalCSection, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Å‡∏•‡πâ‡∏≥‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î (Allowed Coda Clusters)', phonology.allowedCodaClusters, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏° (‡πÄ‡∏ä‡πà‡∏ô nt, lk)",
                    (item) => { phonology.allowedCodaClusters.push(item); renderPhonologyUI(container); saveData(); },
                    (index) => { phonology.allowedCodaClusters.splice(index, 1); renderPhonologyUI(container); saveData(); }
                );
            }

            consonantRolesSection.appendChild(finalCSection);

            createListInput(consonantRolesSection, 'üß± ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå (Syllable Structures)', phonology.syllableStructures, "‡πÄ‡∏ä‡πà‡∏ô CV, CVC, CCVVC",
                (item) => { phonology.syllableStructures.push(item.toUpperCase()); renderPhonologyUI(container); saveData(); },
                (index) => { phonology.syllableStructures.splice(index, 1); renderPhonologyUI(container); saveData(); },
                null, "C = ‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞, V = ‡∏™‡∏£‡∏∞"
            );
            phonologyContainer.appendChild(consonantRolesSection);


            const tonesSection = document.createElement('div');
            tonesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            tonesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">4. ‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå (Tones)</h4>`;
            createCheckboxInput(tonesSection, '‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå (Enable Tones)', 'hasTonesPhonology', phonology.hasTones, '', (e) => {
                phonology.hasTones = e.target.checked;
                renderPhonologyUI(container); saveData();
            });

            if (phonology.hasTones) {
                // Diacritics toggle
                if (typeof phonology.useDiacritics === 'undefined') phonology.useDiacritics = false;
                const diacriticsToggleDiv = document.createElement('div');
                diacriticsToggleDiv.className = 'mb-2';
                diacriticsToggleDiv.innerHTML = `<label class="flex items-center text-xs"><input type="checkbox" id="useDiacriticsPhonology" class="mr-2" ${phonology.useDiacritics ? 'checked' : ''}>‡πÉ‡∏ä‡πâ diacritics (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ö‡∏ô‡∏´‡∏±‡∏ß‡∏™‡∏£‡∏∞)</label>`;
                tonesSection.appendChild(diacriticsToggleDiv);
                setTimeout(() => {
                    const chk = document.getElementById('useDiacriticsPhonology');
                    if (chk) {
                        chk.onchange = (e) => {
                            phonology.useDiacritics = e.target.checked;
                            saveData();
                            renderPhonologyUI(container);
                        };
                    }
                }, 0);

                const toneManagementDiv = document.createElement('div');
                toneManagementDiv.id = 'toneManagementSectionPhonology';
                toneManagementDiv.className = 'mt-2 p-2 border-t';

                const tonesListDiv = document.createElement('div');
                tonesListDiv.className = 'mb-2 space-y-1';
                (phonology.tones || []).forEach((tone, idx) => {
                    const toneDisplay = document.createElement('div');
                    toneDisplay.className = 'flex flex-col sm:flex-row sm:justify-between sm:items-center bg-white p-1.5 rounded border text-sm gap-1';
                    let diacriticsDropdown = '';
                    if (phonology.useDiacritics) {
                        // Default diacritics mapping
                        if (typeof tone.diacritic === 'undefined') {
                            const defaultMap = {1:'`',2:'¬¥',3:'ÀÜ',4:'Àá'};
                            tone.diacritic = defaultMap[tone.number] || '';
                        }
                        diacriticsDropdown = '<select class="diacritics-select" data-tone-idx="'+idx+'">'
                            + '<option value="">(‡πÑ‡∏°‡πà‡∏°‡∏µ)</option>'
                            + '<option value="&#x60;"'+(tone.diacritic==='`'?' selected':'')+'>` (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏≠‡∏Å)</option>'
                            + '<option value="&#xB4;"'+(tone.diacritic==='¬¥'?' selected':'')+'>¬¥ (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÇ‡∏ó)</option>'
                            + '<option value="&#x2C6;"'+(tone.diacritic==='ÀÜ'?' selected':'')+'>ÀÜ (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡∏£‡∏µ)</option>'
                            + '<option value="&#x2C7;"'+(tone.diacritic==='Àá'?' selected':'')+'>Àá (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏à‡∏±‡∏ï‡∏ß‡∏≤)</option>'
                            + '</select>';
                    }
                    toneDisplay.innerHTML = '<div><span>' + tone.name + ' (‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå: ' + (tone.representation || tone.symbol || 'N/A') + ', ‡πÄ‡∏•‡∏Ç: ' + (tone.number !== undefined ? tone.number : (tone.value || 'N/A')) + ')' + (tone.hideInOrthography ? '<em class="text-xs text-gray-500">(‡∏ã‡πà‡∏≠‡∏ô‡∏£‡∏π‡∏õ)</em>' : '') + '</span>' + (phonology.useDiacritics ? ' <span class="ml-2 text-xs">diacritics: </span>' + diacriticsDropdown : '') + '</div>'
                        + '<button class="text-red-500 hover:text-red-700 text-xs tone-delete-btn" data-tone-idx="'+idx+'">&times; ‡∏•‡∏ö</button>';
                    tonesListDiv.appendChild(toneDisplay);
                });
                toneManagementDiv.appendChild(tonesListDiv);
                // Add delete event and diacritics event
                setTimeout(() => {
                    tonesListDiv.querySelectorAll('.tone-delete-btn').forEach(btn => {
                        btn.onclick = (e) => {
                            const idx = parseInt(btn.getAttribute('data-tone-idx'));
                            if (phonology.tones.length > 1) {
                                phonology.tones.splice(idx, 1);
                                saveData();
                                renderPhonologyUI(container);
                            } else {
                                alert('‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡πÄ‡∏™‡∏µ‡∏¢‡∏á');
                            }
                        };
                    });
                    if (phonology.useDiacritics) {
                        tonesListDiv.querySelectorAll('.diacritics-select').forEach(sel => {
                            sel.onchange = (e) => {
                                const idx = parseInt(sel.getAttribute('data-tone-idx'));
                                phonology.tones[idx].diacritic = sel.value;
                                saveData();
                            };
                        });
                    }
                }, 0);

                const addToneForm = document.createElement('div');
                addToneForm.className = 'grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2 items-end p-2 border bg-purple-100 rounded';
                addToneForm.innerHTML = '<div class="flex-grow"><label class="text-xs">‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå:</label><input type="text" id="newToneNamePhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏≠‡∏Å" class="w-full p-1 border rounded text-sm"></div>'
                    + '<div class="flex-grow"><label class="text-xs">‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå (‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•):</label><input type="text" id="newToneRepresentationPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô ¬π ‡∏´‡∏£‡∏∑‡∏≠ L" class="w-full p-1 border rounded text-sm"></div>'
                    + '<div><label class="text-xs">‡πÄ‡∏•‡∏Ç‡πÅ‡∏ó‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á:</label>'
                    + '<select id="newToneNumberPhonology" class="w-full p-1 border rounded text-sm">'
                    + '<option value="0">0 (‡∏™‡∏≤‡∏°‡∏±‡∏ç/‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ)</option>'
                    + '<option value="1">1 (‡πÄ‡∏≠‡∏Å)</option>'
                    + '<option value="2">2 (‡πÇ‡∏ó)</option>'
                    + '<option value="3">3 (‡∏ï‡∏£‡∏µ)</option>'
                    + '<option value="4">4 (‡∏à‡∏±‡∏ï‡∏ß‡∏≤)</option>'
                    + '<option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option>'
                    + '</select></div>'
                    + (phonology.useDiacritics ? '<div class="flex-grow"><label class="text-xs">diacritics:</label><input type="text" id="newToneDiacriticPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô &#x60;" class="w-full p-1 border rounded text-sm"></div>' : '')
                    + '<div class="flex items-center mt-1 md:mt-0"><input type="checkbox" id="newToneHideInOrthographyPhonology" class="h-3.5 w-3.5 mr-1"><label for="newToneHideInOrthographyPhonology" class="text-xs">‡∏ã‡πà‡∏≠‡∏ô‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ</label></div>'
                    + '<button id="addToneButtonPhonology" class="btn-secondary px-2 py-1 rounded text-sm self-end sm:col-span-2 md:col-auto">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå</button>';
                toneManagementDiv.appendChild(addToneForm);
                tonesSection.appendChild(toneManagementDiv);

                // Add event for add button
                setTimeout(() => {
                    const addBtn = document.getElementById('addToneButtonPhonology');
                    if (addBtn) {
                        addBtn.onclick = () => {
                            const name = document.getElementById('newToneNamePhonology').value.trim();
                            const representation = document.getElementById('newToneRepresentationPhonology').value.trim();
                            const number = document.getElementById('newToneNumberPhonology').value;
                            const hide = document.getElementById('newToneHideInOrthographyPhonology').checked;
                            let diacritic = '';
                            if (phonology.useDiacritics) {
                                const dInput = document.getElementById('newToneDiacriticPhonology');
                                if (dInput) diacritic = dInput.value.trim();
                            }
                            if (!name) { alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå'); return; }
                            if (phonology.tones.some(t => (t.number !== undefined ? String(t.number) : t.value) === number)) { alert('‡πÄ‡∏•‡∏Ç‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ã‡πâ‡∏≥'); return; }
                            const newTone = { name, representation, number: parseInt(number), hideInOrthography: hide };
                            if (phonology.useDiacritics) newTone.diacritic = diacritic;
                            phonology.tones.push(newTone);
                            saveData();
                            renderPhonologyUI(container);
                        };
                    }
                }, 0);
            }
            phonologyContainer.appendChild(tonesSection);


            const graphemeMappingSection = document.createElement('div');
            graphemeMappingSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            graphemeMappingSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">5. ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ (Grapheme Mappings)</h4>
                <p class="text-xs text-gray-500 mb-2">‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏•‡∏∞‡∏ï‡∏¥‡∏ô‡πÅ‡∏ï‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏∞‡∏Å‡∏î‡πÅ‡∏ö‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô</p>
                <p class="text-xs text-gray-500 mb-2">
                    ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ (transliterate) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞:
                    <ul class="list-disc list-inside ml-4 text-xs text-gray-500">
                        <li>‡∏´‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πâ‡∏ô‡∏Ñ‡∏≥ ‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å "‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô" (Initial Graphemes)</li>
                        <li>‡∏´‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ó‡πâ‡∏≤‡∏¢‡∏Ñ‡∏≥ ‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å "‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢" (Final Graphemes)</li>
                       </p>
                <div id="graphemeMappingListPhonology" class="space-y-3 mb-3 max-h-72 overflow-y-auto p-2 bg-white rounded"></div>
                <div class="flex flex-wrap gap-2 items-end p-2 border bg-purple-100 rounded">
                    <div class="flex-grow min-w-[100px]"><label class="text-xs">‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phoneme):</label><input type="text" id="graphemeMapSoundPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô k, a" class="w-full p-1 border rounded text-sm" list="${phonemeDatalistId}"></div>
                    <div class="flex-grow"><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô (Initial Graphemes - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="graphemeMapInitialPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô k, c" class="w-full p-1 border rounded text-sm"></div>
                    <div class="flex-grow"><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢ (Final Graphemes - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="graphemeMapFinalPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô ck, k" class="w-full p-1 border rounded text-sm"></div>
                     <div class="flex-grow"><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏£‡∏∞/‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (Vowel/General Graphemes - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,):</label><input type="text" id="graphemeMapVowelPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô a, ah" class="w-full p-1 border rounded text-sm"></div>
                    <button id="addGraphemeMapButtonPhonology" class="btn-secondary px-2 py-1 rounded text-sm self-end">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà</button>
                </div>`;
            phonologyContainer.appendChild(graphemeMappingSection);
            renderGraphemeMappingsList();


            const activeSCRulesSection = document.createElement('div');
            activeSCRulesSection.className = 'mb-6 p-4 border border-purple-300 rounded-lg bg-purple-50';
            activeSCRulesSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">6. ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Active Sound Change Rules)</h4>
                <p class="text-xs text-gray-500 mb-2">‡∏Å‡∏é‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏ú‡∏•‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏©‡∏≤</p>
                <p class="text-xs text-gray-500 mb-2">X ‚Üí Y / A _ B ‡∏≠‡πà‡∏≤‡∏ô‡∏ß‡πà‡∏≤ "‡πÄ‡∏™‡∏µ‡∏¢‡∏á X ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Y ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á A ‡∏Å‡∏±‡∏ö B</p>
                <p class="text-xs text-gray-500 mb-2">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á</p>
                 <p class="text-xs text-gray-500 mb-2">/t/ ‚Üí [s] / _ i ‚Üí ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô /t/ ‡πÄ‡∏õ‡πá‡∏ô /s/ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡∏™‡∏£‡∏∞ /i/</p>
                  <p class="text-xs text-gray-500 mb-2">/n/ ‚Üí [≈ã] / _ k ‚Üí /n/ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô /≈ã/ ‡∏ñ‡πâ‡∏≤‡∏ï‡∏≤‡∏°‡∏î‡πâ‡∏ß‡∏¢ /k/</p>
</p>
                <div id="activeSoundChangesListPhonology" class="space-y-1 mb-3 max-h-72 overflow-y-auto"></div>
                <div class="p-2 border bg-purple-100 rounded">
                    <h5 class="font-medium text-purple-600 mb-1">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡πÉ‡∏´‡∏°‡πà:</h5>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-3 gap-y-2 items-end">
                        <div><label class="text-xs">‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (From X):</label><input type="text" id="activeSCFromPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô t" class="w-full p-1 border rounded text-sm" list="${phonemeDatalistId}"></div>
                        <div><label class="text-xs">‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (To Y):</label><input type="text" id="activeSCToPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô s" class="w-full p-1 border rounded text-sm" list="${phonemeDatalistId}"></div>
                        <div><label class="text-xs">‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ (Context A_):</label><input type="text" id="activeSCContextPrePhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô # (word start), V (vowel)" class="w-full p-1 border rounded text-sm"></div>
                        <div><label class="text-xs">‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á (_B Context):</label><input type="text" id="activeSCContextPostPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô i, # (word end)" class="w-full p-1 border rounded text-sm"></div>
                        <div class="md:col-span-2"><label class="text-xs">‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏é:</label><input type="text" id="activeSCDescPhonology" placeholder="‡πÄ‡∏ä‡πà‡∏ô t > s / _i" class="w-full p-1 border rounded text-sm"></div>
                    </div>
                    <button id="addActiveSCRuleButtonPhonology" class="btn-secondary px-3 py-1.5 rounded text-sm mt-2">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á</button>
                </div>
                <div class="mt-4 p-2 border-t">
                    <h5 class="font-medium text-purple-600 mb-1">‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏é:</h5>
                    <input type="text" id="testActiveSCWordPhonology" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏î‡∏™‡∏≠‡∏ö (‡∏£‡∏π‡∏õ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á)" class="w-full p-1.5 border rounded text-sm mb-1">
                    <button id="applyActiveSCRulesTestBtnPhonology" class="btn-primary px-3 py-1 rounded text-sm">‡∏ó‡∏î‡∏™‡∏≠‡∏ö</button>
                    <div id="testActiveSCResultPhonology" class="mt-2 p-2 bg-white rounded border text-sm min-h-[50px]">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà...</div>
                </div>`;
            phonologyContainer.appendChild(activeSCRulesSection);
            renderActiveSoundChangesList();

            const phonotacticsSection = document.createElement('div');
            phonotacticsSection.className = 'mb-4 p-4 border border-purple-300 rounded-lg bg-purple-50';
            phonotacticsSection.innerHTML = `<h4 class="text-lg font-semibold text-purple-700 mb-3">7. ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (General Phonotactics)</h4>`;
            const rulesList = document.createElement('div');
            (phonology.phonotactics || []).forEach((rule, index) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'flex items-center justify-between p-2 mb-1 bg-white rounded border border-purple-100';
                ruleDiv.innerHTML = `
                    <span class="text-sm ${rule.enabled ? 'text-green-600' : 'text-red-600'}">${rule.rule} ${rule.custom && rule.pattern ? `(${rule.pattern})` : ''}</span>
                    <div>
                        <button class="text-xs ${rule.enabled ? 'bg-yellow-400 hover:bg-yellow-500' : 'bg-green-400 hover:bg-green-500'} text-white px-2 py-1 rounded" onclick="togglePhonotacticRule(${index})">${rule.enabled ? '‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : '‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'}</button>
                        ${rule.custom ? `<button class="text-xs bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded ml-1" onclick="removeCustomPhonotacticRule(${index})">‡∏•‡∏ö</button>` : ''}
                    </div>
                `;
                rulesList.appendChild(ruleDiv);
            });
            phonotacticsSection.appendChild(rulesList);

            const addRuleGroup = document.createElement('div');
            addRuleGroup.className = 'mt-3 flex gap-2 items-center flex-wrap p-2 border-t';
            const ruleDescInput = document.createElement('input');
            ruleDescInput.type = 'text';
            ruleDescInput.placeholder = "‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏é (‡πÄ‡∏ä‡πà‡∏ô ‡∏´‡πâ‡∏≤‡∏° m ‡∏™‡∏∞‡∏Å‡∏î)";
            ruleDescInput.className = 'flex-grow p-2 border border-purple-300 rounded-md min-w-[200px]';
            const rulePatternInput = document.createElement('input');
            rulePatternInput.type = 'text';
            rulePatternInput.placeholder = "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö (‡πÄ‡∏ä‡πà‡∏ô *m# ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö regex)"; 
            rulePatternInput.className = 'flex-grow p-2 border border-purple-300 rounded-md min-w-[150px]';
            const addRuleBtn = document.createElement('button');
            addRuleBtn.className = 'btn-secondary px-3 py-2 rounded-md text-sm';
            addRuleBtn.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡πÄ‡∏≠‡∏á';
            addRuleBtn.onclick = () => {
                const desc = ruleDescInput.value.trim();
                const pattern = rulePatternInput.value.trim();
                if (desc) {
                    phonology.phonotactics.push({ rule: desc, type: "custom_regex", enabled: true, custom: true, pattern: pattern });
                    ruleDescInput.value = ''; rulePatternInput.value = '';
                    renderPhonologyUI(container); saveData();
                }
            };
            addRuleGroup.appendChild(ruleDescInput); addRuleGroup.appendChild(rulePatternInput); addRuleGroup.appendChild(addRuleBtn);
            phonotacticsSection.appendChild(addRuleGroup);
            phonologyContainer.appendChild(phonotacticsSection);


            if (phonology.hasTones) {
                const addToneBtn = document.getElementById('addToneButtonPhonology');
                if (addToneBtn) addToneBtn.onclick = addTonePhonology;
                const addTonePhonotacticRuleBtn = document.getElementById('addTonePhonotacticRuleBtn');
                if(addTonePhonotacticRuleBtn) addTonePhonotacticRuleBtn.onclick = addTonePhonotacticRule;
            }
            const addGraphemeMapBtn = document.getElementById('addGraphemeMapButtonPhonology');
            if (addGraphemeMapBtn) addGraphemeMapBtn.onclick = addGraphemeMappingPhonology;
            
            const addActiveSCRuleBtn = document.getElementById('addActiveSCRuleButtonPhonology');
            if (addActiveSCRuleBtn) addActiveSCRuleBtn.onclick = addActiveSoundChangeRulePhonology;

            const testActiveSCBtn = document.getElementById('applyActiveSCRulesTestBtnPhonology');
            if (testActiveSCBtn) testActiveSCBtn.onclick = testApplyActiveSoundChangesPhonology;

        }

        function renderDynamicIPACharts(langConsonants = [], langVowels = []) {
            const consContainer = document.getElementById('ipaConsonantChartContainerPhonology');
            const vowelContainer = document.getElementById('ipaVowelChartContainerPhonology');

            const consPlaces = ["‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å", "‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å‡∏Å‡∏±‡∏ö‡∏ü‡∏±‡∏ô", "‡∏ü‡∏±‡∏ô", "‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å", "‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å", "‡∏õ‡∏•‡∏≤‡∏¢‡∏•‡∏¥‡πâ‡∏ô‡∏°‡πâ‡∏ß‡∏ô", "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡πÅ‡∏Ç‡πá‡∏á", "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡∏≠‡πà‡∏≠‡∏ô", "‡∏•‡∏¥‡πâ‡∏ô‡πÑ‡∏Å‡πà", "‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡∏≠"];
            const consPlaceSymbols = {
                "‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å": ['p', 'b', 'm', ' ô', '…∏', 'Œ≤'], "‡∏£‡∏¥‡∏°‡∏ù‡∏µ‡∏õ‡∏≤‡∏Å‡∏Å‡∏±‡∏ö‡∏ü‡∏±‡∏ô": ['…±', '‚±±', 'f', 'v', ' ã'], "‡∏ü‡∏±‡∏ô": ['Œ∏', '√∞'],
                "‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å": ['t', 'd', 'n', 'r', '…æ', 's', 'z', '…¨', '…Æ', '…π', 'l'], "‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏´‡∏á‡∏∑‡∏≠‡∏Å": [' É', ' í'],
                "‡∏õ‡∏•‡∏≤‡∏¢‡∏•‡∏¥‡πâ‡∏ô‡∏°‡πâ‡∏ß‡∏ô": [' à', '…ñ', '…≥', '…Ω', ' Ç', ' ê', '…ª', '…≠'], "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡πÅ‡∏Ç‡πá‡∏á": ['c', '…ü', '…≤', '√ß', ' ù', 'j', ' é'],
                "‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡∏≠‡πà‡∏≠‡∏ô": ['k', '…°', '≈ã', 'x', '…£', '…∞', ' ü'], "‡∏•‡∏¥‡πâ‡∏ô‡πÑ‡∏Å‡πà": ['q', '…¢', '…¥', ' Ä', 'œá', ' Å'], "‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡∏≠": [' î', 'h', '…¶']
            };
            const consManners = ["‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏Å", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ô‡∏≤‡∏™‡∏¥‡∏Å", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏£‡∏±‡∏ß", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏ö", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î", "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô"];
            const consMannerSymbols = {
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏Å": ['p', 'b', 't', 'd', ' à', '…ñ', 'c', '…ü', 'k', '…°', 'q', '…¢', ' î'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ô‡∏≤‡∏™‡∏¥‡∏Å": ['m', '…±', 'n', '…≥', '…≤', '≈ã', '…¥'],
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏£‡∏±‡∏ß": [' ô', 'r', ' Ä'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏ö": ['‚±±', '…æ', '…Ω'],
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å": ['…∏', 'Œ≤', 'f', 'v', 'Œ∏', '√∞', 's', 'z', ' É', ' í', ' Ç', ' ê', '√ß', ' ù', 'x', '…£', 'œá', ' Å', 'h', '…¶'],
                "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏î‡πÅ‡∏ó‡∏£‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô": ['…¨', '…Æ'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î": [' ã', '…π', '…ª', 'j', '…∞'], "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡∏¥‡πâ‡∏ô": ['l', '…≠', ' é', ' ü']
            };

            if (consContainer) {
                let tableHTML = '<table class="ipa-table w-full"><thead><tr><th></th>';
                consPlaces.forEach(place => tableHTML += `<th>${place}</th>`);
                tableHTML += '</tr></thead><tbody>';
                consManners.forEach(manner => {
                    tableHTML += `<tr><th>${manner}</th>`;
                    consPlaces.forEach(place => {
                        tableHTML += '<td>';
                        const cellSymbols = (consPlaceSymbols[place] || []).filter(psym => (consMannerSymbols[manner] || []).includes(psym));
                        let outputSymbols = [];
                        for(let i=0; i < cellSymbols.length; i++) {
                            let sym = cellSymbols[i]; let isPaired = false;
                            if (i + 1 < cellSymbols.length) {
                                let nextSym = cellSymbols[i+1];
                                const commonPairs = { 'p':'b', 't':'d', 'k':'…°', ' à':'…ñ', 'c':'…ü', 'q':'…¢', '…∏':'Œ≤', 'f':'v', 'Œ∏':'√∞', 's':'z', ' É':' í', ' Ç':' ê', '√ß':' ù', 'x':'…£', 'œá':' Å', 'h':'…¶', '…¨':'…Æ' };
                                if (commonPairs[sym] === nextSym) {
                                    const sym1Highlighted = langConsonants.includes(sym) ? `<span class="highlighted-phoneme">${sym}</span>` : sym;
                                    const sym2Highlighted = langConsonants.includes(nextSym) ? `<span class="highlighted-phoneme">${nextSym}</span>` : nextSym;
                                    outputSymbols.push(`${sym1Highlighted}&nbsp;${sym2Highlighted}`); i++; isPaired = true;
                                }
                            }
                            if (!isPaired) outputSymbols.push(langConsonants.includes(sym) ? `<span class="highlighted-phoneme">${sym}</span>` : sym);
                        }
                        tableHTML += outputSymbols.join('&nbsp;&nbsp;'); tableHTML += '</td>';
                    }); tableHTML += '</tr>';
                }); tableHTML += '</tbody></table>'; consContainer.innerHTML = tableHTML;
            }

            const vowelPositions = ["‡∏´‡∏ô‡πâ‡∏≤", "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á", "‡∏´‡∏•‡∏±‡∏á"]; 
            const vowelHeights = ["‡∏™‡∏π‡∏á", "‡∏Å‡∏∂‡πà‡∏á‡∏™‡∏π‡∏á", "‡∏Å‡∏•‡∏≤‡∏á", "‡∏Å‡∏∂‡πà‡∏á‡∏ï‡πà‡∏≥", "‡∏ï‡πà‡∏≥"]; 
            const vowelChartSymbols = {
                "‡∏™‡∏π‡∏á":    { "‡∏´‡∏ô‡πâ‡∏≤": ["i","y"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…®"," â"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": ["…Ø","u"] },
                "‡∏Å‡∏∂‡πà‡∏á‡∏™‡∏π‡∏á": { "‡∏´‡∏ô‡πâ‡∏≤": ["e","√∏"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…ò","…µ"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": ["…§","o"] },
                "‡∏Å‡∏•‡∏≤‡∏á":   { "‡∏´‡∏ô‡πâ‡∏≤": [],        "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…ô"],    "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": [] },
                "‡∏Å‡∏∂‡πà‡∏á‡∏ï‡πà‡∏≥": { "‡∏´‡∏ô‡πâ‡∏≤": ["…õ","≈ì"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": [],    "‡∏Å‡∏•‡∏≤‡∏á": ["…ú","…û"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": [" å","…î"] },
                "‡∏ï‡πà‡∏≥":    { "‡∏´‡∏ô‡πâ‡∏≤": ["a","…∂"], "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤": ["√¶"], "‡∏Å‡∏•‡∏≤‡∏á": ["…ê"],    "‡∏Å‡∏∂‡πà‡∏á‡∏´‡∏•‡∏±‡∏á": [],    "‡∏´‡∏•‡∏±‡∏á": ["…ë","…í"] }
            };
            
            if (vowelContainer) {
                let tableHTML = '<table class="ipa-table w-full"><thead><tr><th>‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏•‡∏¥‡πâ‡∏ô\\‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏•‡∏¥‡πâ‡∏ô</th>';
                vowelPositions.forEach(pos => tableHTML += `<th>${pos}</th>`);
                tableHTML += '</tr></thead><tbody>';
                vowelHeights.forEach(height => {
                    tableHTML += `<tr><th>${height}</th>`;
                    vowelPositions.forEach(pos => {
                        tableHTML += '<td>';
                        const symbolsInCell = vowelChartSymbols[height]?.[pos] || [];
                        symbolsInCell.forEach((ipa, idx) => {
                            if (ipa) {
                                const isPresent = langVowels.includes(ipa);
                                tableHTML += isPresent ? `<span class="highlighted-phoneme">${ipa}</span>` : ipa;
                                if (idx < symbolsInCell.length - 1 && symbolsInCell.length > 1) tableHTML += '&nbsp;'; 
                            }
                        }); tableHTML += '</td>';
                    }); tableHTML += '</tr>';
                }); tableHTML += '</tbody></table>'; vowelContainer.innerHTML = tableHTML;
            }
        }


        function addTonePhonology() {
            const name = document.getElementById('newToneNamePhonology').value.trim();
            const representation = document.getElementById('newToneRepresentationPhonology').value.trim(); 
            const number = document.getElementById('newToneNumberPhonology').value; 
            const hideInOrthography = document.getElementById('newToneHideInOrthographyPhonology').checked;

            if (!name || number === "" ) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏•‡∏Ç‡πÅ‡∏ó‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á");
                return;
            }
            const toneId = `tone_${nextToneId++}`;
            currentLanguage.phonology.tones.push({ id: toneId, name, representation, number: parseInt(number), hideInOrthography });
            renderPhonologyUI(tabContentContainer);
            saveData();
        }

        window.removeTonePhonology = (toneId) => {
            currentLanguage.phonology.tones = currentLanguage.phonology.tones.filter(t => t.id !== toneId);
            currentLanguage.phonology.tonePhonotactics = currentLanguage.phonology.tonePhonotactics.map(rule => {
                rule.forbiddenTones = rule.forbiddenTones.filter(ftId => ftId !== toneId); 
                return rule;
            }).filter(rule => rule.forbiddenTones.length > 0 || (rule.initials.length === 0 && rule.finals.length === 0)); 
            renderPhonologyUI(tabContentContainer);
            saveData();
        };
        
        function renderTonePhonotacticsList() {
            const listContainer = document.getElementById('tonePhonotacticsListPhonology');
            if (!listContainer) return;
            listContainer.innerHTML = '';
            (currentLanguage.phonology.tonePhonotactics || []).forEach(rule => {
                const div = document.createElement('div');
                div.className = 'text-xs p-1.5 bg-white border rounded flex justify-between items-center';
                let forbiddenTonesStr = rule.forbiddenTones.map(tNum => {
                    const toneObj = currentLanguage.phonology.tones.find(t => t.number === tNum);
                    return toneObj ? toneObj.name : `‡πÄ‡∏™‡∏µ‡∏¢‡∏á ${tNum}`;
                }).join(', ');

                div.innerHTML = `<span>${rule.description || `‡∏ï‡πâ‡∏ô: [${rule.initials.join(',')}] + ‡∏ó‡πâ‡∏≤‡∏¢: [${rule.finals.join(',')}] ‡∏´‡πâ‡∏≤‡∏°: ${forbiddenTonesStr}`}</span>
                               <button class="text-red-500 hover:text-red-700 text-xs" onclick="removeTonePhonotacticRule('${rule.id}')">&times; ‡∏•‡∏ö</button>`;
                listContainer.appendChild(div);
            });
             if (!currentLanguage.phonology.tonePhonotactics || currentLanguage.phonology.tonePhonotactics.length === 0) {
                listContainer.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå</p>';
            }
        }

        function populateTonePhonotacticToneSelect() {
            const selectEl = document.getElementById('tpRuleForbiddenTones');
            if (!selectEl) return;
            selectEl.innerHTML = '';
            (currentLanguage.phonology.tones || []).forEach(tone => {
                selectEl.innerHTML += `<option value="${tone.number}">${tone.name} (${tone.representation || tone.number})</option>`;
            });
        }

        function addTonePhonotacticRule() {
            const initials = document.getElementById('tpRuleInitials').value.split(',').map(s=>s.trim()).filter(Boolean);
            const finals = document.getElementById('tpRuleFinals').value.split(',').map(s=>s.trim()).filter(Boolean);
            const forbiddenTonesSelect = document.getElementById('tpRuleForbiddenTones');
            const forbiddenTones = Array.from(forbiddenTonesSelect.selectedOptions).map(opt => parseInt(opt.value));
            const description = document.getElementById('tpRuleDescription').value.trim();

            if (forbiddenTones.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏´‡πâ‡∏≤‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"); return;
            }
             if (initials.length === 0 && finals.length === 0 && !description && !confirm("‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô/‡∏ó‡πâ‡∏≤‡∏¢ ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ ‡∏à‡∏∞‡∏°‡∏µ‡∏ú‡∏•‡∏Å‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≥‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?")) {
                return;
            }

            const newRule = {
                id: `tp_${nextTonePhonotacticId++}`,
                ruleType: 'initial_final_tone', 
                initials, finals, forbiddenTones, description
            };
            currentLanguage.phonology.tonePhonotactics.push(newRule);
            renderPhonologyUI(tabContentContainer); 
            saveData();
            document.getElementById('tpRuleInitials').value = '';
            document.getElementById('tpRuleFinals').value = '';
            forbiddenTonesSelect.selectedIndex = -1;
            document.getElementById('tpRuleDescription').value = '';
        }

        window.removeTonePhonotacticRule = (ruleId) => {
            currentLanguage.phonology.tonePhonotactics = currentLanguage.phonology.tonePhonotactics.filter(r => r.id !== ruleId);
            renderPhonologyUI(tabContentContainer);
            saveData();
        }


        function renderGraphemeMappingsList() {
            const listContainer = document.getElementById('graphemeMappingListPhonology');
            if (!listContainer) return;
            listContainer.innerHTML = '';

            const createGraphemeSpans = (graphemes) => {
                if (!graphemes || graphemes.length === 0) return 'N/A';
                return graphemes.map(g => `<span class="mapping-value-item">${g}</span>`).join(', ');
            };
        
            (currentLanguage.phonology.graphemeMappings || []).forEach((gm, index) => {
                const div = document.createElement('div');
                div.className = 'grapheme-mapping-display text-sm'; 
                
                let content = `<strong>‡πÄ‡∏™‡∏µ‡∏¢‡∏á /${gm.sound}/:</strong>`;
                if ((gm.initialGraphemes && gm.initialGraphemes.length > 0) ||
                    (gm.finalGraphemes && gm.finalGraphemes.length > 0) ||
                    (gm.vowelGraphemes && gm.vowelGraphemes.length > 0)) {
                    content += `<div class="ml-4">`;
                    if (gm.initialGraphemes && gm.initialGraphemes.length > 0) {
                        content += `<span class="mapping-type">‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ï‡πâ‡∏ô:</span> <span class="mapping-values-container">${createGraphemeSpans(gm.initialGraphemes)}</span><br>`;
                    }
                    if (gm.finalGraphemes && gm.finalGraphemes.length > 0) {
                        content += `<span class="mapping-type">‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡∏ó‡πâ‡∏≤‡∏¢:</span> <span class="mapping-values-container">${createGraphemeSpans(gm.finalGraphemes)}</span><br>`;
                    }
                    if (gm.vowelGraphemes && gm.vowelGraphemes.length > 0) {
                        content += `<span class="mapping-type">‡∏™‡∏£‡∏∞/‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ:</span> <span class="mapping-values-container">${createGraphemeSpans(gm.vowelGraphemes)}</span>`;
                    }
                    content += `</div>`;
                } else {
                     content += `<span class="text-xs text-gray-400 ml-2">(‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î)</span>`;
                }
                
                const deleteButton = `<button class="text-red-500 hover:text-red-700 text-xs ml-auto" onclick="removeGraphemeMappingPhonology(${index})">&times; ‡∏•‡∏ö</button>`;
                
                div.innerHTML = `<div class="flex justify-between items-start">${content} ${deleteButton}</div>`;
                listContainer.appendChild(div);
            });
            if (!currentLanguage.phonology.graphemeMappings || currentLanguage.phonology.graphemeMappings.length === 0) {
                listContainer.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ</p>';
            }
        }


        function addGraphemeMappingPhonology() {
            const sound = document.getElementById('graphemeMapSoundPhonology').value.trim();
            const initial = document.getElementById('graphemeMapInitialPhonology').value.split(',').map(s => s.trim()).filter(s => s);
            const final = document.getElementById('graphemeMapFinalPhonology').value.split(',').map(s => s.trim()).filter(s => s);
            const vowel = document.getElementById('graphemeMapVowelPhonology').value.split(',').map(s => s.trim()).filter(s => s);

            if (!sound) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phoneme)");
                return;
            }
            if (initial.length === 0 && final.length === 0 && vowel.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô");
                return;
            }

            const existingMappingIndex = currentLanguage.phonology.graphemeMappings.findIndex(gm => gm.sound === sound);
            if (existingMappingIndex > -1) {
                currentLanguage.phonology.graphemeMappings[existingMappingIndex] = { sound, initialGraphemes: initial, finalGraphemes: final, vowelGraphemes: vowel };
            } else {
                currentLanguage.phonology.graphemeMappings.push({ sound, initialGraphemes: initial, finalGraphemes: final, vowelGraphemes: vowel });
            }
            renderGraphemeMappingsList();
            saveData();
            document.getElementById('graphemeMapSoundPhonology').value = '';
            document.getElementById('graphemeMapInitialPhonology').value = '';
            document.getElementById('graphemeMapFinalPhonology').value = '';
            document.getElementById('graphemeMapVowelPhonology').value = '';
        }

        window.removeGraphemeMappingPhonology = (index) => {
            currentLanguage.phonology.graphemeMappings.splice(index, 1);
            renderGraphemeMappingsList();
            saveData();
        }

        function renderActiveSoundChangesList() {
            const listContainer = document.getElementById('activeSoundChangesListPhonology');
            if (!listContainer) return;
            listContainer.innerHTML = '';
            (currentLanguage.phonology.activeSoundChanges || []).sort((a,b) => a.order - b.order).forEach(rule => {
                const div = document.createElement('div');
                div.className = 'draggable-item text-sm p-1.5 bg-white border rounded flex justify-between items-center';
                div.setAttribute('draggable', true);
                div.dataset.ruleId = rule.id;
                div.innerHTML = `
                    <span class="flex-grow">
                        <i class="fas fa-grip-vertical mr-2 text-gray-400"></i>
                        <strong>${rule.order + 1}.</strong> ${rule.description || `${rule.from} ‚Üí ${rule.to} / ${rule.contextPre}_${rule.contextPost}`}
                        (${rule.enabled ? '‡πÄ‡∏õ‡∏¥‡∏î' : '‡∏õ‡∏¥‡∏î'})
                    </span>
                    <span>
                        <button class="text-xs text-blue-500 hover:text-blue-700 mr-1" onclick="toggleActiveSoundChangeRuleEnablePhonology('${rule.id}')">${rule.enabled ? '‡∏õ‡∏¥‡∏î' : '‡πÄ‡∏õ‡∏¥‡∏î'}</button>
                        <button class="text-red-500 hover:text-red-700 text-xs" onclick="removeActiveSoundChangeRulePhonology('${rule.id}')">&times; ‡∏•‡∏ö</button>
                    </span>`;
                listContainer.appendChild(div);
            });
            if (!currentLanguage.phonology.activeSoundChanges || currentLanguage.phonology.activeSoundChanges.length === 0) {
                listContainer.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á</p>';
            }
            setupDragAndDropSort('activeSoundChangesListPhonology', currentLanguage.phonology.activeSoundChanges, renderActiveSoundChangesList, saveData);
        }

        function addActiveSoundChangeRulePhonology() {
            const from = document.getElementById('activeSCFromPhonology').value.trim();
            const to = document.getElementById('activeSCToPhonology').value.trim(); 
            const contextPre = document.getElementById('activeSCContextPrePhonology').value.trim();
            const contextPost = document.getElementById('activeSCContextPostPhonology').value.trim();
            const description = document.getElementById('activeSCDescPhonology').value.trim();

            if (!from) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏ '‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (From X)'"); return;
            }
            const newRule = {
                id: `asc_${nextActiveSoundChangeId++}`,
                from, to, contextPre, contextPost, description,
                order: currentLanguage.phonology.activeSoundChanges.length,
                enabled: true
            };
            currentLanguage.phonology.activeSoundChanges.push(newRule);
            renderActiveSoundChangesList();
            saveData();
            document.getElementById('activeSCFromPhonology').value = '';
            document.getElementById('activeSCToPhonology').value = '';
            document.getElementById('activeSCContextPrePhonology').value = '';
            document.getElementById('activeSCContextPostPhonology').value = '';
            document.getElementById('activeSCDescPhonology').value = '';
        }
        
        window.toggleActiveSoundChangeRuleEnablePhonology = (ruleId) => {
            const rule = currentLanguage.phonology.activeSoundChanges.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = !rule.enabled;
                renderActiveSoundChangesList();
                saveData();
            }
        };

        window.removeActiveSoundChangeRulePhonology = (ruleId) => {
            currentLanguage.phonology.activeSoundChanges = currentLanguage.phonology.activeSoundChanges.filter(r => r.id !== ruleId);
            currentLanguage.phonology.activeSoundChanges.sort((a,b) => a.order - b.order).forEach((r, i) => r.order = i);
            renderActiveSoundChangesList();
            saveData();
        };
        
        function applyActiveSoundChangeRule(word, rule) { 
            if (!rule.enabled) return word;
            
            let escFrom = rule.from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            let prePattern = "";
            // Ensure vowel/consonant lists are available for V/C context matching
            let VOWELS_REGEX_PART = (currentLanguage.phonology.vowels || []).map(v => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
            let CONSONANTS_REGEX_PART = (currentLanguage.phonology.consonants || []).map(c => c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');


            if (rule.contextPre) {
                if (rule.contextPre === '#') prePattern = '^'; 
                else if (rule.contextPre === 'V') prePattern = `(?<=(${VOWELS_REGEX_PART}))`;
                else if (rule.contextPre === 'C') prePattern = `(?<=(${CONSONANTS_REGEX_PART}))`; 
                else prePattern = `(?<=${rule.contextPre.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;
            }

            let postPattern = "";
            if (rule.contextPost) {
                if (rule.contextPost === '#') postPattern = '$'; 
                else if (rule.contextPost === 'V') postPattern = `(?=(${VOWELS_REGEX_PART}))`; 
                else if (rule.contextPost === 'C') postPattern = `(?=(${CONSONANTS_REGEX_PART}))`; 
                else postPattern = `(?=${rule.contextPost.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;
            }
            
            try {
                // Prevent errors if V/C is used but inventory is empty
                if ((rule.contextPre === 'V' && !VOWELS_REGEX_PART) || (rule.contextPre === 'C' && !CONSONANTS_REGEX_PART) ||
                    (rule.contextPost === 'V' && !VOWELS_REGEX_PART) || (rule.contextPost === 'C' && !CONSONANTS_REGEX_PART)) {
                    console.warn("Skipping rule due to empty vowel/consonant inventory for context:", rule);
                    return word;
                }
                const finalRegex = new RegExp(prePattern + escFrom + postPattern, 'g');
                return word.replace(finalRegex, rule.to);
            } catch (e) {
                console.warn("Error in regex for rule:", rule, e, "Word:", word, "Pattern:", prePattern + escFrom + postPattern);
                return word; // Return original word on error
            }
        }

        function testApplyActiveSoundChangesPhonology() {
            const word = document.getElementById('testActiveSCWordPhonology').value.trim();
            const resultDiv = document.getElementById('testActiveSCResultPhonology');
            if (!word) { resultDiv.innerHTML = '<p class="text-red-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏î‡∏™‡∏≠‡∏ö</p>'; return; }

            let currentWordState = word;
            let historyHtml = `<p><strong>‡∏Ñ‡∏≥‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô:</strong> ${word}</p><ol class="list-decimal list-inside mt-1">`;
            
            const sortedRules = [...currentLanguage.phonology.activeSoundChanges].sort((a,b) => a.order - b.order);
            sortedRules.forEach(rule => {
                const wordBeforeRule = currentWordState;
                if (rule.enabled) {
                    currentWordState = applyActiveSoundChangeRule(currentWordState, rule);
                }
                const desc = rule.description || `${rule.from} ‚Üí ${rule.to} / ${rule.contextPre}_${rule.contextPost}`;
                const changed = wordBeforeRule !== currentWordState;
                historyHtml += `<li class="${!rule.enabled ? 'text-gray-400 italic' : (changed ? 'text-green-600 font-semibold' : '')}">
                                    ${desc} ${!rule.enabled ? '(‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)' : ''} ‚Üí ${currentWordState}
                                    ${changed && rule.enabled ? ` (‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å ${wordBeforeRule})` : ''}
                                </li>`;
            });
            historyHtml += `</ol><p class="mt-2"><strong>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢:</strong> ${currentWordState}</p>`;
            resultDiv.innerHTML = historyHtml;
        }

        function setupDragAndDropSort(listContainerId, itemsArray, rerenderCallback, saveCallback) {
            const listContainer = document.getElementById(listContainerId);
            if (!listContainer) return;
            let draggedItem = null;

            listContainer.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('draggable-item')) {
                    draggedItem = e.target;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', e.target.dataset.ruleId); // Assuming ruleId for active sound changes
                    setTimeout(() => e.target.style.opacity = '0.5', 0);
                }
            });

            listContainer.addEventListener('dragend', (e) => {
                if (draggedItem) {
                    setTimeout(() => {
                        if (draggedItem) draggedItem.style.opacity = '1'; // Check if draggedItem still exists
                        draggedItem = null;
                    }, 0);
                    // Update order based on new DOM positions
                    const newOrder = Array.from(listContainer.children)
                                         .map(child => child.dataset.ruleId) // Use ruleId for active sound changes
                                         .filter(id => id); 
                    itemsArray.forEach(item => {
                        const newIdx = newOrder.indexOf(item.id);
                        if (newIdx !== -1) item.order = newIdx;
                    });
                    itemsArray.sort((a,b) => a.order - b.order); 
                    if (rerenderCallback) rerenderCallback(); 
                    if (saveCallback) saveCallback();
                }
            });

            listContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const targetItem = e.target.closest('.draggable-item');
                if (targetItem && draggedItem && targetItem !== draggedItem) {
                    const rect = targetItem.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / (rect.bottom - rect.top) > 0.5;
                    if (next) {
                        listContainer.insertBefore(draggedItem, targetItem.nextSibling);
                    } else {
                        listContainer.insertBefore(draggedItem, targetItem);
                    }
                }
            });
        }


        window.togglePhonotacticRule = (index) => {
            currentLanguage.phonology.phonotactics[index].enabled = !currentLanguage.phonology.phonotactics[index].enabled;
            renderPhonologyUI(tabContentContainer); saveData();
        };
        window.removeCustomPhonotacticRule = (index) => {
            if (currentLanguage.phonology.phonotactics[index].custom) {
                currentLanguage.phonology.phonotactics.splice(index, 1);
                renderPhonologyUI(tabContentContainer); saveData();
            }
        };

        function renderWordGeneratorUI(container) {
            const section = document.createElement('div');
            section.className = 'space-y-4 p-3 border border-green-200 rounded-md bg-green-50';
            // ‡πÅ‡∏™‡∏î‡∏á custom symbol mapping ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å writingSystem ‡πÄ‡∏õ‡πá‡∏ô custom
            section.innerHTML = `
                <div>
                    <label class="block text-sm font-medium text-green-700">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏ï‡πà‡∏≠‡∏Ñ‡∏≥:</label>
                    <div class="flex items-center gap-2">
                        <input type="number" id="minSyllables" value="1" min="1" max="5" class="w-20 p-2 border border-green-300 rounded-md">
                        <span>‡∏ñ‡∏∂‡∏á</span>
                        <input type="number" id="maxSyllables" value="3" min="1" max="5" class="w-20 p-2 border border-green-300 rounded-md">
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-green-700">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á:</label>
                    <input type="number" id="numWordsToGenerate" value="5" min="1" max="20" class="w-20 p-2 border border-green-300 rounded-md">
                </div>
                <button id="generateWordsButton" class="btn-primary bg-green-500 hover:bg-green-600 py-2 px-4 rounded-md">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥ üé≤</button>
                <div id="generatedWordsArea" class="mt-4 p-3 bg-white rounded-md shadow">
                    <h4 class="font-semibold text-green-700">‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏î‡πâ:</h4>
                    <ul id="generatedWordsList" class="list-disc list-inside text-sm"></ul>
                </div>
            `;
            container.appendChild(section);
            document.getElementById('generateWordsButton').addEventListener('click', generateAndDisplayWords);
        }

        // Function to get orthographic form, with an option to use the first grapheme for deterministic output
        // (e.g., for consistent display in inflection tables)
        function getOrthographicForm(wordEntry, forDisplay = true, useFirstGraphemeForAutoInflection = false) {
            if (!wordEntry) return "";
            // If a custom orthography is defined for the word, always use it.
            if (wordEntry.customOrthography) {
                return wordEntry.customOrthography;
            }
            // If the word is in the dictionary, preserve its orthography (never randomize again)
            if (wordEntry.id && currentLanguage && currentLanguage.lexicon && Array.isArray(currentLanguage.lexicon)) {
                const dictWord = currentLanguage.lexicon.find(w => w.id === wordEntry.id);
                if (dictWord && dictWord.customOrthography) return dictWord.customOrthography;
            }
            // Otherwise, transliterate the base phonemic form strictly
            const basePhonemicForm = typeof wordEntry.word === 'string' ? wordEntry.word : '';
            // Always use deterministic mapping for display in dictionary/other systems
            // If writing system is custom, return HTML with custom symbol images/text
            if (currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'custom' && Array.isArray(currentLanguage.orthography.customSymbols) && currentLanguage.orthography.customSymbols.length > 0) {
                return transliterateWordToSymbols(basePhonemicForm, forDisplay, true, true);
            }
            return transliterateWordToSymbols(basePhonemicForm, forDisplay, true);
        }


        // Function to transliterate a phonemic word string into its orthographic representation based on current language settings.
        // Parameters:
        // - wordString: The phonemic string to transliterate.
        // - forDisplay: Boolean, if true, considers displayTonesInOrthography. (Currently always true when called from getOrthographicForm)
        // - useFirstGraphemeOnly: Boolean, if true, selects the first available grapheme from mappings for determinism. Otherwise, selects randomly.
function transliterateWordToSymbols(wordString, forDisplay = true, useFirstGraphemeOnly = false, returnHtml = false) {
            if (!wordString && typeof wordString !== 'string') return ""; 
            const { writingSystem, customSymbols, displayTonesInOrthography } = currentLanguage.orthography;
            const { graphemeMappings, tones: definedTones, hasTones, consonants, vowels, useDiacritics } = currentLanguage.phonology;

            let baseWord = String(wordString);
            let toneMarker = "";
            let toneDiacritic = "";
            let toneObj = null;

            // Extract tone from the end of the phonemic string if tones are enabled and defined.
            if (hasTones && definedTones && definedTones.length > 0) {
                const numericSuperscripts = ["‚Å∞", "¬π", "¬≤", "¬≥", "‚Å¥", "‚Åµ", "‚Å∂", "‚Å∑", "‚Å∏", "‚Åπ"];
                // Sort tone representations by length (longest first) to handle multi-character representations correctly.
                const toneRepresentationsSorted = definedTones
                    .map(t => ({rep: t.representation, tone: t}))
                    .filter(item => item.rep && typeof item.rep === 'string') 
                    .sort((a,b) => b.rep.length - a.rep.length); 

                for (const item of toneRepresentationsSorted) {
                    if (item.rep && baseWord.endsWith(item.rep)) { 
                        toneObj = item.tone;
                        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ representation ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡∏Ç‡∏¢‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á
                        toneMarker = (forDisplay && displayTonesInOrthography && !item.tone.hideInOrthography)
                            ? (item.tone.representation || numericSuperscripts[item.tone.number] || "")
                            : "";
                        toneDiacritic = (useDiacritics && item.tone.diacritic) ? item.tone.diacritic : "";
                        baseWord = baseWord.slice(0, -item.rep.length); // Remove tone from baseWord
                        break;
                    }
                }
                // If no complex tone found, check for simple numeric superscript.
                if (!toneMarker && !toneDiacritic) {
                    for (let i = 0; i < numericSuperscripts.length; i++) {
                        if (baseWord.endsWith(numericSuperscripts[i])) {
                            const foundToneNumber = i;
                            const matchedTone = definedTones.find(t => t.number === foundToneNumber);
                            if (matchedTone) {
                                toneObj = matchedTone;
                                // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ representation ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡∏Ç‡∏¢‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á
                                toneMarker = (forDisplay && displayTonesInOrthography && !matchedTone.hideInOrthography)
                                    ? (matchedTone.representation || numericSuperscripts[i])
                                    : "";
                                toneDiacritic = (useDiacritics && matchedTone.diacritic) ? matchedTone.diacritic : "";
                            } else { // Unmapped numeric tone, still display if allowed.
                                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ mapping ‡πÉ‡∏î ‡πÜ ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏•‡∏Ç‡∏¢‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á
                                toneMarker = (forDisplay && displayTonesInOrthography) ? numericSuperscripts[i] : "";
                            }
                            baseWord = baseWord.slice(0, -1); // Remove tone from baseWord
                            break;
                        }
                    }
                }
            }

            let transliterated = '';
            let remainingWord = baseWord;

            // If diacritics are enabled, insert the diacritic on the first vowel of each syllable, using the correct tone for each syllable
            if (useDiacritics && forDisplay && displayTonesInOrthography) {
                // Split by syllable boundaries (dot or whitespace)
                let syllables = baseWord.split(/\.|\s+/);
                let result = [];
                // Try to extract tone for each syllable from the original wordString
                // Assume the input is in the form: ma¬π man¬≤ta¬≥, etc. (syllable + tone marker)
                // We'll use the definedTones to match at the end of each syllable
                let originalSyllables = (typeof wordString === 'string') ? wordString.split(/\.|\s+/) : [];
                for (let s = 0; s < syllables.length; s++) {
                    let syll = syllables[s];
                    let origSyll = originalSyllables[s] || '';
                    let thisToneDiacritic = '';
                    // Try to find the tone for this syllable
                    if (hasTones && definedTones && definedTones.length > 0) {
                        let found = false;
                        // Check for representation at end
                        for (const t of definedTones) {
                            if (t.representation && origSyll.endsWith(t.representation)) {
                                // ‡∏ñ‡πâ‡∏≤ hideInOrthography ‡πÄ‡∏õ‡πá‡∏ô true ‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏™‡πà diacritic ‡πÄ‡∏•‡∏¢ (‡∏ó‡∏∏‡∏Å‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå)
                                if (!t.hideInOrthography && t.diacritic) {
                                    thisToneDiacritic = t.diacritic;
                                } else {
                                    thisToneDiacritic = '';
                                }
                                found = true;
                                break;
                            }
                        }
                        // If not found, check for numeric superscript
                        if (!found) {
                            const numericSuperscripts = ["‚Å∞", "¬π", "¬≤", "¬≥", "‚Å¥", "‚Åµ", "‚Å∂", "‚Å∑", "‚Å∏", "‚Åπ"];
                            for (let i = 0; i < numericSuperscripts.length; i++) {
                                if (origSyll.endsWith(numericSuperscripts[i])) {
                                    const matchedTone = definedTones.find(t => t.number === i);
                                    if (matchedTone) {
                                        if (!matchedTone.hideInOrthography && matchedTone.diacritic) {
                                            thisToneDiacritic = matchedTone.diacritic;
                                        } else {
                                            thisToneDiacritic = '';
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    let inserted = false;
                    let newSyll = '';
                    // ‡∏ñ‡πâ‡∏≤ hasTones ‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ diacritic ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡∏π‡∏Å hide ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß ‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á diacritic ‡πÉ‡∏î ‡πÜ
                    let showDiacritic = true;
                    if (hasTones && definedTones && definedTones.length > 0) {
                        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ definedTones ‡∏ó‡∏µ‡πà !hideInOrthography ‡πÅ‡∏•‡∏∞‡∏°‡∏µ diacritic ‡πÄ‡∏•‡∏¢ ‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á diacritic
                        const anyVisibleDiacritic = definedTones.some(t => !t.hideInOrthography && t.diacritic);
                        if (!anyVisibleDiacritic) showDiacritic = false;
                    }
                    for (let i = 0; i < syll.length; i++) {
                        let ch = syll[i];
                        if (!inserted && vowels && vowels.includes(ch) && thisToneDiacritic && showDiacritic) {
                            newSyll += ch + thisToneDiacritic;
                            inserted = true;
                        } else {
                            newSyll += ch;
                        }
                    }
                    result.push(newSyll);
                }
                transliterated = result.join('.');
                return transliterated;
            }

            // Handle custom writing system first.
            if (writingSystem === 'custom' && customSymbols && customSymbols.length > 0) {
                const sortedSymbols = [...customSymbols].sort((a, b) => b.sound.length - a.sound.length); // Longest sound first for matching.
                let html = '';
                while (remainingWord.length > 0) {
                    let foundMatch = false;
                    for (const sym of sortedSymbols) {
                        if (remainingWord.startsWith(sym.sound)) {
                            if (returnHtml) {
                                if (sym.imageData) {
                                    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ imageData ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á image
                                    html += `<img src='${sym.imageData}' alt='${sym.sound}' style='height:1.5em;display:inline-block;vertical-align:middle;background:transparent;margin:0 1px;'/>`;
                                } else if (sym.symbol && sym.symbol.trim()) {
                                    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ image ‡πÅ‡∏ï‡πà‡∏°‡∏µ symbol ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á symbol
                                    html += `<span style='display:inline-block;vertical-align:middle;font-size:1.2em;margin:0 1px;'>${sym.symbol}</span>`;
                                } else {
                                    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á sound (text)
                                    html += `<span style='display:inline-block;vertical-align:middle;font-size:1.2em;margin:0 1px;color:#aaa;'>${sym.sound}</span>`;
                                }
                            } else {
                                if (sym.imageData) {
                                    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ imageData ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô [img] (‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©)
                                    transliterated += '[img]';
                                } else if (sym.symbol && sym.symbol.trim()) {
                                    transliterated += sym.symbol;
                                } else {
                                    transliterated += sym.sound;
                                }
                            }
                            remainingWord = remainingWord.substring(sym.sound.length);
                            foundMatch = true;
                            break;
                        }
                    }
                    if (!foundMatch) {
                        // If no custom symbol matches, append the character as is.
                        if (returnHtml) {
                            html += `<span style='color:#aaa;'>${remainingWord[0]}</span>`;
                        } else {
                            transliterated += remainingWord[0];
                        }
                        remainingWord = remainingWord.substring(1);
                    }
                }
                if (returnHtml) {
                    // Add tone marker if needed
                    if (toneMarker) html += `<sup style='font-size:0.7em;color:#a855f7;'>${toneMarker}</sup>`;
                    return html;
                } else {
                    return transliterated + toneMarker;
                }
            } else if (writingSystem === 'latin' && graphemeMappings && graphemeMappings.length > 0) {
                // Strict mapping: initial = initialGraphemes, vowel = vowelGraphemes, final = finalGraphemes
                const sortedMappings = [...graphemeMappings].sort((a, b) => b.sound.length - a.sound.length);
                let currentOriginalPos = 0; // Track position in the original baseWord for context (initial/final).

                while (remainingWord.length > 0) {
                    let foundMatch = false;
                    for (const gm of sortedMappings) {
                        if (remainingWord.startsWith(gm.sound)) {
                            let potentialGraphemes = [];
                            const isInitialSoundSegment = currentOriginalPos === 0;
                            const isFinalSoundSegment = (currentOriginalPos + gm.sound.length === baseWord.length);
                            const isConsonantSound = (currentLanguage.phonology.consonants || []).includes(gm.sound);
                            const isVowelSound = (currentLanguage.phonology.vowels || []).includes(gm.sound);

                            // Strict: Only use initialGraphemes for initial, finalGraphemes for final, vowelGraphemes for vowels
                            if (isConsonantSound) {
                                if (isInitialSoundSegment && gm.initialGraphemes && gm.initialGraphemes.length > 0) {
                                    potentialGraphemes = gm.initialGraphemes;
                                } else if (isFinalSoundSegment && gm.finalGraphemes && gm.finalGraphemes.length > 0) {
                                    potentialGraphemes = gm.finalGraphemes;
                                } else {
                                    // No fallback: do not use other types
                                    potentialGraphemes = [];
                                }
                            } else if (isVowelSound) {
                                if (gm.vowelGraphemes && gm.vowelGraphemes.length > 0) {
                                    potentialGraphemes = gm.vowelGraphemes;
                                } else {
                                    potentialGraphemes = [];
                                }
                            }

                            let chosenGrapheme = null;
                            if (potentialGraphemes.length > 0) {
                                if (useFirstGraphemeOnly) {
                                    chosenGrapheme = potentialGraphemes[0];
                                } else {
                                    chosenGrapheme = potentialGraphemes[Math.floor(Math.random() * potentialGraphemes.length)];
                                }
                            }

                            if (chosenGrapheme) {
                                transliterated += chosenGrapheme;
                                remainingWord = remainingWord.substring(gm.sound.length);
                                currentOriginalPos += gm.sound.length;
                                foundMatch = true;
                                break;
                            }
                        }
                    }
                    if (!foundMatch) {
                        transliterated += remainingWord[0];
                        remainingWord = remainingWord.substring(1);
                        currentOriginalPos += 1;
                    }
                }
            } else { 
                transliterated = baseWord;
            }

            return transliterated + toneMarker; // toneMarker will be empty if diacritics are enabled
        }


        function generateAndDisplayWords() {
            const minSyllables = parseInt(document.getElementById('minSyllables').value);
            const maxSyllables = parseInt(document.getElementById('maxSyllables').value);
            const numWords = parseInt(document.getElementById('numWordsToGenerate').value);
            const listElement = document.getElementById('generatedWordsList');
            listElement.innerHTML = '';

            if (minSyllables > maxSyllables) { alert("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î"); return; }
            if (currentLanguage.phonology.consonants.length === 0 || currentLanguage.phonology.vowels.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∞‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô"); return;
            }

            for (let i = 0; i < numWords; i++) {
                const numSyllToGenerate = Math.floor(Math.random() * (maxSyllables - minSyllables + 1)) + minSyllables;
                let rawWordFormBeforeActiveChanges = ''; 
                let finalPhoneticWord = ''; 

                for (let j = 0; j < numSyllToGenerate; j++) {
                    const syllableParts = generateSyllable(); 
                    rawWordFormBeforeActiveChanges += syllableParts.base; 
                    finalPhoneticWord += syllableParts.phonetic; 
                }
                
                const detailedPhonetics = autoFormatDetailedPhonetics(finalPhoneticWord, currentLanguage.phonology);
                // For word generation list display, use random grapheme selection (useFirstGraphemeForAutoInflection = false).
                // The specific generated displayWord will be passed to showWordModal if the user decides to add it.
                // Render orthography with custom symbol images if writing system is custom
                let orthographyHtml = '';
                if (currentLanguage.orthography.writingSystem === 'custom' && Array.isArray(currentLanguage.orthography.customSymbols) && currentLanguage.orthography.customSymbols.length > 0) {
                    // Map sounds to custom symbol objects for fast lookup
                    const customSymbolMap = {};
                    currentLanguage.orthography.customSymbols.forEach(sym => { customSymbolMap[sym.sound] = sym; });
                    // Try to match the generated word to custom symbols (longest match first)
                    let word = finalPhoneticWord;
                    let i = 0;
                    while (i < word.length) {
                        let matched = false;
                        // Try to match longest sound first
                        const sortedSymbols = [...currentLanguage.orthography.customSymbols].sort((a, b) => b.sound.length - a.sound.length);
                        for (const sym of sortedSymbols) {
                            if (word.slice(i, i + sym.sound.length) === sym.sound) {
                                if (sym.imageData) {
                                    orthographyHtml += `<img src='${sym.imageData}' alt='img' style='height:28px;vertical-align:middle;background:transparent;display:inline-block;margin-right:2px;'/>`;
                                } else if (sym.symbol) {
                                    orthographyHtml += `<span class='font-mono' style='font-size:1.2em;margin-right:2px;'>${sym.symbol}</span>`;
                                } else {
                                    orthographyHtml += `<span class=\"text-gray-400\" style='margin-right:2px;'>(‡∏ß‡πà‡∏≤‡∏á)</span>`;
                                }
                                i += sym.sound.length;
                                matched = true;
                                break;
                            }
                        }
                        if (!matched) {
                            // If no custom symbol matches, show the character as is
                            orthographyHtml += `<span class='font-mono' style='color:#888;margin-right:2px;'>${word[i]}</span>`;
                            i++;
                        }
                    }
                } else {
                    // Fallback: use plain orthography string
                    orthographyHtml = getOrthographicForm({word: finalPhoneticWord, customOrthography: null}, true, false);
                }

                let randomMeaning = "";
                if (apiThaiMeaningsDatabase.length > 0) {
                    randomMeaning = apiThaiMeaningsDatabase[Math.floor(Math.random() * apiThaiMeaningsDatabase.length)];
                } else if (localThaiMeaningsDatabase.length > 0) { 
                    randomMeaning = localThaiMeaningsDatabase[Math.floor(Math.random() * localThaiMeaningsDatabase.length)];
                }

                const listItem = document.createElement('li');
                listItem.className = 'p-2 my-1 bg-gray-50 hover:bg-green-50 rounded flex justify-between items-center flex-wrap';

                const wordDisplaySpan = document.createElement('span');
                wordDisplaySpan.className = 'font-semibold mr-2 flex items-center';
                wordDisplaySpan.innerHTML = `${orthographyHtml} <span class="text-sm text-gray-500 font-normal font-mono ml-2">(${finalPhoneticWord})</span> <span class="text-xs text-blue-400 font-normal font-mono ml-2">[‡∏ê‡∏≤‡∏ô‡∏î‡∏¥‡∏ö: ${rawWordFormBeforeActiveChanges}]</span>`;
                if (randomMeaning) {
                     wordDisplaySpan.innerHTML += ` <span class="text-xs text-blue-500 ml-2">‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á: ${randomMeaning}</span>`;
                }
                listItem.appendChild(wordDisplaySpan);

                const addButton = document.createElement('button');
                addButton.innerHTML = '‚ûï <span class="hidden sm:inline">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</span>';
                addButton.className = 'ml-auto text-xs btn-secondary bg-green-400 hover:bg-green-500 px-2 py-1 rounded whitespace-nowrap';
                // Pass the initially generated displayWord to showWordModal
                addButton.onclick = () => showWordModal(null, finalPhoneticWord, detailedPhonetics, randomMeaning, orthographyHtml); 
                listItem.appendChild(addButton);
                listElement.appendChild(listItem);
            }
        }
        
        function generateSyllable() {
            const ph = currentLanguage.phonology;
            if (ph.syllableStructures.length === 0) return { base: "err", phonetic: "err" };
            if (ph.consonants.length === 0 && !ph.allowVowelInitial) { 
                console.warn("Cannot generate syllable: No consonants defined and vowel initial not allowed.");
                return { base: "errC", phonetic: "errC" };
            }
            if (ph.vowels.length === 0) {
                 console.warn("Cannot generate syllable: No vowels defined.");
                return { base: "errV", phonetic: "errV" };
            }


            let attempts = 0;
            while (attempts < 100) { 
                const structureStr = ph.syllableStructures[Math.floor(Math.random() * ph.syllableStructures.length)];
                let syllableBase = ""; 
                let validSyllable = true;
                let tempStructure = structureStr;
                
                let onsetLength = 0;
                const onsetMatch = tempStructure.match(/^(C+|C)/); 
                if (onsetMatch) onsetLength = onsetMatch[0].length;

                if (onsetLength > 0) { 
                    const availableInitials = ph.allowedInitialConsonants.filter(c => ph.consonants.includes(c));
                    const availableClusters = ph.allowedConsonantClusters.filter(cl => 
                        cl.length <= ph.maxClusterLength && 
                        !ph.forbiddenConsonantClusters.includes(cl) && 
                        cl.split('').every(c => ph.consonants.includes(c)) && 
                        availableInitials.includes(cl[0]) 
                    );

                    if (onsetLength > 1) { 
                        const fittingClusters = availableClusters.filter(cl => cl.length === onsetLength);
                        if (fittingClusters.length > 0) {
                            syllableBase += fittingClusters[Math.floor(Math.random() * fittingClusters.length)];
                        } else { 
                            const shorterFittingClusters = availableClusters.filter(cl => cl.length < onsetLength && cl.length > 0);
                            if (shorterFittingClusters.length > 0) {
                                syllableBase += shorterFittingClusters[Math.floor(Math.random() * shorterFittingClusters.length)];
                            } else if (availableInitials.length > 0) {
                                syllableBase += availableInitials[Math.floor(Math.random() * availableInitials.length)];
                            } else { validSyllable = false; }
                        }
                    } else { 
                        if (availableInitials.length > 0) {
                            syllableBase += availableInitials[Math.floor(Math.random() * availableInitials.length)];
                        } else { validSyllable = false; }
                    }
                    if(validSyllable && onsetMatch) tempStructure = tempStructure.substring(syllableBase.length); 
                } else if (!ph.allowVowelInitial) { 
                    validSyllable = false;
                }
                
                if (validSyllable && ph.forbiddenInitialSounds.some(s => syllableBase.startsWith(s))) {
                     validSyllable = false;
                }

                if (validSyllable) { 
                    const vowelMatch = tempStructure.match(/^(V+|V)/); 
                    if (vowelMatch) {
                        const vowelSegment = vowelMatch[0];
                        for (let k = 0; k < vowelSegment.length; k++) {
                            if (ph.vowels.length > 0) {
                                syllableBase += ph.vowels[Math.floor(Math.random() * ph.vowels.length)];
                            } else { validSyllable = false; break; }
                        }
                        if(validSyllable) tempStructure = tempStructure.substring(vowelSegment.length);
                    } else if (!syllableBase.match(new RegExp(`[${ph.vowels.join('')}]`, 'i'))) { 
                         validSyllable = false; 
                    }
                }

                if (validSyllable && tempStructure.length > 0) { 
                    const codaStructure = tempStructure;
                    const availableFinals = ph.allowedFinalConsonants.filter(c => ph.consonants.includes(c));
                    const availableCodaClusters = ph.allowedCodaClusters.filter(cc => 
                        cc.split('').every(c => ph.consonants.includes(c)) &&
                        !ph.forbiddenConsonantClusters.includes(cc) 
                    );

                    if (ph.allowClusterCoda && codaStructure.length > 1) { 
                        const fittingCodaClusters = availableCodaClusters.filter(cc => cc.length === codaStructure.length);
                        if (fittingCodaClusters.length > 0) {
                            syllableBase += fittingCodaClusters[Math.floor(Math.random() * fittingCodaClusters.length)];
                        } else { 
                            for (let k = 0; k < codaStructure.length; k++) {
                                if (availableFinals.length > 0) syllableBase += availableFinals[Math.floor(Math.random() * availableFinals.length)];
                                else if (!ph.allowNoCoda) { validSyllable = false; break; }
                            }
                        }
                    } else { 
                        for (const codaC of codaStructure.split('')) {
                            if (codaC === 'C') {
                                if (availableFinals.length > 0) {
                                    syllableBase += availableFinals[Math.floor(Math.random() * availableFinals.length)];
                                } else if (!ph.allowNoCoda) { validSyllable = false; break; }
                            }
                        }
                    }
                }
                 if (!validSyllable) { attempts++; continue; }


                if (!ph.allowVowelInitial && ph.vowels.includes(syllableBase[0])) validSyllable = false;
                
                const lastChar = syllableBase.slice(-1);
                const lastSegmentIsConsonant = ph.consonants.includes(lastChar) || 
                                               (ph.allowedCodaClusters.some(cc => syllableBase.endsWith(cc)) && syllableBase.length > 1);

                if (lastSegmentIsConsonant && ph.forbiddenFinalSounds.some(s => syllableBase.endsWith(s))) {
                    validSyllable = false;
                }
                
                if (!ph.allowNoCoda && !lastSegmentIsConsonant) { 
                     validSyllable = false;
                }


                (ph.phonotactics || []).forEach(rule => {
                    if (!validSyllable) return;
                    if (rule.enabled && rule.type === "custom_regex" && rule.pattern) {
                        try { if (new RegExp(rule.pattern).test(syllableBase)) validSyllable = false; } 
                        catch(e) { console.warn("Invalid phonotactic regex:", rule.pattern, e); }
                    }
                });
                if (!validSyllable) { attempts++; continue; }

                let phoneticForm = syllableBase;
                const sortedActiveSCRules = [...ph.activeSoundChanges].sort((a,b) => a.order - b.order);
                sortedActiveSCRules.forEach(rule => {
                    phoneticForm = applyActiveSoundChangeRule(phoneticForm, rule);
                });
        
                let toneRepresentation = "";
                if (ph.hasTones && ph.tones.length > 0) {
                    const applicableTones = ph.tones.filter(tone => {
                        for (const tpRule of (ph.tonePhonotactics || [])) {
                             const initialPhonemesForForm = phoneticForm.match(new RegExp(`^(${ph.consonants.join('|')})*`))?.[0] || "";
                             const finalPhonemesForForm = phoneticForm.match(new RegExp(`(${ph.consonants.join('|')})*$ `))?.[0] || ""; 

                            const initialMatch = tpRule.initials.length === 0 || tpRule.initials.some(init => initialPhonemesForForm.includes(init));
                            const finalMatch = tpRule.finals.length === 0 || tpRule.finals.some(fin => finalPhonemesForForm.includes(fin));
                            
                            if (initialMatch && finalMatch && tpRule.forbiddenTones.includes(tone.number)) {
                                return false; 
                            }
                        }
                        return true; 
                    });

                    if (applicableTones.length > 0) {
                        const randomTone = applicableTones[Math.floor(Math.random() * applicableTones.length)];
                        toneRepresentation = randomTone.representation || "";
                        if (!toneRepresentation && randomTone.number >= 0 && randomTone.number <= 9) { 
                            const superscripts = ["‚Å∞", "¬π", "¬≤", "¬≥", "‚Å¥", "‚Åµ", "‚Å∂", "‚Å∑", "‚Å∏", "‚Åπ"];
                            toneRepresentation = superscripts[randomTone.number];
                        } else if (!toneRepresentation && randomTone.number > 0) { 
                            // Fallback for numbers > 9 or if representation is complex and not a single char
                            toneRepresentation = `^${randomTone.number}`; // Or handle differently
                        }
                    } 
                }
                phoneticForm += toneRepresentation; // Add tone marker to the end of the syllable's phonetic form
        
                return { base: syllableBase, phonetic: phoneticForm };
            }
        
            // Fallback if syllable generation fails after many attempts
            let fallbackSyllable = (ph.consonants[0] || "p") + (ph.vowels[0] || "a");
            console.warn("Syllable generation fallback after 100 attempts. Using:", fallbackSyllable);
            return { base: fallbackSyllable, phonetic: fallbackSyllable };
        }


        function hasConsonantCluster(text, consonantsList) {
            let consonantCount = 0;
            for (const char of text) {
                if (consonantsList.includes(char)) {
                    consonantCount++;
                    if (consonantCount > 1) return true; // Found a cluster of at least 2
                } else {
                    consonantCount = 0; // Reset count if non-consonant
                }
            }
            return false;
        }
        
        // Helper function to create a single rule step's UI
        function createRuleStepUI(step = { id: `step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', ruleValue: '' }, forNounPlural = false) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'p-2 mb-2 border rounded bg-purple-100 rule-step-item draggable-item';
            stepDiv.dataset.stepId = step.id;
            stepDiv.dataset.order = step.order;
            stepDiv.setAttribute('draggable', true);

            let valueInputHTML = '';
            const currentRuleValue = forNounPlural ? step.value : step.ruleValue;
            if (step.ruleType === 'conditionalSuffix') {
                const parts = (currentRuleValue || 'N/A>N/A>N/A').split('>');
                valueInputHTML = `
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-1 mt-1">
                        <input type="text" value="${parts[0] || '*'}" placeholder="‡∏™‡∏£‡∏∞ (*=any)" class="p-1 border rounded text-xs rule-step-cond-vowel" title="‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÄ‡∏ä‡πà‡∏ô * ‡∏´‡∏£‡∏∑‡∏≠ a,i)">
                        <input type="text" value="${parts[1] || ''}" placeholder="‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞" class="p-1 border rounded text-xs rule-step-affix-after" title="‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞ (......)">
                        <input type="text" value="${parts[2] || ''}" placeholder="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏ó‡πâ‡∏≤‡∏¢" class="p-1 border rounded text-xs rule-step-final-suffix" title="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (‡πÄ‡∏ä‡πà‡∏ô ita)">
                    </div>`;
            } else {
                valueInputHTML = `<input type="text" value="${currentRuleValue || ''}" placeholder="‡∏Ñ‡πà‡∏≤" class="w-full p-1 border rounded text-xs rule-step-value">`;
            }

            // --- Logograph image UI for logographic writing system ---
            let logographImageSection = '';
            const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';
            if (isLogographic) {
                logographImageSection = `
                <div class="mt-2 border rounded p-2 bg-white">
                    <label class="block text-xs font-medium mb-1">‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏†‡∏≤‡∏û (Logograph) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ:</label>
                    <input type="file" class="rule-step-logograph-upload mb-1" accept="image/png">
                    <button type="button" class="btn-secondary btn-xs draw-rule-step-logograph">‡∏ß‡∏≤‡∏î‡∏†‡∏≤‡∏û</button>
                    <div class="mt-1"><img class="rule-step-logograph-preview max-h-16 mb-1" src="${step.logographImage ? step.logographImage : ''}" style="${step.logographImage ? '' : 'display:none;'};background:transparent;border:none;box-shadow:none;border-radius:0;"/></div>
                    <button type="button" class="btn-secondary btn-xs clear-rule-step-logograph ${step.logographImage ? '' : 'hidden'}">‡∏•‡∏ö‡∏†‡∏≤‡∏û</button>
                    <div class="draw-rule-step-logograph-modal fixed inset-0 z-[90] flex items-center justify-center modal hidden p-4">
                        <div class="modal-content p-4 rounded-lg shadow-xl w-full max-w-xs bg-white">
                            <h4 class="text-base font-bold mb-2">‡∏ß‡∏≤‡∏î‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏†‡∏≤‡∏û (‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô)</h4>
                            <canvas width="128" height="128" class="rule-step-logograph-canvas border bg-white mb-2"></canvas>
                            <div class="flex gap-2 mb-2">
                                <button type="button" class="btn-secondary btn-xs clear-canvas">‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                                <button type="button" class="btn-primary btn-xs save-canvas">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û</button>
                                <button type="button" class="btn-secondary btn-xs cancel-canvas">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
                            </div>
                        </div>
                    </div>
                </div>`;
            }

            stepDiv.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs font-semibold cursor-grab"><i class="fas fa-grip-vertical mr-1 text-gray-400"></i>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${step.order + 1} (ID: ${step.id})</span>
                    <button type="button" class="text-xs text-red-500 hover:text-red-700 remove-rule-step-btn">&times; ‡∏•‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 items-end">
                    <div>
                        <label class="block text-xs">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Å‡∏é:</label>
                        <select class="w-full p-1 border rounded text-xs rule-step-type">
                            <option value="suffix" ${step.ruleType === 'suffix' ? 'selected' : ''}>‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢ (‡πÄ‡∏ï‡∏¥‡∏°‡∏ó‡πâ‡∏≤‡∏¢)</option>
                            <option value="prefix" ${step.ruleType === 'prefix' ? 'selected' : ''}>‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ (‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏ô‡πâ‡∏≤)</option>
                            <option value="infix" ${step.ruleType === 'infix' ? 'selected' : ''}>‡∏≠‡∏≤‡∏Ñ‡∏° (‡πÄ‡∏ï‡∏¥‡∏°‡∏Å‡∏•‡∏≤‡∏á)</option>
                            <option value="ablaut" ${step.ruleType === 'ablaut' ? 'selected' : ''}>‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞ (Ablaut)</option>
                            <option value="suppletion" ${step.ruleType === 'suppletion' ? 'selected' : ''}>‡∏£‡∏π‡∏õ‡∏û‡∏¥‡πÄ‡∏®‡∏© (Suppletion)</option>
                            <option value="conditionalSuffix" ${step.ruleType === 'conditionalSuffix' ? 'selected' : ''}>‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Conditional Suffix)</option>
                            <option value="none" ${step.ruleType === 'none' ? 'selected' : ''}>‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</option>
                        </select>
                    </div>
                    <div class="rule-step-value-container">${valueInputHTML}</div>
                </div>
                ${logographImageSection}
            `;

            stepDiv.querySelector('.rule-step-type').addEventListener('change', function() {
                const valueContainer = this.closest('.rule-step-item').querySelector('.rule-step-value-container');
                const selectedType = this.value;
                let newValueInputHTML = '';
                if (selectedType === 'conditionalSuffix') {
                     newValueInputHTML = `
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-1 mt-1">
                             <input type="text" value="*" placeholder="‡∏™‡∏£‡∏∞ (*=any)" class="p-1 border rounded text-xs rule-step-cond-vowel" title="‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÄ‡∏ä‡πà‡∏ô * ‡∏´‡∏£‡∏∑‡∏≠ a,i)">
                            <input type="text" placeholder="‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞" class="p-1 border rounded text-xs rule-step-affix-after" title="‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏•‡∏±‡∏á‡∏™‡∏£‡∏∞ (......)">
                            <input type="text" placeholder="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏ó‡πâ‡∏≤‡∏¢" class="p-1 border rounded text-xs rule-step-final-suffix" title="‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (‡πÄ‡∏ä‡πà‡∏ô ita)">
                        </div>`;
                } else {
                    newValueInputHTML = `<input type="text" placeholder="‡∏Ñ‡πà‡∏≤" class="w-full p-1 border rounded text-xs rule-step-value">`;
                }
                valueContainer.innerHTML = newValueInputHTML;
            });

            // --- Logograph image logic for each step ---
            if (isLogographic) {
                const uploadInput = stepDiv.querySelector('.rule-step-logograph-upload');
                const previewImg = stepDiv.querySelector('.rule-step-logograph-preview');
                const clearBtn = stepDiv.querySelector('.clear-rule-step-logograph');
                const drawBtn = stepDiv.querySelector('.draw-rule-step-logograph');
                const modal = stepDiv.querySelector('.draw-rule-step-logograph-modal');
                const canvas = stepDiv.querySelector('.rule-step-logograph-canvas');
                let ctx = null;
                if (canvas) {
                    ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = 'rgba(0,0,0,0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    // Set default arrow cursor
                    canvas.style.cursor = 'default';
                }
                // Upload
                if (uploadInput) {
                    uploadInput.addEventListener('change', e => {
                        const file = e.target.files[0];
                        if (file && file.type === 'image/png') {
                            const reader = new FileReader();
                            reader.onload = function(evt) {
                                const img = new window.Image();
                                img.onload = function() {
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    ctx.globalAlpha = 1.0;
                                    ctx.fillStyle = 'rgba(0,0,0,0)';
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                    const png = canvas.toDataURL('image/png');
                                    previewImg.src = png;
                                    previewImg.style.display = '';
                                    clearBtn.classList.remove('hidden');
                                    step.logographImage = png;
                                };
                                img.src = evt.target.result;
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                }
                // Draw
                if (drawBtn && modal && canvas) {
                    drawBtn.addEventListener('click', () => {
                        modal.classList.remove('hidden');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = 'rgba(0,0,0,0)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        let drawing = false;
                        let lastX = 0, lastY = 0;
                        canvas.onmousedown = e => { drawing = true; lastX = e.offsetX; lastY = e.offsetY; };
                        canvas.onmouseup = () => { drawing = false; };
                        canvas.onmouseleave = () => { drawing = false; };
                        canvas.onmousemove = e => {
                            if (!drawing) return;
                            ctx.strokeStyle = '#222';
                            ctx.lineWidth = 4;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(lastX, lastY);
                            ctx.lineTo(e.offsetX, e.offsetY);
                            ctx.stroke();
                            lastX = e.offsetX; lastY = e.offsetY;
                        };
                        modal.querySelector('.clear-canvas').onclick = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'rgba(0,0,0,0)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        };
                        modal.querySelector('.save-canvas').onclick = () => {
                            const png = canvas.toDataURL('image/png');
                            previewImg.src = png;
                            previewImg.style.display = '';
                            clearBtn.classList.remove('hidden');
                            step.logographImage = png;
                            modal.classList.add('hidden');
                        };
                        modal.querySelector('.cancel-canvas').onclick = () => {
                            modal.classList.add('hidden');
                        };
                    });
                }
                // Clear
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        previewImg.src = '';
                        previewImg.style.display = 'none';
                        clearBtn.classList.add('hidden');
                        step.logographImage = '';
                    });
                }
            }

            stepDiv.querySelector('.remove-rule-step-btn').addEventListener('click', function() {
                const stepItem = this.closest('.rule-step-item');
                const stepsContainer = stepItem.parentElement;
                stepItem.remove();
                // Re-number steps after removal
                const allStepItems = stepsContainer.querySelectorAll('.rule-step-item');
                allStepItems.forEach((s, i) => {
                    s.dataset.order = i;
                    s.querySelector('.font-semibold').innerHTML = `<i class="fas fa-grip-vertical mr-1 text-gray-400"></i>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${i + 1} (ID: ${s.dataset.stepId})`;
                });
            });
            return stepDiv;
        }

        function setupRuleStepDragAndDrop(containerElementId) {
            const listContainer = document.getElementById(containerElementId);
            if (!listContainer) return;

            let draggedStep = null;

            listContainer.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('draggable-item')) {
                    draggedStep = e.target;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', e.target.dataset.stepId);
                    setTimeout(() => { if(draggedStep) draggedStep.style.opacity = '0.5'; }, 0);
                }
            });

            listContainer.addEventListener('dragend', (e) => {
                if (draggedStep) {
                    setTimeout(() => {
                        if(draggedStep) draggedStep.style.opacity = '1';
                        draggedStep = null;
                        // Update order in DOM and re-label
                        const allStepItems = listContainer.querySelectorAll('.rule-step-item');
                        allStepItems.forEach((s, i) => {
                            s.dataset.order = i; // Update data-order attribute
                            s.querySelector('.font-semibold').innerHTML = `<i class="fas fa-grip-vertical mr-1 text-gray-400"></i>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${i + 1} (ID: ${s.dataset.stepId})`;
                        });

                    }, 0);
                }
            });

            listContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const targetItem = e.target.closest('.draggable-item');
                if (targetItem && draggedStep && targetItem !== draggedStep) {
                    const rect = targetItem.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / (rect.bottom - rect.top) > 0.5;
                    if (next) {
                        listContainer.insertBefore(draggedStep, targetItem.nextSibling);
                    } else {
                        listContainer.insertBefore(draggedStep, targetItem);
                    }
                }
            });
        }


        function renderGrammarUI(container) {
            const grammar = currentLanguage.grammar;
            grammar.morphology = grammar.morphology || {}; 
            grammar.morphology.conjugationCategories = grammar.morphology.conjugationCategories || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.grammar.morphology.conjugationCategories));
            grammar.morphology.conjugationRules = grammar.morphology.conjugationRules || [];
            grammar.morphology.nounPluralization = grammar.morphology.nounPluralization || JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.grammar.morphology.nounPluralization));
            if (!grammar.morphology.nounPluralization.ruleSteps) { // Ensure ruleSteps for nounPluralization
                grammar.morphology.nounPluralization.ruleSteps = JSON.parse(JSON.stringify(DEFAULT_LANGUAGE_STATE.grammar.morphology.nounPluralization.ruleSteps));
            }
            grammar.partsOfSpeech = grammar.partsOfSpeech || [...DEFAULT_LANGUAGE_STATE.grammar.partsOfSpeech];
            grammar.genders = grammar.genders || [...DEFAULT_LANGUAGE_STATE.grammar.genders];
        
            const grammarContainerId = 'grammarTabSpecificContent';
            let grammarContainer = container.querySelector(`#${grammarContainerId}`);
            if (!grammarContainer) {
                grammarContainer = document.createElement('div');
                grammarContainer.id = grammarContainerId;
                container.appendChild(grammarContainer);
            }
            grammarContainer.innerHTML = ''; 
        
            const section = document.createElement('div');
            section.className = 'space-y-6 p-3 border border-blue-200 rounded-md bg-blue-50';
        
            createSelectInput(section, '‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (Basic Sentence Structure):', 'sentenceStructureSelectGrammar', grammar.sentenceStructure,
                ['SVO', 'SOV', 'VSO', 'VOS', 'OSV', 'OVS'].map(s => ({ value: s, text: s }))
            ).onchange = (e) => { grammar.sentenceStructure = e.target.value; saveData(); };
        
            createListInput(section, 'üè∑Ô∏è ‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥ (Parts of Speech)', grammar.partsOfSpeech, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥ (‡πÄ‡∏ä‡πà‡∏ô Noun, Noun:Animate)",
                (item) => { grammar.partsOfSpeech.push(item); renderGrammarUI(container); saveData(); },
                (index) => { grammar.partsOfSpeech.splice(index, 1); renderGrammarUI(container); saveData(); }
            );
        
            const genderWrapper = document.createElement('div');
            genderWrapper.className = 'p-3 border border-blue-300 rounded-md bg-white';
            genderWrapper.innerHTML = `<h4 class="font-semibold text-blue-700 mb-2">‡πÄ‡∏û‡∏®‡∏ó‡∏≤‡∏á‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå (Grammatical Gender)</h4>`;
            createCheckboxInput(genderWrapper, '‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏û‡∏®‡∏ó‡∏≤‡∏á‡πÑ‡∏ß‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå', 'hasGenderCheckboxGrammar', grammar.hasGender, '', 
                (e) => {
                    grammar.hasGender = e.target.checked;
                    renderGrammarUI(container); saveData();
                });
            if (grammar.hasGender) {
                createListInput(genderWrapper, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏®', grammar.genders, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏® (‡πÄ‡∏ä‡πà‡∏ô Masculine)",
                    (item) => { grammar.genders.push(item); renderGrammarUI(container); saveData(); },
                    (index) => { grammar.genders.splice(index, 1); renderGrammarUI(container); saveData(); }
                );
            }
            section.appendChild(genderWrapper);
        
            const conjugationSection = document.createElement('div');
            conjugationSection.className = 'p-3 border border-purple-300 rounded-md bg-purple-50';
            conjugationSection.innerHTML = `<h3 class="text-lg font-semibold text-purple-700 mb-3">‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥ (Inflections/Conjugations)</h3>
                                            <p class="text-xs text-gray-500 mb-2">‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡∏´‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô "‡∏£‡∏π‡∏õ‡πÅ‡∏£‡∏Å" ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÉ‡∏ô Grapheme Mappings ‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠</p>`;
        
            const catMgmtSection = document.createElement('div');
            catMgmtSection.innerHTML = `<h4 class="font-medium text-purple-600 mb-2">1. ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (Inflection Categories)</h4>`;
            
            const catsListContainer = document.createElement('div');
            catsListContainer.id = 'conjugationCategoriesListGrammar';
            (grammar.morphology.conjugationCategories).forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'p-2 mb-2 border rounded bg-white text-sm';
                catDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <strong>${cat.name}</strong>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeConjugationCategory('${cat.id}')">‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</button>
                    </div>
                    <p class="text-xs text-gray-600">‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö POS: ${cat.appliesToPOS.join(', ') || 'N/A'}</p>
                    <div class="mt-1">
                        <label class="text-xs font-medium">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢ (Options):</label>
                        <div class="flex flex-wrap gap-1 mt-1">
                            ${cat.options.map((opt, idx) => `
                                <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs flex items-center">
                                    ${opt}
                                    <button class="ml-1 text-purple-500 hover:text-purple-700" onclick="removeOptionFromConjugationCategory('${cat.id}', ${idx})">&times;</button>
                                </span>`).join('')}
                        </div>
                        <div class="flex gap-1 mt-1">
                            <input type="text" placeholder="‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢" class="p-1 border rounded text-xs flex-grow category-option-input-grammar" data-catid="${cat.id}">
                            <button class="text-xs btn-secondary bg-purple-400 px-1 py-0.5 rounded" onclick="addOptionToConjugationCategory('${cat.id}')">‡πÄ‡∏û‡∏¥‡πà‡∏°</button>
                        </div>
                    </div>
                `;
                catsListContainer.appendChild(catDiv);
            });
            catMgmtSection.appendChild(catsListContainer);
        
            const addCatForm = document.createElement('div');
            addCatForm.className = 'mt-2 p-2 border-t flex flex-wrap gap-2 items-end';
            addCatForm.innerHTML = `
               <div class="flex-grow min-w-[150px]"><label class="text-xs">‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÉ‡∏´‡∏°‡πà:</label><input type="text" id="newConjCategoryNameGrammar" placeholder="‡πÄ‡∏ä‡πà‡∏ô Tense, Number" class="w-full p-1 border rounded text-sm"></div>
                <div class="flex-grow min-w-[200px]">
                    <label class="text-xs">‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥:</label>
                    <div id="newConjCategoryPOSCheckboxesGrammar" class="grid grid-cols-2 sm:grid-cols-3 gap-1 p-1 border rounded bg-white max-h-24 overflow-y-auto">
                        ${currentLanguage.grammar.partsOfSpeech.map(pos => `
                            <div class="flex items-center">
                                <input type="checkbox" id="chk_pos_cat_${pos.replace(/\W/g, '')}" value="${pos}" class="h-3.5 w-3.5 mr-1 new-conj-cat-pos-chk">
                                <label for="chk_pos_cat_${pos.replace(/\W/g, '')}" class="text-xs">${pos}</label>
                            </div>`).join('')}
                    </div>
                </div>
                <button id="addConjugationCategoryBtnGrammar" class="btn-secondary bg-purple-500 px-2 py-1 rounded text-sm">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô</button>
            `;
            catMgmtSection.appendChild(addCatForm);
            conjugationSection.appendChild(catMgmtSection);
        
            const ruleDefSection = document.createElement('div');
            ruleDefSection.className = 'mt-4 pt-3 border-t border-purple-200';
            ruleDefSection.innerHTML = `<h4 class="font-medium text-purple-600 mb-2">2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥ (Inflection Rules)</h4>`;
            
            const addRuleForm = document.createElement('div');
            addRuleForm.className = 'p-3 mb-3 border rounded bg-white text-sm';
            addRuleForm.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 items-end mb-3">
                    <div><label class="block text-xs">‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Å‡∏é:</label><input type="text" id="infRuleDescGrammar" placeholder="‡πÄ‡∏ä‡πà‡∏ô Past Tense Verbs" class="w-full p-1 border rounded"></div>
                    <div><label class="block text-xs">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥ (POS):</label><select id="infRulePOSGrammar" class="w-full p-1 border rounded"></select></div>
                    <div><label class="block text-xs">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (Category):</label><select id="infRuleCategoryGrammar" class="w-full p-1 border rounded"></select></div>
                    <div class="lg:col-span-2"><label class="block text-xs">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢ (Option):</label><select id="infRuleOptionGrammar" class="w-full p-1 border rounded"></select></div>
                </div>
                <div class="mt-2 p-2 border-t border-purple-300">
                  <h5 class="text-sm font-semibold mb-1 text-purple-700">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (Rule Steps):</h5>
                  <div id="infRuleStepsContainerGrammar" class="space-y-2 rule-steps-list-container bg-purple-50 p-2 rounded">
                    <!-- Steps will be added here by JS -->
                  </div>
                  <button type="button" id="addNewInfRuleStepBtnGrammar" class="text-xs btn-secondary bg-purple-300 hover:bg-purple-400 text-purple-800 px-2 py-1 mt-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô</button>
                </div>
                <div class="mt-3 text-right"><button id="addInflectionRuleBtnGrammar" class="btn-primary bg-purple-600 px-3 py-1.5 rounded text-sm">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô</button></div>
            `;
            ruleDefSection.appendChild(addRuleForm);

            const rulesListContainer = document.createElement('div');
            rulesListContainer.id = 'inflectionRulesListGrammar';
            rulesListContainer.className = 'max-h-60 overflow-y-auto';
            (grammar.morphology.conjugationRules).forEach(rule => {
                 const cat = grammar.morphology.conjugationCategories.find(c => c.id === rule.categoryId);
                 const stepsDisplay = (rule.ruleSteps || [])
                                         .sort((a,b) => a.order - b.order)
                                         .map(s => `${s.ruleType}:'${s.ruleValue}'`).join(' ‚Üí ');
                 rulesListContainer.innerHTML += `
                    <div class="p-2 mb-1 border rounded bg-white text-xs flex justify-between items-center">
                        <span><strong>${rule.description}</strong> (${rule.partOfSpeech} -> ${cat ? cat.name : 'N/A'}: ${rule.categoryOption} :: ${stepsDisplay || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô'})</span>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeConjugationRule('${rule.id}')">‡∏•‡∏ö</button>
                    </div>`;
            });
            ruleDefSection.appendChild(rulesListContainer);
            conjugationSection.appendChild(ruleDefSection);

            const testerSection = document.createElement('div');
            testerSection.className = 'mt-4 pt-3 border-t border-purple-200';
            testerSection.innerHTML = `
                <h4 class="font-medium text-purple-600 mb-2">3. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥</h4>
                <div class="flex gap-2 mb-2">
                    <input type="text" id="conjugationTestWordGrammar" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏° (‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô)" class="w-full p-1 border rounded text-sm" list="dictionaryWordsDatalistForConjTest">
                    <datalist id="dictionaryWordsDatalistForConjTest"></datalist>
                    <button id="conjugationTestBtnGrammar" class="btn-secondary bg-purple-500 px-2 py-1 rounded text-sm">‡∏ó‡∏î‡∏™‡∏≠‡∏ö</button>
                </div>
                <div id="conjugationTestResultGrammar" class="p-2 bg-white rounded border min-h-[50px] text-sm max-h-80 overflow-y-auto">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</div>
            `;
            conjugationSection.appendChild(testerSection);
            section.appendChild(conjugationSection);
        
            const nounPluralData = grammar.morphology.nounPluralization;
            const nounPluralSection = document.createElement('div');
            nounPluralSection.className = 'mt-4 pt-3 border-t border-blue-200'; 
            nounPluralSection.innerHTML = `
                <h4 class="font-semibold text-blue-700 mb-1">‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏≥‡∏ô‡∏≤‡∏°‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå (Noun Pluralization):</h4>
                <div class="p-2 border rounded bg-blue-100">
                    <h5 class="text-sm font-semibold mb-1 text-blue-700">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå (Pluralization Steps):</h5>
                    <div id="nounPluralStepsContainerGrammar" class="space-y-2 rule-steps-list-container bg-blue-50 p-2 rounded">
                        <!-- Noun plural steps will be added here by JS -->
                    </div>
                    <button type="button" id="addNewNounPluralStepBtnGrammar" class="text-xs btn-secondary bg-blue-300 hover:bg-blue-400 text-blue-800 px-2 py-1 mt-2 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô</button>
                    <div class="mt-2 text-right">
                        <button id="setNounPluralRuleBtnGrammar" class="btn-secondary bg-blue-400 hover:bg-blue-500 px-2 py-1 rounded-md text-xs">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏é‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå</button>
                    </div>
                </div>`;
            section.appendChild(nounPluralSection);
            
            grammarContainer.appendChild(section);
        
            populateInfRulePOSSelect();
            document.getElementById('infRulePOSGrammar').addEventListener('change', populateInfRuleCategorySelect);
            document.getElementById('infRuleCategoryGrammar').addEventListener('change', (e) => {
                populateInfRuleOptionSelect();
                const catName = e.target.options[e.target.selectedIndex]?.text || '';
                const descInput = document.getElementById('infRuleDescGrammar');
                if (descInput && (!descInput.value || grammar.morphology.conjugationCategories.some(c => descInput.value === c.name))) { 
                    descInput.value = catName;
                }
            });
            
            // Populate and set up general inflection rule steps UI
            const infRuleStepsContainer = document.getElementById('infRuleStepsContainerGrammar');
            if (infRuleStepsContainer) {
                 // Always start with one fresh step for adding a new rule
                 infRuleStepsContainer.innerHTML = ''; // Clear existing if any (should not be any for "add new")
                 infRuleStepsContainer.appendChild(createRuleStepUI({id: `step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', ruleValue: ''}));
                
                document.getElementById('addNewInfRuleStepBtnGrammar').addEventListener('click', () => {
                    const currentSteps = infRuleStepsContainer.querySelectorAll('.rule-step-item');
                    infRuleStepsContainer.appendChild(createRuleStepUI({id: `step_${nextRuleStepId++}`, order: currentSteps.length, ruleType: 'suffix', ruleValue: ''}));
                });
                setupRuleStepDragAndDrop('infRuleStepsContainerGrammar');
            }

            // Populate and set up noun pluralization steps UI
            const nounPluralStepsContainer = document.getElementById('nounPluralStepsContainerGrammar');
            if (nounPluralStepsContainer) {
                nounPluralStepsContainer.innerHTML = ''; // Clear first
                const pluralSteps = currentLanguage.grammar.morphology.nounPluralization.ruleSteps || 
                                    [{ id: `plural_step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', value: 's' }];
                if(pluralSteps.length === 0){ // Ensure at least one default step if array is empty
                     pluralSteps.push({ id: `plural_step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', value: 's' });
                }
                pluralSteps.sort((a,b) => a.order - b.order).forEach((step, index) => {
                    nounPluralStepsContainer.appendChild(createRuleStepUI({
                        id: step.id || `plural_step_${nextRuleStepId++}`,
                        order: index, // Re-assign order based on sorted array
                        ruleType: step.ruleType,
                        ruleValue: step.value // createRuleStepUI expects ruleValue, which is `value` for plural
                    }, true)); // true for forNounPlural
                });
                document.getElementById('addNewNounPluralStepBtnGrammar').addEventListener('click', () => {
                     const currentSteps = nounPluralStepsContainer.querySelectorAll('.rule-step-item');
                     nounPluralStepsContainer.appendChild(createRuleStepUI({id: `plural_step_${nextRuleStepId++}`, order: currentSteps.length, ruleType: 'suffix', ruleValue: ''}, true));
                });
                setupRuleStepDragAndDrop('nounPluralStepsContainerGrammar');
            }
            
            document.getElementById('addConjugationCategoryBtnGrammar').addEventListener('click', addConjugationCategory);
            document.getElementById('addInflectionRuleBtnGrammar').addEventListener('click', addInflectionRule);
            document.getElementById('setNounPluralRuleBtnGrammar').addEventListener('click', () => {
                const newRuleSteps = [];
                const stepElements = document.querySelectorAll('#nounPluralStepsContainerGrammar .rule-step-item');
                let errorOccurred = false;
                stepElements.forEach((stepEl, index) => { // Use index from DOM order for 'order'
                    if (errorOccurred) return;
                    const stepId = stepEl.dataset.stepId;
                    const ruleType = stepEl.querySelector('.rule-step-type').value;
                    let stepValue = '';
                    if (ruleType === 'conditionalSuffix') {
                        const condVowel = stepEl.querySelector('.rule-step-cond-vowel').value.trim();
                        const affixAfter = stepEl.querySelector('.rule-step-affix-after').value.trim();
                        const finalSuffix = stepEl.querySelector('.rule-step-final-suffix').value.trim();
                         if (!condVowel || !finalSuffix) {
                             alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏µ‡πà ${index + 1}: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á" ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç" ‡πÅ‡∏•‡∏∞ "‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢"`);
                             errorOccurred = true; return;
                         }
                        stepValue = `${condVowel}>${affixAfter}>${finalSuffix}`;
                    } else {
                        const valueInput = stepEl.querySelector('.rule-step-value');
                        if (valueInput) stepValue = valueInput.value.trim();
                        else console.warn("Could not find .rule-step-value for step type:", ruleType);
                    }
                     if (ruleType !== 'none' && !stepValue && !['ablaut', 'infix', 'suppletion'].includes(ruleType) && !(ruleType === 'conditionalSuffix' && stepValue.split('>')[0] && stepValue.split('>')[2])) {
                         alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏µ‡πà ${index + 1}: ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏Ñ‡πà‡∏≤" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Å‡∏é '${ruleType}'`);
                         errorOccurred = true; return;
                     }
                    newRuleSteps.push({ id: stepId, order: index, ruleType: ruleType, value: stepValue }); // Store as 'value'
                });

                if (errorOccurred) return;

                if (newRuleSteps.length === 0) {
                     if (!confirm("‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? (‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏π‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏´‡∏π‡∏û‡∏à‡∏ô‡πå)")) {
                         return;
                     }
                }
                currentLanguage.grammar.morphology.nounPluralization = { ruleSteps: newRuleSteps };
                renderGrammarUI(container); 
                saveData(); 
            });
            document.getElementById('conjugationTestBtnGrammar').addEventListener('click', testConjugation);
            populateDictionaryWordsDatalist('dictionaryWordsDatalistForConjTest', false); 
        }


        function updateNounPluralValueInput() { // OBSOLETE with multi-step UI
            // This function is no longer needed as each step has its own value input logic
            // in createRuleStepUI. Kept here for reference if parts are useful elsewhere.
        }


        function updateInfRuleValueInput() { // OBSOLETE with multi-step UI
            // This function is no longer needed as each step has its own value input logic
            // in createRuleStepUI.
        }


        function populateDictionaryWordsDatalist(datalistId, useBaseFormForValue = false) {
            const datalist = document.getElementById(datalistId);
            if (!datalist) return;
            datalist.innerHTML = ''; 
            currentLanguage.lexicon.forEach(word => {
                const option = document.createElement('option');
                const orthographicDisplay = getOrthographicForm(word); 
                option.value = useBaseFormForValue ? word.word : orthographicDisplay; 
                option.textContent = `${orthographicDisplay} (${word.meaning}) [‡∏ê‡∏≤‡∏ô: ${word.word}]`;
                if (!useBaseFormForValue) { 
                    option.dataset.baseform = word.word;
                }
                option.dataset.wordid = word.id; 
                datalist.appendChild(option);
            });
        }
        
         function addConjugationCategory() {
            const nameInput = document.getElementById('newConjCategoryNameGrammar');
            const posCheckboxesContainer = document.getElementById('newConjCategoryPOSCheckboxesGrammar');
            const name = nameInput.value.trim();
            const selectedPOS = Array.from(posCheckboxesContainer.querySelectorAll('.new-conj-cat-pos-chk:checked')).map(chk => chk.value);
        
            if (name && selectedPOS.length > 0) {
                if (currentLanguage.grammar.morphology.conjugationCategories.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                    alert(`‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏ä‡∏∑‡πà‡∏≠ "${name}" ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß`);
                    return;
                }
                const newCatId = `cat_${nextConjCategoryId++}`;
                currentLanguage.grammar.morphology.conjugationCategories.push({
                    id: newCatId,
                    name: name,
                    appliesToPOS: selectedPOS,
                    options: [] 
                });
                nameInput.value = ''; 
                posCheckboxesContainer.querySelectorAll('.new-conj-cat-pos-chk:checked').forEach(chk => chk.checked = false); 
                renderGrammarUI(tabContentContainer); 
                saveData();
            } else {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£');
            }
        }
        
        window.removeConjugationCategory = (catId) => {
            currentLanguage.grammar.morphology.conjugationCategories = currentLanguage.grammar.morphology.conjugationCategories.filter(c => c.id !== catId);
            currentLanguage.grammar.morphology.conjugationRules = currentLanguage.grammar.morphology.conjugationRules.filter(r => r.categoryId !== catId);
            renderGrammarUI(tabContentContainer);
            saveData();
        };
        
        window.addOptionToConjugationCategory = (catId) => {
            const cat = currentLanguage.grammar.morphology.conjugationCategories.find(c => c.id === catId);
            const input = document.querySelector(`.category-option-input-grammar[data-catid="${catId}"]`); 
            if (cat && input) {
                const optionValue = input.value.trim();
                if (optionValue && !cat.options.includes(optionValue)) { 
                    cat.options.push(optionValue);
                    input.value = ''; 
                    renderGrammarUI(tabContentContainer);
                    saveData();
                }
            }
        };
        
        window.removeOptionFromConjugationCategory = (catId, optionIndex) => {
            const cat = currentLanguage.grammar.morphology.conjugationCategories.find(c => c.id === catId);
            if (cat && cat.options[optionIndex] !== undefined) {
                const optionToRemove = cat.options[optionIndex];
                cat.options.splice(optionIndex, 1); 
                currentLanguage.grammar.morphology.conjugationRules = currentLanguage.grammar.morphology.conjugationRules.filter(r => !(r.categoryId === catId && r.categoryOption === optionToRemove));
                renderGrammarUI(tabContentContainer);
                saveData();
            }
        };
        
        function populateInfRulePOSSelect() {
            const select = document.getElementById('infRulePOSGrammar');
            if (!select) return;
            select.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥ --</option>';
            currentLanguage.grammar.partsOfSpeech.forEach(pos => {
                select.innerHTML += `<option value="${pos}">${pos}</option>`;
            });
            populateInfRuleCategorySelect(); 
        }
        
        function populateInfRuleCategorySelect() {
            const posSelect = document.getElementById('infRulePOSGrammar');
            const catSelect = document.getElementById('infRuleCategoryGrammar');
            if (!posSelect || !catSelect) return;
        
            const selectedPOS = posSelect.value;
            catSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó --</option>';
            currentLanguage.grammar.morphology.conjugationCategories.forEach(cat => {
                if (!selectedPOS || cat.appliesToPOS.includes(selectedPOS) || cat.appliesToPOS.some(appliedPOS => selectedPOS.startsWith(appliedPOS + ":"))) {
                    catSelect.innerHTML += `<option value="${cat.id}">${cat.name}</option>`;
                }
            });
            populateInfRuleOptionSelect(); 
        }
        
        function populateInfRuleOptionSelect() {
            const catSelect = document.getElementById('infRuleCategoryGrammar');
            const optSelect = document.getElementById('infRuleOptionGrammar');
            if (!catSelect || !optSelect) return;
        
            const selectedCatId = catSelect.value;
            optSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢ --</option>';
            const category = currentLanguage.grammar.morphology.conjugationCategories.find(c => c.id === selectedCatId);
            if (category) {
                category.options.forEach(opt => {
                    optSelect.innerHTML += `<option value="${opt}">${opt}</option>`;
                });
            }
        }
        
        function addInflectionRule() {
            const description = document.getElementById('infRuleDescGrammar').value.trim();
            const pos = document.getElementById('infRulePOSGrammar').value;
            const categoryId = document.getElementById('infRuleCategoryGrammar').value;
            const categoryOption = document.getElementById('infRuleOptionGrammar').value;

            if (!description || !pos || !categoryId || !categoryOption) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô (‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î, ‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥, ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó, ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢)');
                return;
            }

            const ruleSteps = [];
            const stepElements = document.querySelectorAll('#infRuleStepsContainerGrammar .rule-step-item');
            let errorInSteps = false;
            stepElements.forEach((stepEl, index) => {
                if(errorInSteps) return;
                const stepId = stepEl.dataset.stepId;
                const order = parseInt(stepEl.dataset.order);
                const ruleType = stepEl.querySelector('.rule-step-type').value;
                let ruleValue = '';
                if (ruleType === 'conditionalSuffix') {
                    const condVowel = stepEl.querySelector('.rule-step-cond-vowel').value.trim();
                    const affixAfter = stepEl.querySelector('.rule-step-affix-after').value.trim();
                    const finalSuffix = stepEl.querySelector('.rule-step-final-suffix').value.trim();
                    if (!condVowel || !finalSuffix) {
                         alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${index + 1}: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á" ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏™‡∏£‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç" ‡πÅ‡∏•‡∏∞ "‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢"`);
                         errorInSteps = true; return;
                    }
                    ruleValue = `${condVowel}>${affixAfter}>${finalSuffix}`;
                } else {
                    const valueInput = stepEl.querySelector('.rule-step-value');
                    if (valueInput) ruleValue = valueInput.value.trim();
                    else console.warn("Could not find .rule-step-value for step:", stepEl);
                }
                // --- Logograph image for this step ---
                let logographImage = '';
                const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';
                if (isLogographic) {
                    const previewImg = stepEl.querySelector('.rule-step-logograph-preview');
                    if (previewImg && previewImg.src && previewImg.src.startsWith('data:image/png')) {
                        logographImage = previewImg.src;
                    }
                }
                 if (ruleType !== 'none' && !ruleValue && !['ablaut', 'infix', 'suppletion'].includes(ruleType) && !(ruleType === 'conditionalSuffix' && ruleValue.split('>')[0] && ruleValue.split('>')[2])) {
                     alert(`‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${index + 1}: ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å "‡∏Ñ‡πà‡∏≤" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Å‡∏é '${ruleType}'`);
                     errorInSteps = true; return;
                 }
                ruleSteps.push({ id: stepId, order: order, ruleType, ruleValue, ...(logographImage ? {logographImage} : {}) });
            });

            if (errorInSteps) return;

            if (ruleSteps.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô"); return;
            }
            
            ruleSteps.sort((a,b) => a.order - b.order); // Ensure steps are sorted by their DOM order before saving

            const existingRuleIndex = currentLanguage.grammar.morphology.conjugationRules.findIndex(r =>
                r.partOfSpeech === pos && r.categoryId === categoryId && r.categoryOption === categoryOption
            );

            const newRuleData = {
                id: existingRuleIndex > -1 ? currentLanguage.grammar.morphology.conjugationRules[existingRuleIndex].id : `rule_${nextConjRuleId++}`,
                description, 
                partOfSpeech: pos, 
                categoryId, 
                categoryOption, 
                ruleSteps
            };

            if (existingRuleIndex > -1) {
                if (!confirm(`‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${pos} -> ${currentLanguage.grammar.morphology.conjugationCategories.find(c=>c.id === categoryId)?.name}:${categoryOption} ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (${currentLanguage.grammar.morphology.conjugationRules[existingRuleIndex].description}). ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`)) {
                    return;
                }
                currentLanguage.grammar.morphology.conjugationRules[existingRuleIndex] = newRuleData;
            } else {
                currentLanguage.grammar.morphology.conjugationRules.push(newRuleData);
            }
            
            document.getElementById('infRuleDescGrammar').value = '';
            const infRuleStepsContainer = document.getElementById('infRuleStepsContainerGrammar');
            if(infRuleStepsContainer) {
                infRuleStepsContainer.innerHTML = '';
                infRuleStepsContainer.appendChild(createRuleStepUI({id: `step_${nextRuleStepId++}`, order: 0, ruleType: 'suffix', ruleValue: ''}));
            }


            renderGrammarUI(tabContentContainer); 
            saveData();
        }
        
        window.removeConjugationRule = (ruleId) => {
            currentLanguage.grammar.morphology.conjugationRules = currentLanguage.grammar.morphology.conjugationRules.filter(r => r.id !== ruleId);
            renderGrammarUI(tabContentContainer);
            saveData();
        };

        // This function applies a single step of a rule
        function applyRuleStep(currentWord, stepRuleType, stepRuleValue) {
            let inflectedWord = currentWord;
            switch (stepRuleType) {
                case 'prefix': inflectedWord = stepRuleValue + currentWord; break;
                case 'suffix': inflectedWord = currentWord + stepRuleValue; break;
                case 'infix':
                    if (stepRuleValue.includes('>')) {
                        const parts = stepRuleValue.split('>');
                        const charToFind = parts[0]; const charToInsert = parts[1];
                        const idx = currentWord.lastIndexOf(charToFind);
                        if (idx !== -1) inflectedWord = currentWord.slice(0, idx + charToFind.length) + charToInsert + currentWord.slice(idx + charToFind.length);
                        else { // Fallback if charToFind is not present
                           const mid = Math.floor(currentWord.length / 2);
                           inflectedWord = currentWord.slice(0, mid) + stepRuleValue.replace(charToFind + ">", "") + currentWord.slice(mid);
                        }
                    } else { // Simple infix in the middle
                        const mid = Math.floor(currentWord.length / 2);
                        inflectedWord = currentWord.slice(0, mid) + stepRuleValue + currentWord.slice(mid);
                    }
                    break;
                case 'ablaut':
                    let tempWord = currentWord;
                    const changes = stepRuleValue.split(',').map(s => s.trim());
                    changes.forEach(change => {
                        if (change.includes('>')) {
                            const parts = change.split('>');
                            const fromVowel = parts[0].trim(); const toVowel = parts[1].trim();
                            const escapedFromVowel = fromVowel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            try { tempWord = tempWord.replace(new RegExp(escapedFromVowel, 'g'), toVowel); }
                            catch (e) { console.error("Error in ablaut regex:", e); }
                        }
                    });
                    inflectedWord = tempWord;
                    break;
                case 'suppletion': inflectedWord = stepRuleValue; break;
                case 'conditionalSuffix':
                    if (typeof stepRuleValue === 'string' && stepRuleValue.includes('>')) {
                        const parts = stepRuleValue.split('>');
                        if (parts.length === 3) {
                            const condVowelSpec = parts[0].trim();    // e.g., "*", "a", "i,e"
                            const epentheticSound = parts[1].trim(); // The "......" part, e.g., "n"
                            const finalSuffix = parts[2].trim();     // The main suffix, e.g., "ita"

                            let wordEndsWithQualifyingVowel = false;
                            const languageVowels = currentLanguage.phonology.vowels || [];

                            if (condVowelSpec === '*') { // Any vowel from the language's vowel inventory
                                wordEndsWithQualifyingVowel = languageVowels.some(v => currentWord.endsWith(v));
                            } else { // Specific vowel(s) listed in condVowelSpec
                                const specifiedConditionVowels = condVowelSpec.split(',').map(v => v.trim()).filter(Boolean);
                                wordEndsWithQualifyingVowel = specifiedConditionVowels.some(vCond => 
                                    currentWord.endsWith(vCond) && languageVowels.includes(vCond)
                                );
                            }

                            if (wordEndsWithQualifyingVowel) {
                                inflectedWord = currentWord + epentheticSound + finalSuffix;
                            } else {
                                // Word ends in a consonant, or a vowel not matching the specific condition
                                inflectedWord = currentWord + finalSuffix; // Apply final suffix directly
                            }
                        } else {
                            console.warn("Conditional suffix ruleValue format error:", stepRuleValue, "Expected 3 parts separated by '>'. Applying last part as suffix.");
                            inflectedWord = currentWord + (parts[parts.length-1] || ''); // Fallback
                        }
                    } else {
                         console.warn("Conditional suffix ruleValue is not a string or malformed:", stepRuleValue, "Attempting direct suffixation if string.");
                         if (typeof stepRuleValue === 'string') { // If it's just a string, treat as simple suffix
                            inflectedWord = currentWord + stepRuleValue;
                         }
                    }
                    break;
                case 'none': default: break; 
            }
            return inflectedWord;
        }

        function applyInflectionRuleDefinition(baseWord, ruleDefinition) {
            if (!ruleDefinition || !ruleDefinition.ruleSteps || ruleDefinition.ruleSteps.length === 0) {
                return baseWord;
            }
            let currentWordState = baseWord;
            const sortedSteps = [...ruleDefinition.ruleSteps].sort((a,b) => a.order - b.order);

            for (const step of sortedSteps) {
                const valueToUse = step.ruleValue !== undefined ? step.ruleValue : step.value;
                currentWordState = applyRuleStep(currentWordState, step.ruleType, valueToUse);
            }
            return currentWordState;
        }


        function testConjugation() {
            const wordInput = document.getElementById('conjugationTestWordGrammar');
            const resultDiv = document.getElementById('conjugationTestResultGrammar');
            const inputValue = wordInput.value.trim(); 
        
            if (!inputValue) {
                resultDiv.innerHTML = '<p class="text-red-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô)</p>'; return;
            }
        
            let wordEntry = null;
            const selectedOpt = Array.from(document.getElementById('dictionaryWordsDatalistForConjTest').options).find(opt => opt.value === inputValue || opt.dataset.baseform === inputValue);
            if (selectedOpt && selectedOpt.dataset.wordid) {
                wordEntry = currentLanguage.lexicon.find(w => w.id === parseInt(selectedOpt.dataset.wordid));
            }
            // Fallback: Search by orthographic form or base phonemic form if datalist selection failed or wasn't used
            if (!wordEntry) {
                wordEntry = currentLanguage.lexicon.find(w => getOrthographicForm(w) === inputValue || w.word === inputValue);
            }
        
            if (!wordEntry) {
                resultDiv.innerHTML = `<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "${inputValue}" ‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</p>`; return;
            }
        
            const wordPOS = wordEntry.partOfSpeech;
            let htmlResult = `<h5 class="font-semibold">‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö: ${getOrthographicForm(wordEntry)} (${wordEntry.meaning}) - POS: ${wordPOS}</h5>`;
            
            htmlResult += `<div class="my-2"><strong>‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> <select id="conjTestCategoryFilter" multiple class="w-full p-1 border rounded text-sm h-20">`;
            currentLanguage.grammar.morphology.conjugationCategories.forEach(cat => {
                if (cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"))) {
                     htmlResult += `<option value="${cat.id}" selected>${cat.name}</option>`; 
                }
            });
            htmlResult += `</select><button onclick="updateConjugationTestTable(${wordEntry.id})" class="text-xs btn-secondary mt-1">‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</button></div>`; 


            htmlResult += `<div id="conjugationTestTableContainer">`; 
            htmlResult += generateConjugationTableContent(wordEntry.id, null); 
            htmlResult += `</div>`;

            resultDiv.innerHTML = htmlResult;
            const filterSelect = document.getElementById('conjTestCategoryFilter');
            if(filterSelect) filterSelect.onchange = () => updateConjugationTestTable(wordEntry.id);
        }

        function updateConjugationTestTable(wordId) {
            const filterSelect = document.getElementById('conjTestCategoryFilter');
            const selectedCategoryIds = filterSelect ? Array.from(filterSelect.selectedOptions).map(opt => opt.value) : null;
            const tableContainer = document.getElementById('conjugationTestTableContainer');
            if (tableContainer) {
                tableContainer.innerHTML = generateConjugationTableContent(wordId, selectedCategoryIds);
            }
        }

        function generateConjugationTableContent(wordId, selectedCategoryIds = null) {
            const wordEntry = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
            if (!wordEntry) return '<p>Error: Word not found.</p>';

            const wordPOS = wordEntry.partOfSpeech;
            let tableContent = `<table class="min-w-full divide-y divide-gray-200 table-sm mt-2">
                                <thead class="bg-gray-50"><tr>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-500 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á)</th>
                                </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            
            let foundApplicableCategory = false;
            let categoryColorIndex = 0; 
            const applicableCategories = currentLanguage.grammar.morphology.conjugationCategories.filter(cat => {
                if (selectedCategoryIds && !selectedCategoryIds.includes(cat.id)) return false; 
                return cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"));
            });


            applicableCategories.forEach(cat => {
                foundApplicableCategory = true;
                const categoryBgClass = `inflection-category-bg-${categoryColorIndex % 3}`; 
                cat.options.forEach((option, optIndex) => {
                    const manualInflectionKey = `${cat.id}_${option.replace(/\s+/g, '_')}`; 
                    const manualInflection = wordEntry.manualInflections ? wordEntry.manualInflections[manualInflectionKey] : null;
                    
                    let inflectedPhoneticForm = wordEntry.word; 
                    let inflectedOrthographicForm; // Will be determined below
                    let isManual = false;

                    if (manualInflection && manualInflection.phonetic) { 
                        inflectedPhoneticForm = manualInflection.phonetic;
                        // For manual overrides, customOrthography field of the manualInflection should be used if present.
                        // If not, transliterate the manual phonetic form (using first grapheme rule).
                        inflectedOrthographicForm = manualInflection.orthographic || getOrthographicForm({word: inflectedPhoneticForm, customOrthography: null}, true, true);
                        isManual = true;
                    } else {
                        const rule = currentLanguage.grammar.morphology.conjugationRules.find(r =>
                            (r.partOfSpeech === wordPOS || wordPOS.startsWith(r.partOfSpeech + ":")) && 
                            r.categoryId === cat.id && r.categoryOption === option
                        );
                        if (rule) { // Rule itself contains ruleSteps
                            inflectedPhoneticForm = applyInflectionRuleDefinition(wordEntry.word, rule); // Use the new function
                            // For rule-generated forms, use the first grapheme rule for consistency.
                            inflectedOrthographicForm = getOrthographicForm({word: inflectedPhoneticForm, customOrthography: null}, true, true);
                        } else {
                            // No rule, no manual override: show base form, transliterated with first grapheme rule.
                            inflectedPhoneticForm = wordEntry.word;
                            inflectedOrthographicForm = getOrthographicForm({word: wordEntry.word, customOrthography: null}, true, true);
                        }
                    }
                    
                    const formattedPhoneticDisplay = autoFormatDetailedPhonetics(inflectedPhoneticForm, currentLanguage.phonology);
                    
                    let orthoCell = inflectedOrthographicForm;
                    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô logographic: ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û logograph ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ (‡πÄ‡∏ä‡πà‡∏ô ‡∏´‡∏•‡∏≤‡∏¢ step ‡πÉ‡∏ô ruleSteps ‡∏ó‡∏µ‡πà‡∏°‡∏µ logographImage) ‡πÉ‡∏ô cell ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
                    const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';
                    let logographImgs = [];
                    if (isLogographic) {
                        // 1. manual inflection override for this form (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
                        if (manualInflection && manualInflection.logographImage) {
                            logographImgs.push(manualInflection.logographImage);
                        } else {
                            // 2. ‡∏î‡∏∂‡∏á‡∏†‡∏≤‡∏û‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡πÅ‡∏£‡∏Å
                            if (wordEntry.logographImage) {
                                logographImgs.push(wordEntry.logographImage);
                            }
                            // 3. ‡∏à‡∏≤‡∏Å ruleSteps ‡∏Ç‡∏≠‡∏á inflection rule (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
                            const rule = (currentLanguage.grammar.morphology.conjugationRules||[]).find(r => r.categoryId === cat.id && r.categoryOption === option && r.partOfSpeech === wordPOS);
                            if (rule && Array.isArray(rule.ruleSteps)) {
                                rule.ruleSteps.forEach(s => {
                                    if (s.logographImage) logographImgs.push(s.logographImage);
                                });
                            }
                        }
                    }
                    if (isLogographic && logographImgs.length > 0) {
                        orthoCell = logographImgs.map(img => `<img src="${img}" alt="logograph" style="max-height:2.5rem;max-width:2.5rem;background:transparent;border:none;box-shadow:none;border-radius:0;display:inline-block;margin-right:0.25rem;"/>`).join('');
                    }
                    tableContent += `<tr class="${categoryBgClass}">
                                    <td class="px-2 py-1">${optIndex === 0 ? cat.name : ''}</td>
                                    <td class="px-2 py-1">${option} ${isManual ? '<em class=\"text-xs text-blue-500\">(manual)</em>' : ''}</td>
                                    <td class="px-2 py-1 font-mono">${orthoCell}</td>
                                    <td class="px-2 py-1 font-mono text-gray-600">${formattedPhoneticDisplay}</td>
                                   </tr>`;
                });
                categoryColorIndex++;
            });
        
            if (!foundApplicableCategory) { 
                tableContent += `<tr><td colspan="4" class="text-center py-2">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ (${wordPOS}) ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</td></tr>`;
            }
            tableContent += `</tbody></table>`;
            return tableContent;
        }


        window.showWordConjugationModal = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;
            word.manualInflections = word.manualInflections || {}; 

            const wordPOS = word.partOfSpeech;
            let content = `<p class="text-sm mb-2">‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á): <strong class="font-mono">${word.word}</strong> | ‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ): <strong class="font-mono">${getOrthographicForm(word)}</strong></p>`;
            
            content += `<div class="my-2"><strong>‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> <select id="conjModalCategoryFilter" multiple class="w-full p-1 border rounded text-sm h-20">`;
            currentLanguage.grammar.morphology.conjugationCategories.forEach(cat => {
                 if (cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"))) {
                     content += `<option value="${cat.id}" selected>${cat.name}</option>`;
                 }
            });
            content += `</select><button onclick="updateWordConjugationModalTable(${wordId})" class="text-xs btn-secondary mt-1">‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</button></div>`;

            content += `<div id="wordConjugationModalTableContainer">`; 
            content += generateWordConjugationModalTableContent(word.id, null); 
            content += `</div>`;
            
            genericModalTitle.innerHTML = `‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏á: ${getOrthographicForm(word)}`;
            genericModalContent.innerHTML = content;
            genericModalFooter.innerHTML = `<button id="saveConjugationOverridesBtn" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button> <button class="btn-secondary" onclick="closeGenericModal.click()">‡∏õ‡∏¥‡∏î</button>`;
            
            document.getElementById('saveConjugationOverridesBtn').onclick = () => {
                saveConjugationOverrides(wordId);
                genericModal.classList.add('hidden');
            };
            const filterSelect = document.getElementById('conjModalCategoryFilter');
            if(filterSelect) filterSelect.onchange = () => updateWordConjugationModalTable(wordId);

            wordDetailModal.classList.add('hidden'); 
            genericModal.classList.remove('hidden');
        };

        function updateWordConjugationModalTable(wordId) {
            const filterSelect = document.getElementById('conjModalCategoryFilter');
            const selectedCategoryIds = filterSelect ? Array.from(filterSelect.selectedOptions).map(opt => opt.value) : null;
            const tableContainer = document.getElementById('wordConjugationModalTableContainer');
            if (tableContainer) {
                tableContainer.innerHTML = generateWordConjugationModalTableContent(wordId, selectedCategoryIds);
            }
        }

        function generateWordConjugationModalTableContent(wordId, selectedCategoryIds = null) {
             const word = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
             if (!word) return '<p>Error: Word not found.</p>';
             word.manualInflections = word.manualInflections || {};
             const wordPOS = word.partOfSpeech;

             let tableContent = `<table class="min-w-full divide-y divide-gray-200 table-sm mt-2">
                                <thead class="bg-gray-100"><tr>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡πà‡∏≠‡∏¢</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">Override</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)</th>
                                    <th class="px-2 py-1 text-left text-xs font-medium text-gray-600 uppercase">‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á)</th>
                                </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            
            let foundApplicableCategory = false;
            let categoryColorIndex = 0;
            const applicableCategories = currentLanguage.grammar.morphology.conjugationCategories.filter(cat => {
                if (selectedCategoryIds && !selectedCategoryIds.includes(cat.id)) return false;
                return cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":"));
            });

            applicableCategories.forEach(cat => {
                foundApplicableCategory = true;
                const categoryBgClass = `inflection-category-bg-${categoryColorIndex % 3}`;

                cat.options.forEach((option, optIndex) => {
                    const manualInflectionKey = `${cat.id}_${option.replace(/\s+/g, '_')}`;
                    const currentManualOverride = word.manualInflections[manualInflectionKey];

                    let ruleBasedPhonetic = word.word;
                    let ruleBasedOrthographic = getOrthographicForm(word, true, true);
                    const rule = currentLanguage.grammar.morphology.conjugationRules.find(r =>
                        (r.partOfSpeech === wordPOS || wordPOS.startsWith(r.partOfSpeech+":")) &&
                        r.categoryId === cat.id && r.categoryOption === option
                    );
                    if (rule) {
                        // Apply rules separately on phonemic and orthographic bases
                        ruleBasedPhonetic = applyInflectionRuleDefinition(word.word, rule);
                        const baseOrthForm = getOrthographicForm(word, true, true);
                        ruleBasedOrthographic = applyInflectionRuleDefinition(baseOrthForm, rule);
                    }
                    // NOTE: orthographic inflection is now based on the orthographic form, not mapped from phonetics.

                    const initialOrthoValue = currentManualOverride?.orthographic || ruleBasedOrthographic;
                    const initialPhoneticValue = currentManualOverride?.phonetic || ruleBasedPhonetic;
                    // --- ‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á: ‡πÉ‡∏´‡πâ‡∏à‡∏∏‡∏î (.) ‡πÄ‡∏õ‡πá‡∏ô span ‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÑ‡∏î‡πâ ---
                    let displayPhoneticFormatted = autoFormatDetailedPhonetics(initialPhoneticValue, currentLanguage.phonology);
                    displayPhoneticFormatted = displayPhoneticFormatted.replace(/\./g, '<span class="phon-dot" contenteditable="true" title="‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏∏‡∏î">.</span>');

                    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô logographic: ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û logograph ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ (‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô+‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢) ‡πÉ‡∏ô cell ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
                    const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';
                    let orthoCell = '';
                    if (currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'custom' && Array.isArray(currentLanguage.orthography.customSymbols) && currentLanguage.orthography.customSymbols.length > 0) {
                        // ‡πÉ‡∏ä‡πâ transliterateWordToSymbols ‡πÅ‡∏ö‡∏ö returnHtml = true
                        orthoCell = transliterateWordToSymbols(ruleBasedPhonetic, true, true, true);
                    } else if (isLogographic) {
                        let logographImgs = [];
                        if (currentManualOverride && currentManualOverride.logographImage) {
                            logographImgs.push(currentManualOverride.logographImage);
                        } else {
                            if (word.logographImage) {
                                logographImgs.push(word.logographImage);
                            }
                            if (rule && Array.isArray(rule.ruleSteps)) {
                                rule.ruleSteps.forEach(s => {
                                    if (s.logographImage) logographImgs.push(s.logographImage);
                                });
                            }
                        }
                        if (logographImgs.length > 0) {
                            orthoCell = logographImgs.map(img => `<img src="${img}" alt="logograph" style="max-height:2.5rem;max-width:2.5rem;background:transparent;border:none;box-shadow:none;border-radius:0;display:inline-block;margin-right:0.25rem;"/>`).join('');
                        }
                    } else {
                        orthoCell = `<input type=\"text\" class=\"w-full p-0.5 border rounded text-xs font-mono manual-ortho-input\" data-key=\"${manualInflectionKey}\" value=\"${initialOrthoValue}\" ${!currentManualOverride ? 'disabled' : ''}>`;
                    }
                    tableContent += `<tr class="${categoryBgClass}">
                        <td class="px-2 py-1 ${optIndex === 0 ? 'font-semibold text-purple-700' : ''}">${optIndex === 0 ? cat.name : ''}</td>
                        <td class="px-2 py-1">${option}</td>
                        <td class="px-2 py-1">
                            <input type="checkbox" class="manual-override-chk h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500" data-key="${manualInflectionKey}" ${currentManualOverride ? 'checked' : ''} 
                                   onchange="toggleManualInflectionInputs(this, '${manualInflectionKey}', '${ruleBasedOrthographic}', '${ruleBasedPhonetic}', ${wordId})">
                        </td>
                        <td class="px-2 py-1 font-mono">${orthoCell}</td>
                        <td class="px-2 py-1">
                            <input type="text" class="w-full p-0.5 border rounded text-xs font-mono manual-phonetic-input" data-key="${manualInflectionKey}" 
                                   value="${initialPhoneticValue}" ${!currentManualOverride ? 'disabled' : ''} 
                                   placeholder="‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏î‡∏¥‡∏ö)" oninput="updateFormattedPhoneticDisplay(this, '${manualInflectionKey}')">
                            <span class="text-xs text-gray-500 manual-phonetic-display" data-key="${manualInflectionKey}" contenteditable="true" spellcheck="false" title="‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÅ‡∏•‡∏∞‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏∏‡∏î‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á">${displayPhoneticFormatted}</span>
                        </td>
                    </tr>`;
// (manual-phonetic-display is now fully editable; .phon-dot event delegation removed)
                });
                categoryColorIndex++;
            });

            if (!foundApplicableCategory) {
                 tableContent += `<tr><td colspan="5" class="text-center py-2">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ (${wordPOS}) ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á</td></tr>`;
            }
            tableContent += `</tbody></table>`;
            return tableContent;
        }

        function updateFormattedPhoneticDisplay(inputElement, key) {
            const displaySpan = inputElement.parentElement.querySelector(`.manual-phonetic-display[data-key="${key}"]`);
            if (displaySpan) {
                displaySpan.textContent = autoFormatDetailedPhonetics(inputElement.value, currentLanguage.phonology);
            }
        }


        function toggleManualInflectionInputs(checkbox, key, ruleBasedOrthographic, ruleBasedPhonetic, wordId) {
            const row = checkbox.closest('tr');
            const orthoInput = row.querySelector(`.manual-ortho-input[data-key="${key}"]`);
            const phoneticInput = row.querySelector(`.manual-phonetic-input[data-key="${key}"]`);
            const phoneticDisplaySpan = phoneticInput.nextElementSibling; 

            if (checkbox.checked) {
                orthoInput.disabled = false;
                phoneticInput.disabled = false;
            } else {
                orthoInput.disabled = true;
                phoneticInput.disabled = true;
                orthoInput.value = ruleBasedOrthographic;
                phoneticInput.value = ruleBasedPhonetic; 
                if (phoneticDisplaySpan) phoneticDisplaySpan.textContent = autoFormatDetailedPhonetics(ruleBasedPhonetic, currentLanguage.phonology);
            }
        }
        
        function saveConjugationOverrides(wordId) {
            const word = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
            if (!word) return;
            word.manualInflections = word.manualInflections || {}; 

            genericModalContent.querySelectorAll('.manual-override-chk').forEach(chk => {
                const key = chk.dataset.key;
                if (chk.checked) {
                    const orthoInput = genericModalContent.querySelector(`.manual-ortho-input[data-key="${key}"]`);
                    const phoneticInput = genericModalContent.querySelector(`.manual-phonetic-input[data-key="${key}"]`);
                    let phoneticVal = phoneticInput.value;
                    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ .phon-dot ‡πÉ‡∏ô manual-phonetic-display ‡πÉ‡∏´‡πâ‡∏î‡∏∂‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏∏‡∏î‡∏à‡∏≤‡∏Å span
                    const phoneticDisplay = genericModalContent.querySelector(`.manual-phonetic-display[data-key="${key}"]`);
                    if (phoneticDisplay && phoneticDisplay.querySelector('.phon-dot')) {
                        // ‡∏™‡∏£‡πâ‡∏≤‡∏á string ‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å innerText ‡∏Ç‡∏≠‡∏á phoneticDisplay (‡∏à‡∏∞‡∏£‡∏ß‡∏°‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç)
                        phoneticVal = '';
                        phoneticDisplay.childNodes.forEach(node => {
                            if (node.nodeType === Node.TEXT_NODE) {
                                phoneticVal += node.textContent;
                            } else if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('phon-dot')) {
                                phoneticVal += '.';
                            }
                        });
                    }
                    word.manualInflections[key] = {
                        orthographic: orthoInput.value.trim(),
                        phonetic: phoneticVal.trim()
                    };
                } else {
                    delete word.manualInflections[key];
                }
            });
            saveData();
            // ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô modal ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
            const tableContainer = document.getElementById('wordConjugationModalTableContainer');
            if (tableContainer) {
                const filterSelect = document.getElementById('conjModalCategoryFilter');
                const selectedCategoryIds = filterSelect ? Array.from(filterSelect.selectedOptions).map(opt => opt.value) : null;
                tableContainer.innerHTML = generateWordConjugationModalTableContent(wordId, selectedCategoryIds);
            }
            if (activeTab === 'dictionary') {
                 const searchInputEl = document.querySelector('#dictionaryTabSpecificContent input[type="text"][id^="dictionarySearch_"]');
                 const currentSearchTerm = searchInputEl ? searchInputEl.value.trim().toLowerCase() : "";
                 
                 if (currentSearchTerm.length > 0) {
                    const filtered = currentLanguage.lexicon.filter(entry =>
                        getOrthographicForm(entry).toLowerCase().includes(currentSearchTerm) || 
                        entry.word.toLowerCase().includes(currentSearchTerm) || 
                        entry.meaning.toLowerCase().includes(currentSearchTerm) ||
                        (entry.phonetics && autoFormatDetailedPhonetics(entry.phonetics, currentLanguage.phonology).toLowerCase().includes(currentSearchTerm)) || 
                        (entry.synonyms && entry.synonyms.some(s => s.toLowerCase().includes(currentSearchTerm)))
                    ).slice(0, 50); 
                    renderDictionaryTable(filtered);
                } else {
                    renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
                }
            }
        }



        function renderDictionaryUI(container) {
            // --- ‡∏õ‡∏∏‡πà‡∏° Export Excel ---
            const exportRow = document.createElement('div');
            exportRow.className = 'flex justify-end mb-4';
            const exportBtn = document.createElement('button');
            exportBtn.type = 'button';
            exportBtn.className = 'px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700 transition-colors flex items-center gap-2 shadow';
            exportBtn.innerHTML = '<i class="fas fa-file-excel"></i> Export Excel (.xlsx)';
            exportBtn.onclick = exportLexiconToExcel;
            exportRow.appendChild(exportBtn);
            container.appendChild(exportRow);

            // ...existing code for rendering dictionary UI...
        // --- Export Lexicon to Excel (.xlsx) ---
        function exportLexiconToExcel() {
            // Check if XLSX is loaded, if not, load from CDN then call again
            if (typeof window.XLSX === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
                script.onload = exportLexiconToExcel;
                document.body.appendChild(script);
                return;
            }
            // Prepare data
            const lexicon = currentLanguage.lexicon || [];
            if (!lexicon.length) {
                alert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°');
                return;
            }
            // Map to flat array of objects for Excel
            const data = lexicon.map(w => ({
                '‡∏•‡∏≥‡∏î‡∏±‡∏ö': w.id || '',
                '‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå': w.word || '',
                '‡∏™‡∏±‡∏ó‡∏≠‡∏±‡∏Å‡∏©‡∏£': w.phonetics || '',
                '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢': w.meaning || '',
                '‡∏ä‡∏ô‡∏¥‡∏î‡∏Ñ‡∏≥': w.partOfSpeech || '',
                '‡πÄ‡∏û‡∏®': w.gender || '',
                '‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ': w.customOrthography || '',
                '‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå': (w.etymology && w.etymology.roots && w.etymology.roots.length) ? w.etymology.roots.join(', ') : '',
                '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå': (w.etymology && w.etymology.notes) ? w.etymology.notes : '',
                '‡∏£‡∏π‡∏õ‡∏ú‡∏±‡∏ô/‡∏Ñ‡∏≥‡∏¢‡πà‡∏≠‡∏¢': (w.manualInflections && Object.keys(w.manualInflections).length) ? JSON.stringify(w.manualInflections) : '',
                '‡πÑ‡∏ó‡∏°‡πå‡πÑ‡∏•‡∏ô‡πå‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£': (w.evolutionTimeline && w.evolutionTimeline.length) ? JSON.stringify(w.evolutionTimeline) : '',
                '‡∏£‡∏π‡∏õ‡∏ñ‡∏¥‡πà‡∏ô': (w.dialectalForms && w.dialectalForms.length) ? JSON.stringify(w.dialectalForms) : ''
            }));
            // Create worksheet and workbook
            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Lexicon');
            // Download
            const langName = currentLanguage.name ? currentLanguage.name.replace(/[^a-zA-Z0-9‡∏Å-‡πô]/g, '_') : 'lexicon';
            XLSX.writeFile(wb, `${langName}_lexicon.xlsx`);
        }
            currentLanguage.lexicon = currentLanguage.lexicon || [];
            const dictContainerId = 'dictionaryTabSpecificContent';
            let dictContainer = container.querySelector(`#${dictContainerId}`);
            if(!dictContainer){
                dictContainer = document.createElement('div');
                dictContainer.id = dictContainerId;
                container.appendChild(dictContainer);
            }
            dictContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-yellow-200 rounded-md bg-yellow-50';
            const searchId = `dictionarySearch_${Date.now()}`; 
            const suggestionsId = `autocompleteSuggestionsContainer_${Date.now()}`;

            section.innerHTML = `
                <div class="flex flex-wrap gap-4 mb-4 items-center">
                    <div class="relative flex-grow min-w-[200px]">
                        <input type="text" id="${searchId}" placeholder="üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ, ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô, ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢, ‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå)..." class="w-full p-2 border border-yellow-300 rounded-md">
                        <div id="${suggestionsId}" class="autocomplete-suggestions hidden bg-white border border-gray-300 rounded-md shadow-lg" style="width: calc(100% - 0px); top: 100%; left:0;"></div>
                    </div>
                     <button id="clearSearchBtnDict" class="btn-secondary bg-gray-400 hover:bg-gray-500 px-3 py-2 rounded-md text-sm">‡∏•‡πâ‡∏≤‡∏á</button>
                </div>
                <div class="flex flex-wrap gap-2 mb-4 items-center">
                    <button id="exportJsonBtnDict" class="btn-secondary bg-amber-400 hover:bg-amber-500 px-3 py-1 rounded-md text-sm"><i class="fas fa-file-export mr-1"></i>Export JSON</button>
                    <button id="exportCsvBtnDict" class="btn-secondary bg-amber-400 hover:bg-amber-500 px-3 py-1 rounded-md text-sm"><i class="fas fa-file-csv mr-1"></i>Export CSV</button>
                    <button id="showAddWordModalBtnDict" class="btn-primary bg-yellow-500 hover:bg-yellow-600 py-2 px-4 rounded-md ml-auto"><i class="fas fa-plus mr-1"></i>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà</button>
                </div>
                <div id="dictionaryTableContainer" class="overflow-x-auto">
                     <p class="text-center text-gray-500">‡∏û‡∏¥‡∏°‡∏û‡πå‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà (‡πÅ‡∏™‡∏î‡∏á ${currentLanguage.lexicon.length} ‡∏Ñ‡∏≥)</p>
                </div>`;
            dictContainer.appendChild(section);

            const searchInput = document.getElementById(searchId);
            const suggestionsContainer = document.getElementById(suggestionsId);

            const doSearch = () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                 if (searchTerm.length > 0) {
                    const filtered = currentLanguage.lexicon.filter(entry =>
                        getOrthographicForm(entry).toLowerCase().includes(searchTerm) || 
                        entry.word.toLowerCase().includes(searchTerm) || 
                        entry.meaning.toLowerCase().includes(searchTerm) ||
                        (entry.phonetics && entry.phonetics.toLowerCase().includes(searchTerm)) || 
                        (entry.synonyms && entry.synonyms.some(s => s.toLowerCase().includes(searchTerm)))
                    ).slice(0, 50); 
                    renderDictionaryTable(filtered);
                } else {
                    renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
                }
            };

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                if (searchTerm.length > 0) {
                    const suggestions = currentLanguage.lexicon
                        .filter(entry => 
                            getOrthographicForm(entry).toLowerCase().startsWith(searchTerm) || 
                            entry.word.toLowerCase().startsWith(searchTerm) || 
                            entry.meaning.toLowerCase().startsWith(searchTerm)
                        )
                        .slice(0, 10); 

                    suggestionsContainer.innerHTML = '';
                    if (suggestions.length > 0) {
                        suggestions.forEach(suggestion => {
                            const div = document.createElement('div');
                            div.textContent = `${getOrthographicForm(suggestion)} (${suggestion.meaning}) [${suggestion.word}]`;
                            div.className = 'autocomplete-suggestion p-2 hover:bg-gray-100 cursor-pointer';
                            div.onclick = () => {
                                searchInput.value = getOrthographicForm(suggestion); 
                                suggestionsContainer.classList.add('hidden');
                                doSearch(); 
                            };
                            suggestionsContainer.appendChild(div);
                        });
                        suggestionsContainer.classList.remove('hidden');
                    } else {
                        suggestionsContainer.classList.add('hidden');
                    }
                } else {
                    suggestionsContainer.classList.add('hidden');
                }
                doSearch(); 
            });

            document.getElementById('clearSearchBtnDict').addEventListener('click', () => {
                searchInput.value = '';
                suggestionsContainer.classList.add('hidden');
                renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
            });

            document.addEventListener('click', function(event) {
                if (searchInput && suggestionsContainer && !searchInput.contains(event.target) && !suggestionsContainer.contains(event.target)) {
                    suggestionsContainer.classList.add('hidden');
                }
            });

            document.getElementById('exportJsonBtnDict').addEventListener('click', exportDictionaryAsJSON);
            document.getElementById('exportCsvBtnDict').addEventListener('click', exportDictionaryAsCSV);
            document.getElementById('showAddWordModalBtnDict').addEventListener('click', () => showWordModal());

            renderDictionaryTable(currentLanguage.lexicon.slice(0,50)); 
        }

        function renderDictionaryTable(lexiconSubset) {
            const container = document.getElementById('dictionaryTableContainer');
            if (!container) return;
            container.innerHTML = ''; 

            if (!lexiconSubset || lexiconSubset.length === 0) {
                container.innerHTML = `<p class="text-center text-gray-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${currentLanguage.lexicon.length} ‡∏Ñ‡∏≥)</p>`;
                return;
            }

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-yellow-300 bg-white shadow-sm rounded-lg';
            const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';
            table.innerHTML = `
                <thead class="bg-yellow-100">
                    <tr>
                        ${isLogographic ? '<th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏†‡∏≤‡∏û)</th>' : ''}
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á)</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î)</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider hidden sm:table-cell">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-yellow-700 uppercase tracking-wider">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-yellow-200"></tbody>
            `;
            const tbody = table.querySelector('tbody');
            lexiconSubset.forEach(entry => {
                const row = tbody.insertRow();
                const displayWord = getOrthographicForm(entry);
                let cells = '';
                if (isLogographic) {
                    cells += `<td class="px-4 py-2 whitespace-nowrap">${entry.logographImage ? `<a href=\"#\" onclick=\"event.preventDefault(); showWordDetailPopup(${entry.id})\"><img src=\"${entry.logographImage}\" alt=\"logograph\" style=\"max-height:3rem;max-width:3rem;background:transparent;border:none;box-shadow:none;border-radius:0;\"/></a>` : ''}</td>`;
                }
                cells += `
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-700 font-semibold">${isLogographic ? displayWord : `<a href=\"#\" class=\"text-purple-600 hover:underline\" onclick=\"event.preventDefault(); showWordDetailPopup(${entry.id})\">${displayWord}</a>`}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 font-mono">${entry.word}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500 font-mono">
                        ${entry.phonetics 
                            ? `<div class="flex items-center flex-wrap dict-phonetic-container" data-phonetic="${entry.phonetics}" data-voiceid="${entry.voiceId || ''}">
                                <span class="mr-1">${entry.phonetics}</span>
                                <button type="button" class="text-blue-500 ml-1 dict-phonetics-btn"><i class="fas fa-headphones"></i></button>
                                <span class="text-xs text-blue-500 ml-1 cursor-pointer dict-phonetics-btn">‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
                                <button type="button" class="accent-toggle-btn text-blue-500 ml-1" title="‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏≥‡πÄ‡∏ô‡∏µ‡∏¢‡∏á"><i class="fas fa-language"></i></button>
                                <select class="voice-select ml-1 text-xs p-0.5 border rounded hidden" data-hide-after-select="true" data-selected-voice="${entry.voiceId || ''}"></select>
                            </div>`
                            : 'N/A'
                        }
                    </td>
                    <td class="px-4 py-2 text-sm text-gray-700">${entry.meaning}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${entry.partOfSpeech} ${entry.gender ? `(${entry.gender})` : ''}</td>
                    <td class="px-4 py-2 text-sm text-gray-500 hidden sm:table-cell">${entry.example || 'N/A'}</td>
                    <td class="px-4 py-2 whitespace-nowrap text-sm">
                        <button class="text-indigo-500 hover:text-indigo-700 mr-1" title="‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå" onclick="showSynonymsModal(${entry.id})"><i class="fas fa-sync-alt"></i></button>
                        <button class="text-blue-500 hover:text-blue-700 mr-1" title="‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç" onclick="showWordModal(${entry.id})"><i class="fas fa-edit"></i></button>
                        <button class="text-red-500 hover:text-red-700" title="‡∏•‡∏ö" onclick="deleteWordFromDictionary(${entry.id})"><i class="fas fa-trash"></i></button>
                    </td>
                `;
                row.innerHTML = cells;
            });
            container.appendChild(table);
            // Attach phonetics play events and populate voice selects for dictionary
            const dictButtons = table.querySelectorAll('.dict-phonetics-btn');
            dictButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const wrapper = btn.closest('.dict-phonetic-container');
                    const phon = wrapper ? wrapper.getAttribute('data-phonetic') : '';
                    let voiceName = null;
                    if (wrapper) {
                        const voiceSel = wrapper.querySelector('select.voice-select');
                        if (voiceSel && voiceSel.value) {
                            voiceName = voiceSel.value;
                        } else {
                            // fallback to stored voiceId on wrapper if present
                            const v = wrapper.getAttribute('data-voiceid');
                            if (v) voiceName = v;
                        }
                    }
                    speakPhonetics(phon, voiceName);
                });
            });
            if (typeof updateVoiceSelects === 'function') {
                updateVoiceSelects();
            }
            container.innerHTML += `<p class="text-xs text-gray-400 mt-1">‡πÅ‡∏™‡∏î‡∏á ${lexiconSubset.length} ‡∏à‡∏≤‡∏Å ${currentLanguage.lexicon.length} ‡∏Ñ‡∏≥</p>`;
        }
        
        window.showSynonymsModal = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;

            genericModalTitle.textContent = `‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå‡∏Ç‡∏≠‡∏á: ${getOrthographicForm(word)}`;
            let contentHtml = '';
            if (word.synonyms && word.synonyms.length > 0) {
                contentHtml += '<ul class="list-disc list-inside space-y-1">';
                word.synonyms.forEach(synonymText => {
                    const synonymEntry = currentLanguage.lexicon.find(w => w.word === synonymText || getOrthographicForm(w) === synonymText);
                    if (synonymEntry) {
                        contentHtml += `<li><strong>${getOrthographicForm(synonymEntry)}</strong> (${synonymEntry.meaning})</li>`;
                    } else {
                        contentHtml += `<li>${synonymText} (‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°)</li>`;
                    }
                });
                contentHtml += '</ul>';
            } else {
                contentHtml = '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ</p>';
            }
            genericModalContent.innerHTML = contentHtml;
            genericModalFooter.innerHTML = `<button class="btn-secondary" onclick="closeGenericModal.click()">‡∏õ‡∏¥‡∏î</button>`;
            genericModal.classList.remove('hidden');
        };


        window.showWordDetailPopup = (wordId) => {
            const word = (currentLanguage.lexicon || []).find(w => w.id === wordId);
            if (!word) return;
        
            wordDetailTitle.innerHTML = getOrthographicForm(word);
            let contentHtml = '';
            // Show logograph image at the top if in logographic mode and image exists
            const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';
            if (isLogographic && word.logographImage) {
                contentHtml += `<div style="display:flex;justify-content:center;align-items:center;margin-bottom:1rem;padding:0.5rem 0;background:none !important;border:none !important;box-shadow:none !important;">
                  <img src="${word.logographImage}" alt="logograph" style="display:block;max-height:5rem;max-width:5rem;background:transparent !important;background-color:transparent !important;border:none !important;box-shadow:none !important;outline:none !important;border-radius:0 !important;padding:0;"/>
                </div>`;
            }
            const fields = [
                { label: '‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ)', value: getOrthographicForm(word) },
                { label: '‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (Base Phonemic Form)', value: word.word },
                { label: '‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Detailed Phonetics)', value: word.phonetics },
                { label: '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢ (Meaning)', value: word.meaning },
                { label: '‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥ (Part of Speech)', value: word.partOfSpeech },
            ];
            if (currentLanguage.grammar.hasGender && word.gender) {
                fields.push({ label: '‡πÄ‡∏û‡∏® (Gender)', value: word.gender });
            }
            fields.push(
                { label: '‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ (Example)', value: word.example },
                { label: '‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå (Synonyms)', value: word.synonyms ? word.synonyms.join(', ') : null }
            );
            fields.forEach(field => {
                if (field.value && field.value.toString().trim() !== '') {
                    // If this field represents phonetic details, render with audio and accent controls
                    if (field.label && (field.label.includes('‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á') || field.label.toLowerCase().includes('phonetics'))) {
                        const ipaValue = field.value.toString();
                        contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">${field.label}:</strong> ` +
                            `<div class="flex items-center flex-wrap dict-phonetic-container" data-phonetic="${ipaValue}" data-voiceid="${word.voiceId || ''}">` +
                                `<span class="mr-1">${ipaValue}</span>` +
                                `<button type="button" class="text-blue-500 ml-1 dict-phonetics-btn" title="‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"><i class="fas fa-headphones"></i></button>` +
                                `<button type="button" class="accent-toggle-btn text-blue-500 ml-1" title="‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏≥‡πÄ‡∏ô‡∏µ‡∏¢‡∏á"><i class="fas fa-language"></i></button>` +
                                `<select class="voice-select ml-1 text-xs p-0.5 border rounded hidden" data-hide-after-select="true" data-selected-voice="${word.voiceId || ''}"></select>` +
                            `</div>` +
                        `</div>`;
                    } else {
                        contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">${field.label}:</strong> ${field.value}</div>`;
                    }
                }
            });
        
            if (word.etymology) {
                let etymologyHtml = '';
                if (word.etymology.notes) etymologyHtml += `<p class="text-xs"><strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${word.etymology.notes}</p>`;
                if (word.etymology.roots && word.etymology.roots.length > 0) {
                    etymologyHtml += `<p class="mt-1 text-xs"><strong>‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå:</strong></p><ul class="list-disc list-inside ml-4 text-xs">`;
                    word.etymology.roots.forEach(root => {
                        if (root.wordId) {
                            const parentWord = currentLanguage.lexicon.find(w => w.id === root.wordId);
                            etymologyHtml += `<li>‡∏à‡∏≤‡∏Å: <strong>${parentWord ? getOrthographicForm(parentWord) : '‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏•‡∏ö'}</strong> <span class="font-mono text-xs text-gray-500">[‡∏ê‡∏≤‡∏ô: ${parentWord ? parentWord.word : 'N/A'}]</span></li>`;
                        } else if (root.customRoot) {
                            etymologyHtml += `<li>‡∏°‡∏≤‡∏à‡∏≤‡∏Å: <strong>${root.customRoot}</strong> (${root.sourceLang || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'})</li>`;
                        }
                    });
                    etymologyHtml += `</ul>`;
                }
                if (etymologyHtml) contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (Etymology):</strong>${etymologyHtml}</div>`;
            }
        
            if (word.evolutionTimeline && word.evolutionTimeline.length > 0) {
                let evolutionHtml = `<p class="mt-1 text-xs"><strong>‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡∏≤‡∏°‡∏¢‡∏∏‡∏Ñ:</strong></p><ul class="list-disc list-inside ml-4 text-xs">`;
                const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));
                sortedEras.forEach(era => {
                    const evoEntry = word.evolutionTimeline.find(e => e.eraId === era.id);
                    if (evoEntry && (evoEntry.orthographicForm || evoEntry.phoneticForm)) {
                         evolutionHtml += `<li><strong>${era.name}:</strong> ${getOrthographicForm({word: evoEntry.phoneticForm, customOrthography: evoEntry.orthographicForm})} ${evoEntry.notes ? `(${evoEntry.notes})` : ''}</li>`;
                    }
                });
                evolutionHtml += `</ul>`;
                contentHtml += `<div class="word-detail-popup-field"><strong class="text-purple-600">‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥ (Evolution):</strong>${evolutionHtml}</div>`;
            }
        

            const hasDialectForms = word.dialectalForms && word.dialectalForms.length > 0;
            // Determine if this word has an evolution timeline to display.  Used for showing the evolution overview button.
            const hasEvolution = word.evolutionTimeline && word.evolutionTimeline.length > 0;

            wordDetailContent.innerHTML = contentHtml || '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°</p>';
            // Populate voice selections for any dropdowns within the word detail modal
            if (typeof updateVoiceSelects === 'function') updateVoiceSelects();
        
            // Build the action buttons for the word detail popup.  Include the evolution overview button only when evolution data exists.
            let detailButtonsHtml = '';
            detailButtonsHtml += `<button class="btn-secondary text-xs" onclick="openEtymologyTreeForWord(${word.id})"><i class="fas fa-seedling mr-1"></i> ‡∏î‡∏π‡∏ú‡∏±‡∏á‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤</button>`;
            detailButtonsHtml += `<button class="btn-secondary text-xs" onclick="openEvolutionModalForWord(${word.id})"><i class="fas fa-history mr-1"></i> ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥</button>`;
            if (hasEvolution) {
                detailButtonsHtml += `<button class="btn-secondary text-xs" onclick="showEvolutionDetailPopup(${word.id})"><i class="fas fa-stream mr-1"></i> ‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå</button>`;
            }
            detailButtonsHtml += `<button class="btn-secondary text-xs" onclick="openDialectModalForWord(${word.id})"><i class="fas fa-map-signs mr-1"></i> ${hasDialectForms ? '‡∏î‡∏π/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô' : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô'}</button>`;
            wordDetailButtons.innerHTML = detailButtonsHtml;
            
            const wordPOS = word.partOfSpeech;
            const canConjugate = currentLanguage.grammar.morphology.conjugationCategories.some(cat => cat.appliesToPOS.includes(wordPOS) || cat.appliesToPOS.some(appliedPOS => wordPOS.startsWith(appliedPOS + ":")));
            if (canConjugate) {
                const conjButton = document.createElement('button');
                conjButton.className = 'btn-secondary text-xs bg-purple-500 hover:bg-purple-600';
                conjButton.innerHTML = `<i class="fas fa-project-diagram mr-1"></i> ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ú‡∏±‡∏ô‡∏Ñ‡∏≥`;
                conjButton.onclick = () => showWordConjugationModal(word.id);
                wordDetailButtons.appendChild(conjButton);
            }
        
            wordDetailModal.classList.remove('hidden');
        };

        window.openEtymologyTreeForWord = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (word) {
                switchTab('etymology'); 
                setTimeout(() => { 
                    const searchInput = document.getElementById('etymologyWordSearch');
                    if(searchInput) {
                        searchInput.value = getOrthographicForm(word); 
                        document.getElementById('searchEtymologyBtn').click(); 
                    }
                }, 100); 
            }
            wordDetailModal.classList.add('hidden');
        };

// Modal ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥ (Evolution)
window.openEvolutionModalForWord = (wordId) => {
    genericModalTitle.textContent = '‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥';
    // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° container ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö evolution UI
    const tempDiv = document.createElement('div');
    tempDiv.id = 'evolutionModalContentContainer';
    tempDiv.className = 'max-h-[70vh] overflow-y-auto';
    // render evolution UI ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏±‡πâ‡∏ô (‡πÅ‡∏ï‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≥)
    renderEvolutionUI(tempDiv);
    genericModalContent.innerHTML = '';
    genericModalContent.appendChild(tempDiv);
    genericModalFooter.innerHTML = `<button class="btn-secondary" onclick="closeGenericModal.click()">‡∏õ‡∏¥‡∏î</button>`;
    wordDetailModal.classList.add('hidden');
    genericModal.classList.remove('hidden');
    // Autofill ‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ id ‡πÉ‡∏´‡∏°‡πà‡∏Ç‡∏≠‡∏á input)
    setTimeout(() => {
        const word = currentLanguage.lexicon.find(w => w.id === wordId);
        if (word) {
            const evoInput = document.getElementById('evoBaseWordInput');
            if (evoInput) {
                evoInput.value = word.word;
                evoInput.dispatchEvent(new Event('input'));
            }
        }
    }, 100);
};

        function autoFormatDetailedPhonetics(basePhonemicForm, phonologyData) {
            if (!basePhonemicForm || !phonologyData) return `/${basePhonemicForm || ''}/`;

            let wordToFormat = basePhonemicForm;
            if (wordToFormat.startsWith('/') && wordToFormat.endsWith('/')) {
                wordToFormat = wordToFormat.slice(1, -1);
            }
            if (wordToFormat.startsWith('[') && wordToFormat.endsWith(']')) {
                wordToFormat = wordToFormat.slice(1, -1);
            }
            wordToFormat = wordToFormat.replace(/\./g, ''); 

            const { syllableStructures, consonants, vowels, hasTones, tones } = phonologyData;
            if (!syllableStructures || syllableStructures.length === 0) return `/${wordToFormat}/`;

            let remainingWord = wordToFormat;
            let parsedSyllables = [];
            
            const toneMarkers = (hasTones && tones && tones.length > 0) ? 
                                tones.map(t => t.representation || (t.number >=0 && t.number <=9 ? ["‚Å∞","¬π","¬≤","¬≥","‚Å¥","‚Åµ","‚Å∂","‚Å∑","‚Å∏","‚Åπ"][t.number] : null))
                                     .filter(Boolean) 
                                     .sort((a,b) => b.length - a.length) 
                                     .map(tm => tm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')) 
                                     .join('|')
                                : null;
            const toneRegexSuffixGlobal = toneMarkers ? new RegExp(`(${toneMarkers})$`) : null;
            const allPhonemesSorted = [...consonants, ...vowels].sort((a, b) => b.length - a.length);


            while (remainingWord.length > 0) {
                let longestMatchThisSyllable = '';
                let matchedStructureStr = '';

                for (const struct of syllableStructures.sort((a, b) => b.length - a.length)) {
                    let currentSyllableCandidate = '';
                    let tempRemaining = remainingWord;
                    let possibleSyllable = true;

                    for (const charType of struct) { 
                        let phonemeFoundForCharType = false;
                        const inventoryToSearch = (charType === 'C' ? consonants : vowels).sort((a, b) => b.length - a.length);
                        
                        for (const phon of inventoryToSearch) {
                            if (tempRemaining.startsWith(phon)) {
                                currentSyllableCandidate += phon;
                                tempRemaining = tempRemaining.substring(phon.length);
                                phonemeFoundForCharType = true;
                                break;
                            }
                        }
                        if (!phonemeFoundForCharType) { possibleSyllable = false; break; }
                    }

                    if (possibleSyllable) {
                        let toneForThisSyllable = "";
                        if (toneRegexSuffixGlobal && tempRemaining.length > 0) {
                            const toneMatch = tempRemaining.match(new RegExp(`^(${toneMarkers})`));
                            if (toneMatch) {
                                toneForThisSyllable = toneMatch[0];
                                currentSyllableCandidate += toneForThisSyllable;
                            }
                        }
                        if (currentSyllableCandidate.length > longestMatchThisSyllable.length) {
                            longestMatchThisSyllable = currentSyllableCandidate;
                            matchedStructureStr = struct; 
                        }
                    }
                }


                if (longestMatchThisSyllable.length > 0) {
                    parsedSyllables.push(longestMatchThisSyllable);
                    remainingWord = remainingWord.substring(longestMatchThisSyllable.length);
                } else {
                    let fallbackConsumed = false;
                    for (const phon of allPhonemesSorted) {
                         if (remainingWord.startsWith(phon)) {
                            parsedSyllables.push(phon);
                            remainingWord = remainingWord.substring(phon.length);
                            fallbackConsumed = true; break;
                        }
                    }
                     if (!fallbackConsumed && toneRegexSuffixGlobal && remainingWord.length > 0) { 
                        const toneMatch = remainingWord.match(new RegExp(`^(${toneMarkers})`));
                        if (toneMatch) {
                            parsedSyllables.push(toneMatch[0]);
                            remainingWord = remainingWord.substring(toneMatch[0].length);
                            fallbackConsumed = true;
                        }
                    }
                    if (!fallbackConsumed && remainingWord.length > 0) {
                        parsedSyllables.push(remainingWord[0]); 
                        remainingWord = remainingWord.substring(1);
                    }
                }
            }
            
            if (parsedSyllables.length > 0) return `/${parsedSyllables.join('.')}/`;
            return `/${basePhonemicForm}/`; 
        }


        window.showWordModal = (wordId = null, generatedWordPhoneticForm = null, generatedPhoneticsDetail = null, generatedMeaning = null) => {
            const existingWord = wordId ? currentLanguage.lexicon.find(w => w.id === wordId) : null;
            const modalId = 'wordEditModal';
            let modal = document.getElementById(modalId);
            if (modal) modal.remove(); 

            modal = document.createElement('div');
            modal.id = modalId;
            modal.className = 'fixed inset-0 z-[70] flex items-center justify-center modal p-4'; 

            const initialWordValue = existingWord ? existingWord.word : (generatedWordPhoneticForm || '');
            const initialCustomOrthography = existingWord ? (existingWord.customOrthography || '') : ''; // Ensure it's a string
            
            let initialPhonetics;
            if (existingWord && existingWord.phonetics) { initialPhonetics = existingWord.phonetics; } 
            else if (generatedPhoneticsDetail) { initialPhonetics = generatedPhoneticsDetail; } 
            else { initialPhonetics = autoFormatDetailedPhonetics(initialWordValue, currentLanguage.phonology); }


            let initialMeaning;
            if (existingWord) { initialMeaning = existingWord.meaning; } 
            else { 
                if (generatedMeaning) initialMeaning = generatedMeaning;
                else { 
                    if (apiThaiMeaningsDatabase.length > 0) initialMeaning = apiThaiMeaningsDatabase[Math.floor(Math.random() * apiThaiMeaningsDatabase.length)];
                    else if (localThaiMeaningsDatabase.length > 0) initialMeaning = localThaiMeaningsDatabase[Math.floor(Math.random() * localThaiMeaningsDatabase.length)];
                    else initialMeaning = '';
                }
            }

            const initialPartOfSpeech = existingWord ? existingWord.partOfSpeech : (currentLanguage.grammar.partsOfSpeech[0] || '‡∏ô‡∏≤‡∏°');
            const initialGender = existingWord ? existingWord.gender : (currentLanguage.grammar.hasGender && currentLanguage.grammar.genders.length > 0 ? currentLanguage.grammar.genders[0] : '');
            const initialExample = existingWord ? existingWord.example : '';
            const initialSynonyms = existingWord && existingWord.synonyms ? existingWord.synonyms.join(', ') : '';
            const initialEtymologyNotes = existingWord && existingWord.etymology ? existingWord.etymology.notes : '';

            let posOptionsHtml = '';
            currentLanguage.grammar.partsOfSpeech.forEach(pos => {
                posOptionsHtml += `<option value="${pos}" ${pos === initialPartOfSpeech ? 'selected' : ''}>${pos}</option>`;
            });

            let genderOptionsHtml = '';
             if (currentLanguage.grammar.hasGender && currentLanguage.grammar.genders && currentLanguage.grammar.genders.length > 0) {
                currentLanguage.grammar.genders.forEach(g => {
                    genderOptionsHtml += `<option value="${g}" ${g === initialGender ? 'selected' : ''}>${g}</option>`;
                });
            }

            // Detect if logographic system is selected
            const isLogographic = currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'logographic';

            // Build options for selecting the era that this word belongs to (base era).
            let baseEraOptionsHtml = '';
            const sortedErasForModal = (currentLanguage.eras || []).slice().sort((a,b) => (a.order || 0) - (b.order || 0));
            sortedErasForModal.forEach(era => {
                let selected = false;
                if (existingWord && existingWord.baseEraId) {
                    selected = (existingWord.baseEraId === era.id);
                } else if (!existingWord && currentLanguage.evolution && currentLanguage.evolution.baseEra) {
                    // When adding a new word, use the language's configured base era as default
                    selected = (currentLanguage.evolution.baseEra === era.id);
                }
                baseEraOptionsHtml += `<option value="${era.id}" ${selected ? 'selected' : ''}>${era.name}</option>`;
            });
            let logographImage = existingWord && existingWord.logographImage ? existingWord.logographImage : '';
            modal.innerHTML = `
                <div class="modal-content p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <h3 class="text-xl font-bold mb-4">${existingWord ? '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå: ' + getOrthographicForm(existingWord) : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà'}</h3>
                    <p class="text-xs text-gray-500 mb-2">‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô) ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏Å‡∏é Active Sound Changes ‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÅ‡∏•‡πâ‡∏ß (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)</p>
                    <div class="space-y-3">
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á):</label><input type="text" id="modalWord" value="${initialWordValue}" class="w-full p-2 border rounded-md font-mono"></div>
                        <div>
                            <label class="block text-sm font-medium">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ - ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£):</label>
                            <div class="relative">
                                <input type="text" id="modalCustomOrthography" value="${initialCustomOrthography}" class="w-full p-2 border rounded-md font-mono pr-32" placeholder="‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏Å‡∏é‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥">
                                <span id="modalOrthographyPreview" class="absolute right-2 top-1/2 -translate-y-1/2 text-purple-700 font-semibold bg-white/80 px-2 rounded pointer-events-none select-none text-sm max-w-[30%] truncate" style="direction: ltr;"></span>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium">‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phonetics - ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î):</label>
                            <div class="flex items-center flex-wrap mt-1">
                                <input type="text" id="modalPhonetics" value="${initialPhonetics}" class="flex-grow p-2 border rounded-md font-mono" placeholder="/‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå1.‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå2/">
                                <button type="button" class="text-blue-500 ml-2 modal-phonetics-btn"><i class="fas fa-headphones"></i></button>
                                <span class="text-xs text-blue-500 ml-1 cursor-pointer modal-phonetics-btn">‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
                                <select id="modalPhoneticsVoiceSelect" class="voice-select ml-1 text-xs p-1 border rounded" data-selected-voice="${existingWord && existingWord.voiceId ? existingWord.voiceId : ''}"></select>
                            </div>
                        </div>
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢:</label><input type="text" id="modalMeaning" value="${initialMeaning}" class="w-full p-2 border rounded-md"></div>
                        <div>
                            <label class="block text-sm font-medium">‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥:</label>
                            <select id="modalPartOfSpeech" class="w-full p-2 border rounded-md">${posOptionsHtml}</select>
                        </div>
                        ${currentLanguage.grammar.hasGender ? `
                        <div id="modalGenderSection" class="${initialPartOfSpeech.toLowerCase().includes('‡∏ô‡∏≤‡∏°') ? '' : 'hidden'}">
                            <label class="block text-sm font-medium">‡πÄ‡∏û‡∏®:</label>
                            <select id="modalGender" class="w-full p-2 border rounded-md">${genderOptionsHtml}</select>
                        </div>` : ''}
                        <div><label class="block text-sm font-medium">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ:</label><textarea id="modalExample" class="w-full p-2 border rounded-md">${initialExample}</textarea></div>
                        <div><label class="block text-sm font-medium">‡∏Ñ‡∏≥‡πÑ‡∏ß‡∏û‡∏à‡∏ô‡πå (Synonyms - ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ):</label><input type="text" id="modalSynonyms" value="${initialSynonyms}" class="w-full p-2 border rounded-md"></div>

                        <!-- Base era selection for this word -->
                        <div>
                            <label class="block text-sm font-medium">‡∏¢‡∏∏‡∏Ñ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏ê‡∏≤‡∏ô):</label>
                            <select id="modalBaseEra" class="w-full p-2 border rounded-md text-sm">
                                ${baseEraOptionsHtml}
                            </select>
                        </div>
                        <div id="etymologySectionModal">
                            <label class="block text-sm font-medium mb-1">‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (Etymology):</label>
                            <div id="etymologyRootsContainerModal" class="space-y-2 mb-2"></div>
                            <button id="addEtymologyRootModalBtn" class="text-xs btn-secondary bg-purple-400 hover:bg-purple-500 px-2 py-1 rounded-md">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå</button>
                            <div class="mt-2"><label class="block text-sm font-medium">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤:</label><textarea id="modalEtymologyNotes" class="w-full p-2 border rounded-md">${initialEtymologyNotes}</textarea></div>
                        </div>
                        ${isLogographic ? `
                        <div id="logographImageSection" class="border rounded p-3 bg-gray-50">
                            <label class="block text-sm font-medium mb-1">‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏†‡∏≤‡∏û (Logograph):</label>
                            <div class="flex flex-col gap-2">
                                <input type="file" id="logographImageInput" accept="image/png" class="mb-2">
                                <button id="drawLogographBtn" class="btn-secondary w-fit">‡∏ß‡∏≤‡∏î‡∏†‡∏≤‡∏û‡∏Ñ‡∏≥ (Draw)</button>
                                <div id="logographImagePreviewContainer" class="mt-2">
                                    ${logographImage ? `<img id='logographImagePreview' src='${logographImage}' alt='Logograph' class='max-h-32 border rounded mb-2'>` : `<img id='logographImagePreview' src='' alt='Logograph' class='max-h-32 border rounded mb-2 hidden'>`}
                                </div>
                                <button id="clearLogographImageBtn" class="btn-secondary bg-red-400 hover:bg-red-500 text-white w-fit ${logographImage ? '' : 'hidden'}">‡∏•‡∏ö‡∏†‡∏≤‡∏û</button>
                            </div>
                        </div>
                        <div id="drawLogographModal" class="fixed inset-0 z-[80] flex items-center justify-center modal hidden p-4">
                            <div class="modal-content p-4 rounded-lg shadow-xl w-full max-w-md">
                                <h4 class="text-lg font-bold mb-2">‡∏ß‡∏≤‡∏î‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏†‡∏≤‡∏û</h4>
                                <canvas id="logographCanvas" width="256" height="256" class="border bg-white mb-2"></canvas>
                                <div class="flex gap-2 mb-2">
                                    <button id="clearCanvasBtn" class="btn-secondary">‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                                    <button id="saveCanvasBtn" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û</button>
                                    <button id="cancelCanvasBtn" class="btn-secondary">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    <div class="mt-6 flex justify-end space-x-3">
                        <button id="cancelWordModalBtn" class="btn-secondary bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded-md">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
                        <button id="saveWordModalBtn" class="btn-primary px-4 py-2 rounded-md">${existingWord ? '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á' : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå'}</button>
                    </div>
                </div>`;
            // --- Logograph image logic ---
            if (isLogographic) {
                const logographImageInput = modal.querySelector('#logographImageInput');
                const logographImagePreview = modal.querySelector('#logographImagePreview');
                const logographImagePreviewContainer = modal.querySelector('#logographImagePreviewContainer');
                const clearLogographImageBtn = modal.querySelector('#clearLogographImageBtn');
                const drawLogographBtn = modal.querySelector('#drawLogographBtn');
                const drawLogographModal = modal.querySelector('#drawLogographModal');
                const logographCanvas = modal.querySelector('#logographCanvas');
                let drawing = false;
                let ctx = null;
                if (logographCanvas) {
                    ctx = logographCanvas.getContext('2d');
                    ctx.clearRect(0, 0, logographCanvas.width, logographCanvas.height);
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = 'rgba(0,0,0,0)';
                    ctx.fillRect(0, 0, logographCanvas.width, logographCanvas.height);
                }
                // Upload image
                if (logographImageInput) {
                    logographImageInput.addEventListener('change', e => {
                        const file = e.target.files[0];
                        if (file && file.type === 'image/png') {
                            const reader = new FileReader();
                            reader.onload = function(evt) {
                                // Always draw uploaded image onto a transparent canvas, then export as PNG
                                const img = new window.Image();
                                img.onload = function() {
                                    ctx.clearRect(0, 0, logographCanvas.width, logographCanvas.height);
                                    ctx.globalAlpha = 1.0;
                                    ctx.fillStyle = 'rgba(0,0,0,0)';
                                    ctx.fillRect(0, 0, logographCanvas.width, logographCanvas.height);
                                    ctx.drawImage(img, 0, 0, logographCanvas.width, logographCanvas.height);
                                    logographImage = logographCanvas.toDataURL('image/png');
                                    logographImagePreview.src = logographImage;
                                    logographImagePreview.classList.remove('hidden');
                                    clearLogographImageBtn.classList.remove('hidden');
                                };
                                img.src = evt.target.result;
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                }
                // Draw image
                if (drawLogographBtn && drawLogographModal && logographCanvas) {
                    drawLogographBtn.addEventListener('click', () => {
                        drawLogographModal.classList.remove('hidden');
                        // Reset canvas with transparent background
                        ctx.clearRect(0, 0, logographCanvas.width, logographCanvas.height);
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = 'rgba(0,0,0,0)';
                        ctx.fillRect(0, 0, logographCanvas.width, logographCanvas.height);
                        if (logographImage) {
                            const img = new window.Image();
                            img.onload = function() {
                                ctx.drawImage(img, 0, 0, logographCanvas.width, logographCanvas.height);
                            };
                            img.src = logographImage;
                        }
                    });
                    // Drawing logic
                    let lastX = 0, lastY = 0;
                    logographCanvas.addEventListener('mousedown', e => {
                        drawing = true;
                        const rect = logographCanvas.getBoundingClientRect();
                        lastX = e.clientX - rect.left;
                        lastY = e.clientY - rect.top;
                    });
                    logographCanvas.addEventListener('mousemove', e => {
                        if (!drawing) return;
                        const rect = logographCanvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        lastX = x;
                        lastY = y;
                    });
                    logographCanvas.addEventListener('mouseup', () => { drawing = false; });
                    logographCanvas.addEventListener('mouseleave', () => { drawing = false; });
                    // Clear canvas
                    drawLogographModal.querySelector('#clearCanvasBtn').addEventListener('click', () => {
                        ctx.clearRect(0, 0, logographCanvas.width, logographCanvas.height);
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = 'rgba(0,0,0,0)';
                        ctx.fillRect(0, 0, logographCanvas.width, logographCanvas.height);
                    });
                    // Save canvas
                    drawLogographModal.querySelector('#saveCanvasBtn').addEventListener('click', () => {
                        logographImage = logographCanvas.toDataURL('image/png');
                        logographImagePreview.src = logographImage;
                        logographImagePreview.classList.remove('hidden');
                        clearLogographImageBtn.classList.remove('hidden');
                        drawLogographModal.classList.add('hidden');
                    });
                    // Cancel drawing
                    drawLogographModal.querySelector('#cancelCanvasBtn').addEventListener('click', () => {
                        drawLogographModal.classList.add('hidden');
                    });
                }
                // Clear image
                if (clearLogographImageBtn) {
                    clearLogographImageBtn.addEventListener('click', () => {
                        logographImage = '';
                        logographImagePreview.src = '';
                        logographImagePreview.classList.add('hidden');
                        clearLogographImageBtn.classList.add('hidden');
                    });
                }
            }
            document.body.appendChild(modal);
            // After inserting the modal into the DOM, populate the voice selection drop-downs so users can choose accents
            if (typeof updateVoiceSelects === 'function') updateVoiceSelects();

            const modalWordInput = modal.querySelector('#modalWord');
            const modalPhoneticsInput = modal.querySelector('#modalPhonetics');
            const modalCustomOrthographyInput = modal.querySelector('#modalCustomOrthography');
            const modalOrthographyPreview = modal.querySelector('#modalOrthographyPreview');

            // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ
            function updateOrthographyPreview() {
                if (currentLanguage.orthography && currentLanguage.orthography.writingSystem === 'custom') {
                    // ‡πÅ‡∏™‡∏î‡∏á preview ‡πÄ‡∏õ‡πá‡∏ô HTML (image/symbol) ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
                    const basePhonemic = modalWordInput.value;
                    const html = transliterateWordToSymbols(basePhonemic, true, true, true);
                    modalOrthographyPreview.innerHTML = html;
                    modalOrthographyPreview.title = basePhonemic;
                    modalOrthographyPreview.style.display = html ? '' : 'none';
                    return;
                }
                const custom = modalCustomOrthographyInput.value.trim();
                let preview = '';
                if (custom) {
                    preview = custom;
                } else {
                    // ‡πÉ‡∏ä‡πâ‡∏Å‡∏é‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á)
                    const basePhonemic = modalWordInput.value;
                    preview = getOrthographicForm({ word: basePhonemic, customOrthography: '' }, true, false);
                }
                modalOrthographyPreview.textContent = preview;
                modalOrthographyPreview.title = preview;
                modalOrthographyPreview.style.display = '';
            }
            updateOrthographyPreview();
            modalCustomOrthographyInput.addEventListener('input', updateOrthographyPreview);
            modalWordInput.addEventListener('input', updateOrthographyPreview);

            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï phonetics ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á
            const updateDerivedForms = () => {
                const basePhonemic = modalWordInput.value;
                modalPhoneticsInput.value = autoFormatDetailedPhonetics(basePhonemic, currentLanguage.phonology);
                updateOrthographyPreview();
            };
            modalWordInput.addEventListener('change', updateDerivedForms);


            const modalPosSelect = modal.querySelector('#modalPartOfSpeech');
            const modalGenderSection = modal.querySelector('#modalGenderSection');
            if (modalPosSelect && modalGenderSection) {
                modalPosSelect.onchange = (e) => {
                    modalGenderSection.classList.toggle('hidden', !e.target.value.toLowerCase().includes('‡∏ô‡∏≤‡∏°'));
                };
            }

            const etymologyRootsContainerModal = modal.querySelector('#etymologyRootsContainerModal');
            let tempEtymologyRoots = existingWord && existingWord.etymology && existingWord.etymology.roots ? JSON.parse(JSON.stringify(existingWord.etymology.roots)) : [];

            const renderEtymologyRootsModal = () => {
                etymologyRootsContainerModal.innerHTML = '';
                const wordOptionsForRootDatalistId = `wordRootDatalist_${Date.now()}`;
                let datalistOptions = '';
                currentLanguage.lexicon.forEach(w => { 
                     if (!existingWord || w.id !== existingWord.id) {
                         let ortho = getOrthographicForm(w, false, false);
                         let base = w.word;
                         datalistOptions += `<option value="${ortho}" data-id="${w.id}">${ortho} (${base})</option>`;
                     }
                });
                etymologyRootsContainerModal.innerHTML += `<datalist id="${wordOptionsForRootDatalistId}">${datalistOptions}</datalist>`;


                tempEtymologyRoots.forEach((root, index) => {
                    const rootDiv = document.createElement('div');
                    rootDiv.className = 'flex items-center gap-2 p-2 border rounded bg-purple-50 flex-wrap sm:flex-nowrap';

                    const wordInput = document.createElement('input');
                    wordInput.type = 'text';
                    wordInput.setAttribute('list', wordOptionsForRootDatalistId);
                    wordInput.placeholder = '-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥ / ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏£‡∏≤‡∏Å‡πÄ‡∏≠‡∏á (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á) --';
                    wordInput.className = 'p-1 border rounded text-sm flex-grow modal-etymology-root-word w-full sm:w-auto mb-1 sm:mb-0 font-mono';
                    if(root.wordId){
                        const parentWord = currentLanguage.lexicon.find(w => w.id === root.wordId);
                        if(parentWord) wordInput.value = parentWord.word; 
                    } else if (root.customRoot) {
                        wordInput.value = root.customRoot;
                    }

                    const sourceLangInput = document.createElement('input');
                    sourceLangInput.type = 'text';
                    sourceLangInput.placeholder = '‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á)';
                    sourceLangInput.className = `p-1 border rounded text-sm modal-etymology-source-lang w-full sm:w-auto mb-1 sm:mb-0 ${root.wordId ? 'hidden': ''}`;
                    sourceLangInput.value = root.sourceLang || '';

                    wordInput.onchange = (e) => { 
                        const selectedOpt = Array.from(document.getElementById(wordOptionsForRootDatalistId).options).find(opt => opt.value === e.target.value);
                        if (selectedOpt) {
                            tempEtymologyRoots[index].wordId = parseInt(selectedOpt.dataset.id);
                            tempEtymologyRoots[index].customRoot = ''; 
                            tempEtymologyRoots[index].sourceLang = '';
                            sourceLangInput.classList.add('hidden');
                            sourceLangInput.value = '';
                        } else { 
                            tempEtymologyRoots[index].wordId = null;
                            tempEtymologyRoots[index].customRoot = e.target.value; 
                            sourceLangInput.classList.remove('hidden');
                        }
                    };
                    sourceLangInput.oninput = (e) => { if(tempEtymologyRoots[index]) tempEtymologyRoots[index].sourceLang = e.target.value; };

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '‡∏•‡∏ö';
                   removeBtn.className = 'text-xs bg-red-400 hover:bg-red-500 text-white px-2 py-1 rounded h-fit';
                    removeBtn.onclick = () => { tempEtymologyRoots.splice(index,1); renderEtymologyRootsModal(); };

                    rootDiv.appendChild(wordInput);
                    rootDiv.appendChild(sourceLangInput);
                    rootDiv.appendChild(removeBtn);
                    etymologyRootsContainerModal.appendChild(rootDiv);
                });
            };
            renderEtymologyRootsModal();

            modal.querySelector('#addEtymologyRootModalBtn').onclick = () => {
                tempEtymologyRoots.push({ wordId: null, customRoot: '', sourceLang: '' });
                renderEtymologyRootsModal();
            };

            modal.querySelector('#cancelWordModalBtn').onclick = () => modal.remove();
            modal.querySelector('#saveWordModalBtn').onclick = () => {
                    const updatedWord = {
                        id: existingWord ? existingWord.id : nextWordId,
                        word: modal.querySelector('#modalWord').value.trim(),
                        customOrthography: modal.querySelector('#modalCustomOrthography').value.trim() || null, // Set to null if empty
                        phonetics: modal.querySelector('#modalPhonetics').value.trim(),
                        meaning: modal.querySelector('#modalMeaning').value.trim(),
                        partOfSpeech: modal.querySelector('#modalPartOfSpeech').value,
                        gender: currentLanguage.grammar.hasGender && modal.querySelector('#modalGenderSection') && !modal.querySelector('#modalGenderSection').classList.contains('hidden') ? modal.querySelector('#modalGender').value : '',
                        example: modal.querySelector('#modalExample').value.trim(),
                        synonyms: modal.querySelector('#modalSynonyms').value.split(',').map(s => s.trim()).filter(s => s),
                        // store the selected voice (accent) for this word. If the user did not select a voice, null or default will be stored.
                        voiceId: (modal.querySelector('#modalPhoneticsVoiceSelect') && modal.querySelector('#modalPhoneticsVoiceSelect').value) ? modal.querySelector('#modalPhoneticsVoiceSelect').value : null,
                        etymology: {
                            roots: tempEtymologyRoots.filter(r => r.wordId || (r.customRoot && r.customRoot.trim() !== '')),
                            notes: modal.querySelector('#modalEtymologyNotes').value.trim()
                        },
                        // Persist the base era selected by the user. Use null if no selection exists.
                        baseEraId: (modal.querySelector('#modalBaseEra') && modal.querySelector('#modalBaseEra').value) ? modal.querySelector('#modalBaseEra').value : null,
                        evolutionTimeline: (existingWord && existingWord.evolutionTimeline) ? existingWord.evolutionTimeline : [],
                        dialectalForms: (existingWord && existingWord.dialectalForms) ? existingWord.dialectalForms : [],
                        ...(isLogographic ? { logographImage: logographImage || '' } : {})
                    };

                if (!updatedWord.word || !updatedWord.meaning || !updatedWord.partOfSpeech) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á), ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢, ‡πÅ‡∏•‡∏∞‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥'); return;
                }

                if (existingWord) {
                    const index = currentLanguage.lexicon.findIndex(w => w.id === wordId);
                    currentLanguage.lexicon[index] = updatedWord;
                } else {
                    currentLanguage.lexicon.push(updatedWord);
                    nextWordId = calculateNextWordId(currentLanguage.lexicon); 
                }
                // Immediately update the UI to show the edited/added word
                modal.remove();
                // Ensure tabContentContainer is up-to-date
                let container = tabContentContainer;
                if (!container || !document.body.contains(container)) {
                    container = document.getElementById('tabContentContainer') || document.querySelector('.tab-content') || document.body;
                }
                if (activeTab === 'dictionary') {
                    renderDictionaryUI(container);
                } else if (activeTab === 'etymology') {
                    renderEtymologyUI(container);
                }
                saveData();
            };
        };

        window.deleteWordFromDictionary = (wordId) => {
            if (confirm('‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ? ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ‡∏≠‡∏≤‡∏à‡∏™‡πà‡∏á‡∏ú‡∏•‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏≠‡∏∑‡πà‡∏ô')) {
                currentLanguage.lexicon = currentLanguage.lexicon.filter(w => w.id !== wordId);
                currentLanguage.lexicon.forEach(word => { 
                    if (word.etymology && word.etymology.roots) {
                        word.etymology.roots = word.etymology.roots.filter(root => root.wordId !== wordId);
                    }
                });
                nextWordId = calculateNextWordId(currentLanguage.lexicon); 
                if (activeTab === 'dictionary') renderDictionaryUI(tabContentContainer);
                else if (activeTab === 'etymology') renderEtymologyUI(tabContentContainer); 
                saveData();
            }
        };

        function exportDictionaryAsJSON() {
            const jsonData = JSON.stringify(currentLanguage.lexicon, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `${currentLanguage.name}_dictionary.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function exportDictionaryAsCSV() {
            if (!currentLanguage.lexicon || currentLanguage.lexicon.length === 0) { alert("‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤"); return; }
            const headers = ['ID', 'Word(BasePhonemic)', 'Word(Orthographic)', 'CustomOrthography', 'Phonetics(Detailed)', 'Meaning', 'PartOfSpeech', 'Gender', 'Example', 'Synonyms', 'EtymologyRoots', 'EtymologyNotes'];
            const rows = currentLanguage.lexicon.map(entry => [
                entry.id, entry.word, getOrthographicForm(entry, false), entry.customOrthography || '', entry.phonetics, entry.meaning,
                entry.partOfSpeech, entry.gender || '', entry.example,
                entry.synonyms ? entry.synonyms.join(';') : '', 
                entry.etymology && entry.etymology.roots ? entry.etymology.roots.map(r => r.wordId ? `id:${r.wordId}` : `${r.customRoot}(${r.sourceLang})`).join(' | ') : '',
                entry.etymology ? entry.etymology.notes : ''
            ]);
            let csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n"
                           + rows.map(e => e.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(",")).join("\n"); 
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri); link.setAttribute("download", `${currentLanguage.name}_dictionary.csv`);
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        }

        function renderOrthographyUI(container) {
            const ortho = currentLanguage.orthography;
            ortho.customSymbols = ortho.customSymbols || [];
            ortho.displayTonesInOrthography = ortho.displayTonesInOrthography === undefined ? true : ortho.displayTonesInOrthography;

            // ...existing code...
        // ...existing code...
            // --- ‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ô modal ‡∏™‡∏£‡πâ‡∏≤‡∏á/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå ---
            // ‡πÄ‡∏û‡∏¥‡πà‡∏° dropdown ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå)
            if (currentLanguage.phonology.hasTones) {
                // ‡πÅ‡∏¢‡∏Å‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå‡∏à‡∏≤‡∏Å modalWordInput ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏£‡πâ‡∏≤‡∏á dropdown ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå
                const wordInputDiv = modal.querySelector('#modalWord').parentElement;
                const toneDropdownDiv = document.createElement('div');
                toneDropdownDiv.className = 'flex flex-wrap gap-2 mt-1';
                toneDropdownDiv.id = 'toneDropdownsContainer';
                wordInputDiv.appendChild(toneDropdownDiv);

                function getSyllables() {
                    return modalWordInput.value.trim().split(/\.|\s+/).filter(Boolean);
                }
                function renderToneDropdowns() {
                    const syllables = getSyllables();
                    toneDropdownDiv.innerHTML = '';
                    if (!modal._syllableTones || modal._syllableTones.length !== syllables.length) {
                        modal._syllableTones = Array(syllables.length).fill(0);
                    }
                    syllables.forEach((syll, idx) => {
                        const sel = document.createElement('select');
                        sel.className = 'p-1 border rounded text-xs';
                        currentLanguage.phonology.tones.forEach(tone => {
                            sel.innerHTML += `<option value="${tone.number}" ${modal._syllableTones[idx]===tone.number?'selected':''}>${tone.name}${tone.number!==0?(' ('+(tone.representation||tone.display||tone.number)+')'):''}</option>`;
                        });
                        sel.onchange = (e) => {
                            modal._syllableTones[idx] = parseInt(e.target.value);
                            updateWordToneDisplay();
                        };
                        // ‡πÉ‡∏™‡πà label ‡∏û‡∏¢‡∏≤‡∏á‡∏Ñ‡πå + dropdown
                        const label = document.createElement('span');
                        label.className = 'font-mono';
                        label.textContent = syll;
                        toneDropdownDiv.appendChild(label);
                        toneDropdownDiv.appendChild(sel);
                    });
                }

                function updateWordToneDisplay() {
                    // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô preview (‡πÄ‡∏ä‡πà‡∏ô co¬≤laneto‚Å¥) ‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏•‡∏Ç‡∏¢‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
                    const syllables = getSyllables();
                    let display = '';
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å checkbox ‡πÉ‡∏ô orthography (displayTonesInOrthography)
                    let showTone = true;
                    const ortho = currentLanguage.orthography;
                    if (typeof ortho.displayTonesInOrthography !== 'undefined') {
                        showTone = ortho.displayTonesInOrthography;
                    }
                    syllables.forEach((syll, idx) => {
                        const toneNum = (modal._syllableTones||[])[idx]||0;
                        const toneObj = currentLanguage.phonology.tones.find(t=>t.number===toneNum);
                        display += syll;
                        if (showTone && toneObj && toneObj.number!==0) {
                            display += `<sup>${toneObj.representation||toneObj.display||toneObj.number}</sup>`;
                        }
                    });
                    // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÄ‡∏õ‡πá‡∏ô HTML (superscript)
                    let previewDiv = modal.querySelector('#modalWordTonePreview');
                    if (!previewDiv) {
                        previewDiv = document.createElement('div');
                        previewDiv.id = 'modalWordTonePreview';
                        previewDiv.className = 'text-purple-700 font-mono text-lg mt-1';
                        modalWordInput.parentElement.appendChild(previewDiv);
                    }
                    previewDiv.innerHTML = display;
                }

                modalWordInput.addEventListener('input', () => {
                    renderToneDropdowns();
                    updateWordToneDisplay();
                });
                renderToneDropdowns();
                updateWordToneDisplay();
                // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ‡πÉ‡∏´‡πâ‡∏£‡∏ß‡∏°‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÄ‡∏Ç‡πâ‡∏≤ word
                const saveBtn = modal.querySelector('#saveWordModalBtn');
                const origSaveHandler = saveBtn.onclick;
                saveBtn.onclick = () => {
                    // ‡∏£‡∏ß‡∏°‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÄ‡∏Ç‡πâ‡∏≤ word ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ
                    const syllables = getSyllables();
                    let wordWithTone = '';
                    let showTone = true;
                    const ortho = currentLanguage.orthography;
                    if (typeof ortho.displayTonesInOrthography !== 'undefined') {
                        showTone = ortho.displayTonesInOrthography;
                    }
                    syllables.forEach((syll, idx) => {
                        const toneNum = (modal._syllableTones||[])[idx]||0;
                        const toneObj = currentLanguage.phonology.tones.find(t=>t.number===toneNum);
                        wordWithTone += syll;
                        if (showTone && toneObj && toneObj.number!==0) {
                            wordWithTone += (toneObj.representation||toneObj.display||toneObj.number);
                        }
                    });
                    modalWordInput.value = wordWithTone;
                    if (typeof origSaveHandler === 'function') origSaveHandler();
                };
            }


            const orthographyContainerId = 'orthographyTabSpecificContent';
            let orthographyContainer = container.querySelector(`#${orthographyContainerId}`);
            if(!orthographyContainer){
                orthographyContainer = document.createElement('div');
                orthographyContainer.id = orthographyContainerId;
                container.appendChild(orthographyContainer);
            }
            orthographyContainer.innerHTML = '';


            const section = document.createElement('div');
            section.className = 'space-y-4 p-3 border border-indigo-200 rounded-md bg-indigo-50';
            const soundDatalistId = 'phonemeSuggestionsDatalistOrtho';
            let soundOptionsHtml = [...new Set([...currentLanguage.phonology.consonants, ...currentLanguage.phonology.vowels])].map(p => `<option value="${p}"></option>`).join('');

            section.innerHTML = `<datalist id="${soundDatalistId}">${soundOptionsHtml}</datalist>`;
  createSelectInput(section, '‚úíÔ∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Writing System):', 'writingSystemSelectOrtho', ortho.writingSystem,
                [
                    {value: 'latin', text: '‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏•‡∏∞‡∏ï‡∏¥‡∏ô (A-Z) (‡∏≠‡∏≤‡∏à‡πÉ‡∏ä‡πâ Grapheme Mappings ‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á)'},
                    {value: 'custom', text: '‡πÉ‡∏ä‡πâ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á (Custom Symbols)'},
                    {value: 'logographic', text: '‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏†‡∏≤‡∏û (logographic)'}
                ]
            ).onchange = (e) => {
                ortho.writingSystem = e.target.value;
                renderOrthographyUI(container); 
                saveData();
            };
            
            if (currentLanguage.phonology.hasTones) {
                 createCheckboxInput(section, '‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏π‡∏õ‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ (Display Tones in Orthography)', 'displayTonesCheckboxOrtho', ortho.displayTonesInOrthography, 
                 '‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå ‡πÅ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á', 
                 (e) => {
                    ortho.displayTonesInOrthography = e.target.checked;
                    saveData();
                 });
            }


            const customSymbolsSection = document.createElement('div');
            customSymbolsSection.id = 'customSymbolsSectionOrtho';
            customSymbolsSection.className = `${ortho.writingSystem === 'custom' ? '' : 'hidden'}`; 
            const helpTextForCustomSymbols = ortho.writingSystem === 'custom' 
                ? '‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏≠‡∏á' 
                : '‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡∏∞‡∏ï‡∏¥‡∏ô ‡πÇ‡∏î‡∏¢‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏à‡∏∞‡πÉ‡∏ä‡πâ Grapheme Mappings ‡∏à‡∏≤‡∏Å‡πÅ‡∏ó‡πá‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏•‡∏∞‡∏ï‡∏¥‡∏ô‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô';

            const customSymbolListContainer = document.createElement('div'); 
            customSymbolListContainer.id = 'customSymbolListOrtho';
            customSymbolListContainer.className = 'space-y-2 mb-2 max-h-60 overflow-y-auto p-2 bg-white rounded border';

            const addSymbolForm = `
                <label class="block text-sm font-medium text-indigo-700 mb-1">‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á (Custom Symbols):</label>
                <p class="text-xs text-gray-500 mb-1">${helpTextForCustomSymbols}</p>
                ${customSymbolListContainer.outerHTML} 
                <div class="flex gap-2 items-center flex-wrap p-2 border rounded bg-indigo-100">
                    <input type="text" id="customSymbolSoundOrtho" list="${soundDatalistId}" placeholder="‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏ä‡πà‡∏ô k, sh, a)" class="p-1 border rounded-md text-sm flex-grow sm:flex-grow-0">
                    <input type="text" id="customSymbolCharOrtho" placeholder="‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå (‡πÄ‡∏ä‡πà‡∏ô ‚ö∂, ‚ú∂)" class="p-1 border rounded-md text-sm flex-grow sm:flex-grow-0">
                    <button id="drawCustomSymbolBtnOrthoNew" class="btn-secondary bg-indigo-500 hover:bg-indigo-600 px-2 py-1 rounded-md text-xs"><i class="fas fa-pen"></i> ‡∏ß‡∏≤‡∏î</button>
                    <label class="btn-secondary bg-indigo-400 hover:bg-indigo-500 px-2 py-1 rounded-md text-xs cursor-pointer m-0">
                        <input type="file" id="uploadCustomSymbolPngOrthoNew" accept="image/png" style="display:none;">
                        <i class="fas fa-upload"></i> ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PNG
                    </label>
                    <span id="customSymbolPreviewOrthoNew" class="ml-2"></span>
                    <button id="addCustomSymbolBtnOrtho" class="btn-secondary bg-indigo-400 hover:bg-indigo-500 px-2 py-1 rounded-md text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå</button>
                </div>
                <!-- Modal ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÉ‡∏´‡∏°‡πà -->
                <div id="drawCustomSymbolModalOrthoNew" style="display:none;position:fixed;z-index:9999;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.3);align-items:center;justify-content:center;">
                  <div style="background:#fff;padding:20px;border-radius:8px;min-width:320px;max-width:90vw;">
                    <h4 class="mb-2">‡∏ß‡∏≤‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå</h4>
                    <canvas id="drawCustomSymbolCanvasOrthoNew" width="96" height="96" style="border:1px solid #ccc;background:transparent;"></canvas><br>
                    <button id="clearDrawCustomSymbolBtnOrthoNew" class="btn-secondary text-xs">‡∏•‡πâ‡∏≤‡∏á</button>
                    <button id="saveDrawCustomSymbolBtnOrthoNew" class="btn-primary text-xs">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
                    <button id="closeDrawCustomSymbolBtnOrthoNew" class="btn-danger text-xs">‡∏õ‡∏¥‡∏î</button>
                  </div>
                </div>
            `;
            // --- Logic: ‡∏ß‡∏≤‡∏î/‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PNG ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏° custom symbol ‡πÉ‡∏´‡∏°‡πà ---
            let drawnCustomSymbolDataUrlNew = null;
            customSymbolsSection.innerHTML = addSymbolForm;
            section.appendChild(customSymbolsSection);
            // ‡∏ß‡∏≤‡∏î
            const drawBtnNew = section.querySelector('#drawCustomSymbolBtnOrthoNew');
            if (drawBtnNew) {
                drawBtnNew.onclick = () => {
                    const modal = document.getElementById('drawCustomSymbolModalOrthoNew');
                    modal.style.display = 'flex';
                    let drawing = false;
                    const canvas = document.getElementById('drawCustomSymbolCanvasOrthoNew');
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = 'rgba(0,0,0,0)';
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    canvas.onmousedown = (e) => { drawing = true; ctx.beginPath(); ctx.moveTo(e.offsetX, e.offsetY); };
                    canvas.onmouseup = () => { drawing = false; };
                    canvas.onmouseleave = () => { drawing = false; };
                    canvas.onmousemove = (e) => {
                        if (!drawing) return;
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.strokeStyle = '#222';
                        ctx.lineTo(e.offsetX, e.offsetY);
                        ctx.stroke();
                    };
                    document.getElementById('clearDrawCustomSymbolBtnOrthoNew').onclick = () => {
                        ctx.clearRect(0,0,canvas.width,canvas.height);
                    };
                    document.getElementById('saveDrawCustomSymbolBtnOrthoNew').onclick = () => {
                        drawnCustomSymbolDataUrlNew = canvas.toDataURL('image/png');
                        // Show preview
                        const preview = section.querySelector('#customSymbolPreviewOrthoNew');
                        preview.innerHTML = `<img src='${drawnCustomSymbolDataUrlNew}' alt='drawn' style='height:32px;vertical-align:middle;background:transparent'/>`;
                        modal.style.display = 'none';
                    };
                    document.getElementById('closeDrawCustomSymbolBtnOrthoNew').onclick = () => {
                        modal.style.display = 'none';
                    };
                };
            }
            // ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PNG
            const uploadInputNew = section.querySelector('#uploadCustomSymbolPngOrthoNew');
            if (uploadInputNew) {
                uploadInputNew.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        drawnCustomSymbolDataUrlNew = e.target.result;
                        // Show preview
                        const preview = section.querySelector('#customSymbolPreviewOrthoNew');
                        preview.innerHTML = `<img src='${drawnCustomSymbolDataUrlNew}' alt='uploaded' style='height:32px;vertical-align:middle;background:transparent'/>`;
                    };
                    reader.readAsDataURL(file);
                    event.target.value = null;
                };
            }

            const renderCustomSymbolsListLocal = () => {

                const listEl = section.querySelector('#customSymbolListOrtho');
                if (!listEl) return;
                listEl.innerHTML = '';
                (ortho.customSymbols || []).forEach((sym, index) => {
                    let imgHtml = sym.imageData ? `<img src='${sym.imageData}' alt='img' style='height:32px;vertical-align:middle;background:transparent'/>` : '';
                    listEl.innerHTML += `
                        <div class="flex items-center gap-2 p-1 bg-white rounded border border-indigo-100 text-sm">
                            <span>‡πÄ‡∏™‡∏µ‡∏¢‡∏á '<span class="font-mono">${sym.sound}</span>' <i class="fas fa-arrow-right mx-1"></i> ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå '<span class="font-mono">${sym.symbol}</span>'</span>
                            <button class="btn-secondary text-xs" onclick="window.openDrawSymbolModalOrtho(${index})">‡∏ß‡∏≤‡∏î</button>
                            <label class="btn-secondary text-xs cursor-pointer m-0">‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PNG
                                <input type="file" accept="image/png" style="display:none" onchange="window.uploadCustomSymbolImageOrtho(event, ${index})">
                            </label>
                            <span class="ml-2">${imgHtml}</span>
                            <button class="text-xs text-red-500 hover:text-red-700" onclick="removeCustomSymbol(${index})">&times; ‡∏•‡∏ö</button>
                        </div>`;
                });
                if (!ortho.customSymbols || ortho.customSymbols.length === 0) {
                    listEl.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á</p>';
                }
            };

            // Modal ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏≤‡∏î‡∏†‡∏≤‡∏û (canvas)
            if (!document.getElementById('drawSymbolModalOrtho')) {
                const modal = document.createElement('div');
                modal.id = 'drawSymbolModalOrtho';
                modal.style = 'display:none;position:fixed;z-index:9999;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.3);align-items:center;justify-content:center;';
                modal.innerHTML = `
                  <div style="background:#fff;padding:20px;border-radius:8px;min-width:320px;max-width:90vw;">
                    <h4 class="mb-2">‡∏ß‡∏≤‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå</h4>
                    <canvas id="drawSymbolCanvasOrtho" width="96" height="96" style="border:1px solid #ccc;background:transparent;"></canvas><br>
                    <button id="clearDrawSymbolBtnOrtho" class="btn-secondary text-xs">‡∏•‡πâ‡∏≤‡∏á</button>
                    <button id="saveDrawSymbolBtnOrtho" class="btn-primary text-xs">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
                    <button id="closeDrawSymbolBtnOrtho" class="btn-danger text-xs">‡∏õ‡∏¥‡∏î</button>
                  </div>
                `;
                document.body.appendChild(modal);
            }

            // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î modal ‡∏ß‡∏≤‡∏î
            window.openDrawSymbolModalOrtho = (idx) => {
                const modal = document.getElementById('drawSymbolModalOrtho');
                modal.style.display = 'flex';
                let drawing = false;
                const canvas = document.getElementById('drawSymbolCanvasOrtho');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,canvas.width,canvas.height);
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = 'rgba(0,0,0,0)';
                ctx.fillRect(0,0,canvas.width,canvas.height);
                // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏¥‡∏°
                if (ortho.customSymbols[idx].imageData) {
                    const img = new window.Image();
                    img.onload = () => ctx.drawImage(img,0,0,canvas.width,canvas.height);
                    img.src = ortho.customSymbols[idx].imageData;
                }
                canvas.onmousedown = (e) => { drawing = true; ctx.beginPath(); ctx.moveTo(e.offsetX, e.offsetY); };
                canvas.onmouseup = () => { drawing = false; };
                canvas.onmouseleave = () => { drawing = false; };
                canvas.onmousemove = (e) => {
                    if (!drawing) return;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#222';
                    ctx.lineTo(e.offsetX, e.offsetY);
                    ctx.stroke();
                };
                document.getElementById('clearDrawSymbolBtnOrtho').onclick = () => {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                };
                document.getElementById('saveDrawSymbolBtnOrtho').onclick = () => {
                    ortho.customSymbols[idx].imageData = canvas.toDataURL('image/png');
                    saveData();
                    renderCustomSymbolsListLocal();
                    modal.style.display = 'none';
                };
                document.getElementById('closeDrawSymbolBtnOrtho').onclick = () => {
                    modal.style.display = 'none';
                };
            };

            // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PNG
            window.uploadCustomSymbolImageOrtho = (event, idx) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(e) {
                    ortho.customSymbols[idx].imageData = e.target.result;
                    saveData();
                    renderCustomSymbolsListLocal();
                };
                reader.readAsDataURL(file);
                event.target.value = null;
            };

            renderCustomSymbolsListLocal(); 
            const addBtn = section.querySelector('#addCustomSymbolBtnOrtho');
            if (addBtn) { 
                addBtn.onclick = () => {
                    const soundInput = section.querySelector('#customSymbolSoundOrtho');
                    const symbolInput = section.querySelector('#customSymbolCharOrtho');
                    const sound = soundInput.value.trim();
                    const symbol = symbolInput.value.trim(); // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏î‡πâ
                    let imageData = drawnCustomSymbolDataUrlNew || null;
                    if (sound) {
                        if (ortho.customSymbols.some(s => s.sound === sound)) { 
                            alert(`‡πÄ‡∏™‡∏µ‡∏¢‡∏á '${sound}' ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô`);
                            return;
                        }
                        ortho.customSymbols.push({ sound, symbol, imageData });
                        soundInput.value = '';
                        symbolInput.value = '';
                        drawnCustomSymbolDataUrlNew = null;
                        const preview = section.querySelector('#customSymbolPreviewOrthoNew');
                        if (preview) preview.innerHTML = '';
                        renderCustomSymbolsListLocal(); 
                        saveData();
                    }
                };
            }
            

            createSelectInput(section, '‚ÜîÔ∏è ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Writing Direction):', 'writingDirectionSelectOrtho', ortho.direction,
                [{value: 'ltr', text: '‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏Ç‡∏ß‡∏≤'}, {value: 'rtl', text: '‡∏Ç‡∏ß‡∏≤‡πÑ‡∏õ‡∏ã‡πâ‡∏≤‡∏¢'}, {value: 'ttb', text: '‡∏ö‡∏ô‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á'}]
            ).onchange = (e) => { ortho.direction = e.target.value; saveData(); };

            const translitDemoSection = document.createElement('div');
            translitDemoSection.innerHTML = `
                <label class="block text-sm font-medium text-indigo-700">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏±‡∏Å‡∏©‡∏£:</label>
                <input type="text" id="orthoTestWord" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á (‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á)" class="w-full p-2 border border-indigo-300 rounded-md mb-1 font-mono">
                <button id="transliterateBtnOrtho" class="btn-primary bg-indigo-500 hover:bg-indigo-600 px-3 py-1 rounded-md text-sm">‡πÅ‡∏õ‡∏•‡∏á</button>
                <p id="transliteratedOutputOrtho" class="mt-2 p-2 bg-white rounded border border-indigo-200 text-lg min-h-[2.5em] font-mono"></p>`;
            section.appendChild(translitDemoSection);

            const transliterateBtn = section.querySelector('#transliterateBtnOrtho');
            if (transliterateBtn) { 
                 transliterateBtn.onclick = () => {
                    const word = section.querySelector('#orthoTestWord').value.trim(); 
                    const outputP = section.querySelector('#transliteratedOutputOrtho');
                    if (!word) { outputP.textContent = '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥'; return; }
                    outputP.textContent = transliterateWordToSymbols(word);
                    outputP.style.direction = (ortho.direction === 'rtl' ? 'rtl' : 'ltr');
                    outputP.style.writingMode = (ortho.direction === 'ttb' ? 'vertical-rl' : 'horizontal-tb');
                };
            }
            orthographyContainer.appendChild(section);
        }

        window.removeCustomSymbol = (index) => {
            currentLanguage.orthography.customSymbols.splice(index, 1);
            const listEl = document.getElementById('customSymbolListOrtho'); 
            if (listEl) { 
                listEl.innerHTML = ''; 
                (currentLanguage.orthography.customSymbols || []).forEach((sym, idx) => {
                    listEl.innerHTML += `<div class="flex items-center justify-between p-1 bg-white rounded border border-indigo-100 text-sm">
                        <span>‡πÄ‡∏™‡∏µ‡∏¢‡∏á '${sym.sound}' <i class="fas fa-arrow-right mx-1"></i> ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå '${sym.symbol}'</span>
                        <button class="text-xs text-red-500 hover:text-red-700" onclick="removeCustomSymbol(${idx})">&times; ‡∏•‡∏ö</button></div>`;
                });
                 if (currentLanguage.orthography.customSymbols.length === 0 && listEl) { 
                    listEl.innerHTML = '<p class="text-xs text-gray-400 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á</p>';
                }
            }
            saveData();
        };

        function renderEtymologyUI(container) {
            const etymologyContainerId = 'etymologyTabSpecificContent';
            let etymologyContainer = container.querySelector(`#${etymologyContainerId}`);
            if(!etymologyContainer){
                etymologyContainer = document.createElement('div');
                etymologyContainer.id = etymologyContainerId;
                container.appendChild(etymologyContainer);
            }
            etymologyContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-teal-200 rounded-md bg-teal-50 space-y-4';
            const etymologyDatalistId = `dictionaryWordsForEtymologyDatalist_${Date.now()}`;
            let datalistOptions = '';

            (currentLanguage.lexicon || []).forEach(w => {
                // Show orthography (plain text, not HTML) and base form in parentheses
                let ortho = getOrthographicForm(w, false, false); // always plain text for datalist
                let base = w.word;
                datalistOptions += `<option value="${ortho}" data-baseform="${base}">${ortho} (${base})</option>`;
            });

            section.innerHTML = `
                <datalist id="${etymologyDatalistId}">${datalistOptions}</datalist>
                <div>
                    <label for="etymologyWordSearch" class="block text-sm font-medium text-teal-700">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏û‡∏¥‡∏°‡∏û‡πå‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏π‡∏õ‡∏ê‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á):</label>
                    <div class="flex gap-2">
                        <input type="text" id="etymologyWordSearch" list="${etymologyDatalistId}" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥..." class="flex-grow p-2 border border-teal-300 rounded-md">
                        <button id="searchEtymologyBtn" class="btn-primary bg-teal-500 hover:bg-teal-600 px-3 py-1 rounded-md text-sm">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</button>
                    </div>
                </div>
                <div id="etymologyResults" class="p-3 bg-white rounded-md shadow min-h-[100px]">
                    <p class="text-center text-gray-400">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
                </div>
                <h4 class="font-semibold text-teal-700 pt-2 border-t border-teal-200">‡∏ú‡∏±‡∏á‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (Etymology Tree):</h4>
                <div id="wordEtymologyTreeChart" class="pedigree-chart p-2 bg-white rounded-md shadow min-h-[150px] max-h-[500px] overflow-auto">
                    <p class="text-center text-gray-400">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ú‡∏±‡∏á</p>
                </div>
            `;
            etymologyContainer.appendChild(section);

            const wordSearchInput = section.querySelector('#etymologyWordSearch');
            const searchBtn = section.querySelector('#searchEtymologyBtn');

            const performSearch = () => {
                const searchTerm = wordSearchInput.value.trim();
                let wordEntry;
                const selectedOpt = Array.from(section.querySelector(`#${etymologyDatalistId}`).options).find(opt => opt.value === searchTerm);
                if (selectedOpt && selectedOpt.dataset.baseform) {
                     wordEntry = (currentLanguage.lexicon || []).find(w => w.word === selectedOpt.dataset.baseform);
                } else { 
                     wordEntry = (currentLanguage.lexicon || []).find(w => w.word === searchTerm || transliterateWordToSymbols(w.word) === searchTerm);
                }
                displayEtymologyForWord(wordEntry ? wordEntry.id : null, searchTerm);
            };

            searchBtn.addEventListener('click', performSearch);
            wordSearchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') performSearch(); });
        }

        function displayEtymologyForWord(wordId, originalSearchTerm) {
            const resultsContainer = document.getElementById('etymologyResults'); 
            const treeChartContainer = document.getElementById('wordEtymologyTreeChart');
            if(!resultsContainer || !treeChartContainer) return;

            resultsContainer.innerHTML = ''; treeChartContainer.innerHTML = '';

             const wordEntry = wordId ? (currentLanguage.lexicon || []).find(w => w.id === wordId) : null;

             if (!wordEntry) {
                resultsContainer.innerHTML = `<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "${originalSearchTerm}" ‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°</p>`;
                return;
            }

            let resultHTML = `<h3 class="text-lg font-semibold text-teal-600">${transliterateWordToSymbols(wordEntry.word)} <span class="text-sm text-gray-500 font-mono">(${wordEntry.word})</span></h3>`;
            resultHTML += `<p class="text-sm text-gray-600"><strong>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢:</strong> ${wordEntry.meaning}</p>`;
            if (wordEntry.etymology && (wordEntry.etymology.roots && wordEntry.etymology.roots.length > 0 || wordEntry.etymology.notes)) {
                if (wordEntry.etymology.notes) resultHTML += `<p class="text-sm mt-1"><strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${wordEntry.etymology.notes}</p>`;
                if (wordEntry.etymology.roots && wordEntry.etymology.roots.length > 0) {
                    resultHTML += `<h4 class="text-md font-medium mt-2 text-teal-500">‡∏£‡∏≤‡∏Å‡∏®‡∏±‡∏û‡∏ó‡πå‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á:</h4><ul class="list-disc list-inside ml-4 text-sm">`;
                    wordEntry.etymology.roots.forEach(root => {
                        if (root.wordId) {
                            const parentWord = (currentLanguage.lexicon || []).find(w => w.id === root.wordId);
                            resultHTML += `<li>‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤: <strong>${parentWord ? transliterateWordToSymbols(parentWord.word) : '‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏•‡∏ö'}</strong> <span class="font-mono text-xs text-gray-500">[${parentWord ? parentWord.word : 'N/A'}]</span></li>`;
                        } else if (root.customRoot) {
                            resultHTML += `<li>‡∏°‡∏≤‡∏à‡∏≤‡∏Å: <strong>${root.customRoot}</strong> (‡∏†‡∏≤‡∏©‡∏≤: ${root.sourceLang || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'})</li>`;
                        }
                    });
                    resultHTML += `</ul>`;
                }
            } else {
                resultHTML += `<p class="text-sm text-gray-500 mt-1">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏®‡∏±‡∏û‡∏ó‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ</p>`;
            }
            resultsContainer.innerHTML = resultHTML;
            treeChartContainer.appendChild(buildEtymologyTreeRecursive(wordEntry, new Set(), wordEntry.id, true)); 
        }

        function buildEtymologyTreeRecursive(wordEntry, visited = new Set(), searchedWordId = null, isRootOfSearch = false) {
            if (!wordEntry || visited.has(wordEntry.id)) {
                const emptyNode = document.createElement('ul');
                if (wordEntry && visited.has(wordEntry.id)) { 
                     const li = document.createElement('li');
                     li.innerHTML = `<span class="pedigree-node italic text-xs">‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏ã‡πâ‡∏≥: ${transliterateWordToSymbols(wordEntry.word)}</span>`;
                     emptyNode.appendChild(li);
                }
                return emptyNode;
            }
            visited.add(wordEntry.id);

            const ul = document.createElement('ul');
            const li = document.createElement('li');

            let nodeClass = 'pedigree-node';
            if (wordEntry.id === searchedWordId && isRootOfSearch) { 
                nodeClass += ' searched font-bold'; 
            }
            li.innerHTML = `<span class="${nodeClass}">${transliterateWordToSymbols(wordEntry.word)}</span> <span class="text-xs text-gray-500 font-mono">(${wordEntry.word})</span> <span class="text-xs text-gray-500">(${wordEntry.meaning})</span>`;

            if (wordEntry.etymology && wordEntry.etymology.roots && wordEntry.etymology.roots.length > 0) {
                const ancestorsUl = document.createElement('ul');
                wordEntry.etymology.roots.forEach(root => {
                    if (root.wordId) {
                        const parentWord = (currentLanguage.lexicon || []).find(w => w.id === root.wordId);
                        if (parentWord) {
                            ancestorsUl.appendChild(buildEtymologyTreeRecursive(parentWord, new Set(visited), searchedWordId, false)); 
                        }
                    } else if (root.customRoot) {
                        const customLi = document.createElement('li');
                        customLi.innerHTML = `<span class="pedigree-node text-sm"><i>${root.customRoot}</i> (${root.sourceLang || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'})</span>`;
                        ancestorsUl.appendChild(customLi);
                    }
                });
                 if (ancestorsUl.hasChildNodes()) li.appendChild(ancestorsUl);
            }

            const descendants = currentLanguage.lexicon.filter(w => w.etymology && w.etymology.roots && w.etymology.roots.some(r => r.wordId === wordEntry.id));
            if (descendants.length > 0 && isRootOfSearch) { 
                const descendantsUl = document.createElement('ul');
                descendants.forEach(descWord => {
                     if (!visited.has(descWord.id)) { 
                        descendantsUl.appendChild(buildEtymologyTreeRecursive(descWord, new Set(visited), searchedWordId, false));
                     }
                });
                if (descendantsUl.hasChildNodes()) {
                    const descendantsContainerLi = document.createElement('li'); 
                    descendantsContainerLi.innerHTML = `<span class="text-xs text-teal-600 block mt-1">‡∏Ñ‡∏≥‡∏™‡∏∑‡∏ö‡∏ó‡∏≠‡∏î (Descendants):</span>`;
                    descendantsContainerLi.appendChild(descendantsUl);
                    li.appendChild(descendantsContainerLi);
                }
            }
            ul.appendChild(li);
            return ul;
        }

        function renderEvolutionUI(container) {
            currentLanguage.eras = currentLanguage.eras || [...DEFAULT_LANGUAGE_STATE.eras];
            currentLanguage.eras.forEach(era => { 
                era.soundChangeRules = era.soundChangeRules || [];
            });

            const evolutionContainerId = 'evolutionTabSpecificContent';
            let evolutionContainer = container.querySelector(`#${evolutionContainerId}`);
            if(!evolutionContainer){
                evolutionContainer = document.createElement('div');
                evolutionContainer.id = evolutionContainerId;
                container.appendChild(evolutionContainer);
            }
            evolutionContainer.innerHTML = '';


            const section = document.createElement('div');
            section.className = 'p-3 border border-cyan-200 rounded-md bg-cyan-50 space-y-4';

            const erasSection = document.createElement('div');
            erasSection.innerHTML = `<h4 class="font-semibold text-cyan-700 mb-2">üï∞Ô∏è ‡∏¢‡∏∏‡∏Ñ‡∏ó‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (Historical Eras)</h4>`;
            const erasItemList = document.createElement('div');
            erasItemList.id = 'erasListContainerEvolution'; 
            (currentLanguage.eras.sort((a,b) => (a.order || 0) - (b.order || 0))).forEach((era) => {
                const eraItemDiv = document.createElement('div');
                eraItemDiv.className = 'p-3 mb-2 bg-white rounded border border-cyan-100 shadow-sm';
                eraItemDiv.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <span class="font-medium">${era.name} (Order: ${era.order || 0})</span>
                        <div>
                            <input type="number" value="${era.order || 0}" class="w-16 p-1 border rounded text-xs mr-2 era-order-input-evolution" data-eraid="${era.id}">
                            <button class="text-xs text-blue-500 hover:text-blue-700 mr-1" onclick="toggleEraSoundChanges('${era.id}')">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏é‡πÄ‡∏™‡∏µ‡∏¢‡∏á</button>
                            <button class="text-xs text-red-500 hover:text-red-700" onclick="removeEra('${era.id}')">‡∏•‡∏ö</button>
                        </div>
                    </div>
                    <div id="soundChangesForEra_${era.id}" class="hidden mt-2 p-2 border-t border-cyan-200 bg-cyan-50 rounded">
                        <h5 class="text-sm font-semibold text-cyan-600 mb-1">‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏¢‡∏∏‡∏Ñ ${era.name}):</h5>
                        <div id="rulesListEra_${era.id}" class="space-y-1 text-xs mb-2 max-h-40 overflow-y-auto">
                            ${(era.soundChangeRules || []).map((rule, ruleIdx) => `
                                <div class="flex justify-between items-center p-1 bg-white rounded border">
                                    <span>'${rule.from}' <i class="fas fa-arrow-right mx-1"></i> '${rule.to}' ${rule.context ? '('+rule.context+')' : ''} (${rule.description || 'N/A'})</span>
                                    <button class="text-red-400 hover:text-red-600" onclick="removeSoundChangeRuleFromEra('${era.id}', ${ruleIdx})">&times;</button>
                                </div>`).join('') || '<p class="text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é</p>'}
                        </div>
                        <div class="flex gap-1 items-end flex-wrap">
                            <input type="text" placeholder="‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á" class="p-1 border rounded text-xs era-sc-from-evolution" data-eraid="${era.id}" style="width:80px;">
                            <input type="text" placeholder="‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á" class="p-1 border rounded text-xs era-sc-to-evolution" data-eraid="${era.id}" style="width:80px;">
                            <input type="text" placeholder="‡∏ö‡∏£‡∏¥‡∏ö‡∏ó (‡πÄ‡∏ä‡πà‡∏ô V_V)" class="p-1 border rounded text-xs era-sc-context-evolution" data-eraid="${era.id}" style="width:100px;">
                            <input type="text" placeholder="‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏" class="p-1 border rounded text-xs era-sc-desc-evolution flex-grow" data-eraid="${era.id}">
                            <button class="btn-secondary bg-cyan-300 text-cyan-800 px-2 py-1 rounded text-xs" onclick="addSoundChangeRuleToEra('${era.id}')">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                        </div>
                    </div>
                `;
                erasItemList.appendChild(eraItemDiv);
            });
            erasSection.appendChild(erasItemList);
            erasSection.innerHTML += `
                <div class="flex gap-2 mt-3 items-center p-2 border-t">
                    <input type="text" id="newEraNameEvolution" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏¢‡∏∏‡∏Ñ‡πÉ‡∏´‡∏°‡πà" class="p-1 border rounded-md text-sm flex-grow">
                    <input type="number" id="newEraOrderEvolution" placeholder="‡∏•‡∏≥‡∏î‡∏±‡∏ö" value="${currentLanguage.eras.length}" class="p-1 border rounded-md text-sm w-20">
                    <button id="addEraBtnEvolution" class="btn-secondary bg-cyan-400 px-2 py-1 rounded-md text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏¢‡∏∏‡∏Ñ</button>
                </div>`;
            section.appendChild(erasSection);
            evolutionContainer.appendChild(section);

            document.getElementById('addEraBtnEvolution').onclick = () => {
                const name = document.getElementById('newEraNameEvolution').value.trim();
                const order = parseInt(document.getElementById('newEraOrderEvolution').value);
                if (name) {
                    currentLanguage.eras.push({ id: `era_${Date.now()}`, name, order: isNaN(order) ? currentLanguage.eras.length : order, soundChangeRules: [] });
                    renderEvolutionUI(container); saveData();
                }
            };
            evolutionContainer.querySelectorAll('.era-order-input-evolution').forEach(input => {
                input.onchange = (e) => {
                    const era = currentLanguage.eras.find(er => er.id === e.target.dataset.eraid);
                    if(era) era.order = parseInt(e.target.value);
                    renderEvolutionUI(container); saveData(); 
                };
            });
        }

        window.toggleEraSoundChanges = (eraId) => {
            const section = document.getElementById(`soundChangesForEra_${eraId}`);
            if (section) section.classList.toggle('hidden');
        };

        window.addSoundChangeRuleToEra = (eraId) => {
            const era = currentLanguage.eras.find(e => e.id === eraId);
            if (!era) return;
            const fromInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-from-evolution`);
            const toInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-to-evolution`);
            const contextInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-context-evolution`);
            const descInput = document.querySelector(`#soundChangesForEra_${eraId} .era-sc-desc-evolution`);

            const from = fromInput.value.trim();
            const to = toInput.value.trim();
            const context = contextInput.value.trim();
            const description = descInput.value.trim();

            if (from) {  
                era.soundChangeRules.push({ from, to, context, description });
                fromInput.value = ''; toInput.value = ''; contextInput.value = ''; descInput.value = ''; 
                renderEvolutionUI(tabContentContainer); 
                saveData();
                setTimeout(() => {
                    const eraSection = document.getElementById(`soundChangesForEra_${eraId}`);
                    if (eraSection && eraSection.classList.contains('hidden')) { 
                        eraSection.classList.remove('hidden');
                    }
                },0);
            }
        };

        window.removeSoundChangeRuleFromEra = (eraId, ruleIndex) => {
            const era = currentLanguage.eras.find(e => e.id === eraId);
            if (era && era.soundChangeRules && era.soundChangeRules[ruleIndex]) {
                era.soundChangeRules.splice(ruleIndex, 1);
                renderEvolutionUI(tabContentContainer); saveData();
                 setTimeout(() => { 
                    const eraSection = document.getElementById(`soundChangesForEra_${eraId}`);
                    if (eraSection && eraSection.classList.contains('hidden')) { 
                        eraSection.classList.remove('hidden');
                    }
                },0);
            }
        };

        window.removeEra = (eraId) => {
            currentLanguage.eras = currentLanguage.eras.filter(e => e.id !== eraId);
            currentLanguage.lexicon.forEach(word => {
                if (word.evolutionTimeline) {
                    word.evolutionTimeline = word.evolutionTimeline.filter(ev => ev.eraId !== eraId);
                }
            });
            renderEvolutionUI(tabContentContainer); saveData();
        };

        function applyInterEraSoundChanges(text, rules) { 
            let newText = text;
            if (rules && rules.length > 0) {
                rules.forEach(rule => {
                    try {
                         const regex = convertContextualRuleToRegex(rule.from, rule.to, rule.context);
                         newText = newText.replace(regex, rule.to); 
                    } catch (e) {
                        console.warn("Invalid regex in sound change rule:", rule, e);
                    }
                });
            }
            return newText;
        }
        
        function convertContextualRuleToRegex(from, to, contextStr) {
            const V = '[aeiouAEIOU√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√ø…ô√¶…î]'; 
            const C = '[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ≈ã É íŒ∏√∞ î à…ñ…≥ Ç ê√ß ù…∏Œ≤…±‚±±…æ…Ω…≤≈ã…¥ Äƒß ï…¨…Æ…∞]'; 
            
            let escFrom = from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            let pre = '', post = '';

            if (contextStr) {
                const parts = contextStr.split('_');
                if (parts.length === 2) {
                    if (parts[0] === '#') pre = '^';
                    else if (parts[0] === 'V') pre = `(?<=${V})`;
                    else if (parts[0] === 'C') pre = `(?<=${C})`;
                    else if (parts[0]) pre = `(?<=${parts[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;

                    if (parts[1] === '#') post = '$';
                    else if (parts[1] === 'V') post = `(?=${V})`;
                    else if (parts[1] === 'C') post = `(?=${C})`;
                    else if (parts[1]) post = `(?=${parts[1].replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`;
                }
            }
            return new RegExp(pre + escFrom + post, 'g');
        }


        window.openEvolutionModalForWord = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;
            word.evolutionTimeline = word.evolutionTimeline || []; 

            genericModalTitle.textContent = `‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: ${transliterateWordToSymbols(word.word)} [${word.word}]`;
            let content = `<p class="text-sm mb-2">‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏¢‡∏∏‡∏Ñ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á): <strong class="font-mono">${word.word}</strong>, ‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ê‡∏≤‡∏ô (‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î): <strong class="font-mono">${word.phonetics || 'N/A'}</strong></p>`;

            const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));

            sortedEras.forEach((era, eraIndex) => {
                const existingEvo = word.evolutionTimeline.find(e => e.eraId === era.id);
                let initialPhonetic = existingEvo?.phoneticForm || '';
                let initialOrthographic = existingEvo?.orthographicForm || '';

                // Determine the base form for this era.  The initial form should be set on the base era defined per word.
                if (!existingEvo) {
                    if (word.baseEraId && era.id === word.baseEraId) {
                        initialPhonetic = word.word;
                        initialOrthographic = transliterateWordToSymbols(initialPhonetic);
                    } else if ((!word.baseEraId || word.baseEraId === '') && eraIndex === 0) {
                        // Fallback to the first era when no base era is defined
                        initialPhonetic = word.word;
                        initialOrthographic = transliterateWordToSymbols(initialPhonetic);
                    }
                }

                content += `
                <div class="p-3 border rounded bg-gray-50 mb-2 evo-era-entry" data-eraid="${era.id}">
                    <div class="flex justify-between items-center">
                        <h5 class="font-semibold text-purple-600">${era.name}</h5>
                        ${eraIndex > 0 ? `<button class="text-xs btn-secondary bg-cyan-500 hover:bg-cyan-600 px-2 py-1 rounded" onclick="autoGenerateForEra('${word.id}', '${era.id}', '${sortedEras[eraIndex-1].id}')">‡∏®‡∏±‡∏û‡∏ó‡πå‡∏à‡∏≤‡∏Å‡∏¢‡∏∏‡∏Ñ '${sortedEras[eraIndex-1].name}'</button>` : ''}
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-1">
                        <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phonetic):</label><input type="text" class="w-full p-1 border rounded text-sm evo-phonetic font-mono" value="${initialPhonetic}"></div>
                        <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Orthographic):</label><input type="text" class="w-full p-1 border rounded text-sm evo-orthographic font-mono" value="${initialOrthographic}"></div>
                    </div>
                    <div><label class="text-xs mt-1">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</label><textarea class="w-full p-1 border rounded text-sm evo-notes" rows="1">${existingEvo?.notes || ''}</textarea></div>
                </div>`;
            });
            genericModalContent.innerHTML = content;

            genericModalFooter.innerHTML = `<button id="saveEvolutionChangesBtnModal" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</button>`;
            document.getElementById('saveEvolutionChangesBtnModal').onclick = () => {
                const newEvolutionTimeline = [];
                genericModalContent.querySelectorAll('.evo-era-entry').forEach(entryDiv => {
                    const eraId = entryDiv.dataset.eraid;
                    const phoneticInput = entryDiv.querySelector(`.evo-phonetic`);
                    const orthographicInput = entryDiv.querySelector(`.evo-orthographic`);
                    const notesInput = entryDiv.querySelector(`.evo-notes`);
                    if (phoneticInput.value.trim() || orthographicInput.value.trim() || notesInput.value.trim()) {
                         newEvolutionTimeline.push({
                            eraId: eraId,
                            phoneticForm: phoneticInput.value.trim(),
                            orthographicForm: orthographicInput.value.trim(),
                            notes: notesInput.value.trim()
                        });
                    }
                });
                word.evolutionTimeline = newEvolutionTimeline;
                saveData();
                genericModal.classList.add('hidden');
                if (activeTab === 'dictionary') showWordDetailPopup(wordId); 
                else if (activeTab === 'evolution') renderEvolutionUI(tabContentContainer); 
            };
            wordDetailModal.classList.add('hidden'); 
            genericModal.classList.remove('hidden');
        };

        window.autoGenerateForEra = (wordId, currentEraId, previousEraId) => {
            const word = currentLanguage.lexicon.find(w => w.id === parseInt(wordId));
            const currentEra = currentLanguage.eras.find(e => e.id === currentEraId);
            if (!word || !currentEra) return;

            let previousPhoneticForm = '';
            const previousEraEntryDivModal = genericModalContent.querySelector(`.evo-era-entry[data-eraid="${previousEraId}"] .evo-phonetic`);
            if (previousEraEntryDivModal && previousEraEntryDivModal.value.trim()) {
                 previousPhoneticForm = previousEraEntryDivModal.value.trim();
            } else { 
                const previousEvoEntry = word.evolutionTimeline.find(e => e.eraId === previousEraId); 
                if (previousEvoEntry && previousEvoEntry.phoneticForm) {
                    previousPhoneticForm = previousEvoEntry.phoneticForm;
                } else { 
                    const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));
                    if (sortedEras.length > 0 && sortedEras[0].id === previousEraId) {
                        previousPhoneticForm = word.word; 
                    }
                }
            }
            
            if (!previousPhoneticForm) {
                alert(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∏‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ (${currentLanguage.eras.find(e=>e.id === previousEraId)?.name || previousEraId}). ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∏‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏•‡∏±‡∏Å`);
                return;
            }

            const rules = currentEra.soundChangeRules || [];
            const newPhoneticForm = applyInterEraSoundChanges(previousPhoneticForm, rules);

            const currentEraEntryDivModal = genericModalContent.querySelector(`.evo-era-entry[data-eraid="${currentEraId}"]`);
            if (currentEraEntryDivModal) {
                currentEraEntryDivModal.querySelector('.evo-phonetic').value = newPhoneticForm;
                currentEraEntryDivModal.querySelector('.evo-orthographic').value = transliterateWordToSymbols(newPhoneticForm); 
            }
        };

        // Display a read-only evolution overview for a specific word.  This shows the evolution as a
        // horizontal flow (tree-like) and a table listing the forms across eras.  Invoked from the
        // dictionary word detail popup when the user clicks the "‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå" button.  It uses
        // the genericModal to present the information.
        window.showEvolutionDetailPopup = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word || !word.evolutionTimeline || word.evolutionTimeline.length === 0) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ');
                return;
            }
            // Sort eras by order for consistent display
            const sortedEras = [...currentLanguage.eras].sort((a,b) => (a.order || 0) - (b.order || 0));
            genericModalTitle.textContent = `‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: ${transliterateWordToSymbols(word.word)} [${word.word}]`;
            let content = '<div class="space-y-6">';
            // Flow / tree diagram section
            content += '<div><h4 class="text-lg font-semibold text-purple-700 mb-2">‡πÅ‡∏ú‡∏ô‡∏†‡∏π‡∏°‡∏¥‡∏™‡∏≤‡∏¢‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£</h4><div class="word-evolution-flow-container flex flex-wrap items-center">';
            let first = true;
            sortedEras.forEach((era) => {
                const evoEntry = word.evolutionTimeline.find(e => e.eraId === era.id);
                if (evoEntry && (evoEntry.phoneticForm || evoEntry.orthographicForm)) {
                    if (!first) {
                        content += '<span class="evolution-arrow">&rarr;</span>';
                    }
                    first = false;
                    const ph = evoEntry.phoneticForm || '';
                    let ortho = '';
                    if (evoEntry.orthographicForm && evoEntry.orthographicForm.trim() !== '') {
                        ortho = evoEntry.orthographicForm;
                    } else {
                        // Fallback to transliteration of the phonetic form
                        ortho = transliterateWordToSymbols(ph);
                    }
                    content += `<div class="evolution-era-node"><strong>${era.name}</strong><span class="ortho">${ortho}</span><span class="phonetic">/${ph}/</span></div>`;
                }
            });
            if (first) {
                content += '<p class="text-sm text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á</p>';
            }
            content += '</div></div>';
            // Table section
            content += '<div><h4 class="text-lg font-semibold text-purple-700 mb-2">‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£</h4>';
            content += '<table class="min-w-full divide-y divide-purple-200 bg-white rounded shadow">';
            content += '<thead><tr class="bg-purple-100">';
            content += '<th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏¢‡∏∏‡∏Ñ</th>';
            content += '<th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á</th>';
            content += '<th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô</th>';
            content += '<th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏</th>';
            content += '</tr></thead><tbody>';
            sortedEras.forEach((era) => {
                const evoEntry = word.evolutionTimeline.find(e => e.eraId === era.id);
                if (evoEntry && (evoEntry.phoneticForm || evoEntry.orthographicForm || evoEntry.notes)) {
                    const ph = evoEntry.phoneticForm || '';
                    let ortho = '';
                    if (evoEntry.orthographicForm && evoEntry.orthographicForm.trim() !== '') {
                        ortho = evoEntry.orthographicForm;
                    } else {
                        ortho = transliterateWordToSymbols(ph);
                    }
                    const notes = evoEntry.notes || '';
                    content += `<tr><td class="px-4 py-2 text-sm text-gray-700">${era.name}</td><td class="px-4 py-2 text-sm font-mono">${ph}</td><td class="px-4 py-2 text-sm font-mono">${ortho}</td><td class="px-4 py-2 text-sm text-gray-600">${notes}</td></tr>`;
                }
            });
            content += '</tbody></table></div>';
            content += '</div>';
            genericModalContent.innerHTML = content;
            genericModalFooter.innerHTML = `<button class="btn-secondary" onclick="closeGenericModal.click()">‡∏õ‡∏¥‡∏î</button>`;
            // Hide the word detail modal and show the generic modal
            wordDetailModal.classList.add('hidden');
            genericModal.classList.remove('hidden');
        };

        function applyDialectSoundChanges(text, rules) { 
            return applyInterEraSoundChanges(text, rules); // Reusing the same logic for now
        }

        function renderDialectsUI(container) {
            currentLanguage.regions = currentLanguage.regions || [...DEFAULT_LANGUAGE_STATE.regions];
            currentLanguage.dialectSoundChanges = currentLanguage.dialectSoundChanges || {};
             currentLanguage.regions.forEach(region => {
                if (!currentLanguage.dialectSoundChanges[region]) {
                    currentLanguage.dialectSoundChanges[region] = [];
                }
            });

            const dialectsContainerId = 'dialectsTabSpecificContent';
            let dialectsContainer = container.querySelector(`#${dialectsContainerId}`);
            if(!dialectsContainer){
                dialectsContainer = document.createElement('div');
                dialectsContainer.id = dialectsContainerId;
                container.appendChild(dialectsContainer);
            }
            dialectsContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-lime-200 rounded-md bg-lime-50 space-y-4';

            createListInput(section, 'üåç ‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô (Dialect Regions)', currentLanguage.regions, "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ (‡πÄ‡∏ä‡πà‡∏ô Northern, Capital City)",
                (item) => { 
                    if (!currentLanguage.regions.includes(item)) {
                        currentLanguage.regions.push(item); 
                        if (!currentLanguage.dialectSoundChanges[item]) {
                           currentLanguage.dialectSoundChanges[item] = []; 
                        }
                        renderDialectsUI(container); 
                        saveData(); 
                    } else {
                        alert("‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
                    }
                },
                (index) => {
                    const regionNameToRemove = currentLanguage.regions[index];
                    currentLanguage.regions.splice(index, 1);
                    delete currentLanguage.dialectSoundChanges[regionNameToRemove]; 
                    currentLanguage.lexicon.forEach(word => {
                        if (word.dialectalForms) {
                            word.dialectalForms = word.dialectalForms.filter(df => df.regionName !== regionNameToRemove);
                        }
                    });
                    renderDialectsUI(container); 
                    saveData(); 
                }
            );

            const rulesSection = document.createElement('div');
            rulesSection.innerHTML = `<h4 class="font-semibold text-lime-700 mt-4 mb-2">‚öôÔ∏è ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô:</h4>`;
            if (currentLanguage.regions.length > 0) {
                currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(region => { 
                    const safeRegionIdPart = region.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const regionRulesDiv = document.createElement('div');
                    regionRulesDiv.className = 'p-3 mb-2 bg-white rounded border border-lime-100 shadow-sm';
                    regionRulesDiv.innerHTML = `
                        <div class="flex items-center justify-between mb-2">
                            <h5 class="font-medium text-lime-600">${region}</h5>
                            <button class="text-xs text-blue-500 hover:text-blue-700" onclick="toggleRegionRulesDisplay('rulesForRegion_${safeRegionIdPart}')">‡πÅ‡∏™‡∏î‡∏á/‡∏ã‡πà‡∏≠‡∏ô‡∏Å‡∏é</button>
                        </div>
                        <div id="rulesForRegion_${safeRegionIdPart}" class="hidden mt-2 p-2 border-t border-lime-200 bg-lime-50 rounded">
                            <div id="rulesListForRegion_${safeRegionIdPart}" class="space-y-1 text-xs mb-2 max-h-40 overflow-y-auto"></div>
                            <div class="flex gap-1 items-end flex-wrap">
                                <input type="text" placeholder="‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå" class="p-1 border rounded text-xs region-sc-from" data-region="${region}" style="width:100px;">
                                <input type="text" placeholder="‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå" class="p-1 border rounded text-xs region-sc-to" data-region="${region}" style="width:100px;">
                                <input type="text" placeholder="‡∏ö‡∏£‡∏¥‡∏ö‡∏ó (‡πÄ‡∏ä‡πà‡∏ô V_V)" class="p-1 border rounded text-xs region-sc-context flex-grow" data-region="${region}" style="min-width:100px;">
                                <input type="text" placeholder="‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏" class="p-1 border rounded text-xs region-sc-desc flex-grow" data-region="${region}" style="min-width:100px;">
                                <button class="btn-secondary bg-lime-300 text-lime-800 px-2 py-1 rounded text-xs" onclick="addSoundChangeRuleToRegion('${region}')">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                            </div>
                        </div>
                    `;
                    rulesSection.appendChild(regionRulesDiv);
                    renderRegionSoundRulesList(region, `rulesListForRegion_${safeRegionIdPart}`);
                });
                 if(currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').length === 0){
                     rulesSection.innerHTML += `<p class="text-sm text-gray-500">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏≠‡∏∑‡πà‡∏ô‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å 'Standard' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é</p>`;
                 }
            } else {
                rulesSection.innerHTML += `<p class="text-sm text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∂‡∏á‡∏à‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ</p>`;
            }
            section.appendChild(rulesSection);

            const comparisonSection = document.createElement('div');
            comparisonSection.className = 'mt-4 pt-3 border-t border-lime-200';
            const wordSearchId = `dialectWordSearch_${Date.now()}`;
            const wordSearchDatalistId = `dialectWordDatalist_${Date.now()}`;
            let datalistOptions = '';
            (currentLanguage.lexicon || []).forEach(w => { 
                let ortho = getOrthographicForm(w, false, false);
                let base = w.word;
                datalistOptions += `<option value="${ortho}" data-wordid="${w.id}" data-baseform="${base}">${ortho} (${base})</option>`;
            });

            comparisonSection.innerHTML = `
                <h4 class="font-semibold text-lime-700 mb-2">üìä ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô:</h4>
                <datalist id="${wordSearchDatalistId}">${datalistOptions}</datalist>
                <div class="flex gap-2 items-center mb-2">
                    <input type="text" id="${wordSearchId}" list="${wordSearchDatalistId}" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°..." class="flex-grow p-2 border border-lime-300 rounded-md">
                    <button id="searchDialectComparisonBtn" class="btn-primary bg-lime-500 hover:bg-lime-600 px-3 py-1 rounded-md text-sm">‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö</button>
                </div>
                <div id="dialectComparisonTableContainer" class="overflow-x-auto bg-white p-2 rounded shadow min-h-[100px]">
                    <p class="text-center text-gray-400">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö</p>
                </div>
            `;
            section.appendChild(comparisonSection);
            const searchBtn = comparisonSection.querySelector('#searchDialectComparisonBtn');
            if (searchBtn) {
                searchBtn.addEventListener('click', () => {
                    const searchInput = document.getElementById(wordSearchId);
                    const searchTerm = searchInput.value.trim();
                    let wordEntry;
                    const selectedOpt = Array.from(document.getElementById(wordSearchDatalistId).options).find(opt => opt.value === searchTerm && opt.dataset.wordid);

                    if (selectedOpt) {
                        wordEntry = (currentLanguage.lexicon || []).find(w => w.id === parseInt(selectedOpt.dataset.wordid));
                    } else { 
                        const baseFormFromDatalist = Array.from(document.getElementById(wordSearchDatalistId).options).find(opt => opt.value === searchTerm)?.dataset.baseform;
                        if (baseFormFromDatalist) {
                             wordEntry = (currentLanguage.lexicon || []).find(w => w.word === baseFormFromDatalist);
                        } else { 
                            wordEntry = (currentLanguage.lexicon || []).find(w => w.word === searchTerm || transliterateWordToSymbols(w.word) === searchTerm || w.meaning.toLowerCase().includes(searchTerm.toLowerCase()));
                        }
                    }

                    if (wordEntry) {
                        displayDialectComparisonTable(wordEntry);
                    } else {
                        document.getElementById('dialectComparisonTableContainer').innerHTML = '<p class="text-red-500 text-center">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå</p>';
                    }
                });
            }

            const dialectWordList = document.createElement('div');
            dialectWordList.innerHTML = `<h4 class="font-semibold text-lime-700 mt-4 pt-3 border-t border-lime-200 mb-2">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡πÅ‡∏•‡πâ‡∏ß:</h4>`;
            const ul = document.createElement('ul');
            ul.className = 'list-disc list-inside max-h-60 overflow-y-auto bg-white p-2 rounded shadow text-sm';
            let count = 0;
            currentLanguage.lexicon.forEach(word => {
                if (word.dialectalForms && word.dialectalForms.length > 0) {
                    count++;
                    const li = document.createElement('li');
                    li.className = 'p-1 hover:bg-lime-100 cursor-pointer';
                    li.innerHTML = `${transliterateWordToSymbols(word.word)} <span class="text-xs text-gray-500">(${word.meaning})</span> - <button class="text-xs text-blue-500" onclick="openDialectModalForWord(${word.id})">‡∏î‡∏π/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç (${word.dialectalForms.length} ‡∏ñ‡∏¥‡πà‡∏ô)</button>`;
                    ul.appendChild(li);
                }
            });
            if(count === 0) ul.innerHTML = `<li class="text-sm text-gray-500 p-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô</li>`;
            dialectWordList.appendChild(ul);
            section.appendChild(dialectWordList);

            dialectsContainer.appendChild(section);
        }

        window.toggleRegionRulesDisplay = (divId) => {
            const element = document.getElementById(divId);
            if (element) {
                element.classList.toggle('hidden');
            }
        };

        function renderRegionSoundRulesList(regionName, listContainerId) {
            const rulesListContainer = document.getElementById(listContainerId);
            if (!rulesListContainer) return; 
            
            rulesListContainer.innerHTML = ''; 
            const rules = currentLanguage.dialectSoundChanges[regionName] || [];

            if (rules.length === 0) {
                rulesListContainer.innerHTML = '<p class="text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏ô‡∏µ‡πâ</p>';
                return;
            }

            rules.forEach((rule, index) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'flex justify-between items-center p-1 bg-white rounded border border-lime-50';
                ruleDiv.innerHTML = `
                    <span>'${rule.from}' <i class="fas fa-arrow-right mx-1"></i> '${rule.to}' ${rule.context ? '('+rule.context+')' : ''} ${rule.description ? `(${rule.description})` : ''}</span>
                    <button class="text-red-400 hover:text-red-600 text-xs" onclick="removeSoundChangeRuleFromRegion('${regionName}', ${index})">&times; ‡∏•‡∏ö</button>
                `;
                rulesListContainer.appendChild(ruleDiv);
            });
        }
        
        window.addSoundChangeRuleToRegion = (regionName) => {
            const fromInput = document.querySelector(`.region-sc-from[data-region="${regionName}"]`);
            const toInput = document.querySelector(`.region-sc-to[data-region="${regionName}"]`);
            const contextInput = document.querySelector(`.region-sc-context[data-region="${regionName}"]`);
            const descInput = document.querySelector(`.region-sc-desc[data-region="${regionName}"]`);

            if (!fromInput || !toInput || !descInput || !contextInput) {
                console.error("Could not find input fields for region:", regionName);
                return;
            }

            const from = fromInput.value.trim();
            const to = toInput.value.trim(); 
            const context = contextInput.value.trim();
            const description = descInput.value.trim();

            if (from) { 
                if (!currentLanguage.dialectSoundChanges[regionName]) {
                    currentLanguage.dialectSoundChanges[regionName] = [];
                }
                currentLanguage.dialectSoundChanges[regionName].push({ from, to, context, description });
                
                fromInput.value = '';
                toInput.value = '';
                contextInput.value = '';
                descInput.value = '';
                
                const safeRegionIdPart = regionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                renderRegionSoundRulesList(regionName, `rulesListForRegion_${safeRegionIdPart}`);
                saveData();
                setTimeout(() => {
                    const regionSection = document.getElementById(`rulesForRegion_${safeRegionIdPart}`);
                    if (regionSection && regionSection.classList.contains('hidden')) { 
                        regionSection.classList.remove('hidden');
                    }
                },0);
            } else {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å '‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á' ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢");
            }
        };

        window.removeSoundChangeRuleFromRegion = (regionName, ruleIndex) => {
            if (currentLanguage.dialectSoundChanges[regionName] && currentLanguage.dialectSoundChanges[regionName][ruleIndex]) {
                currentLanguage.dialectSoundChanges[regionName].splice(ruleIndex, 1);
                const safeRegionIdPart = regionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                renderRegionSoundRulesList(regionName, `rulesListForRegion_${safeRegionIdPart}`);
                saveData();
                setTimeout(() => { 
                    const regionSection = document.getElementById(`rulesForRegion_${safeRegionIdPart}`);
                    if (regionSection && regionSection.classList.contains('hidden')) { 
                        regionSection.classList.remove('hidden');
                    }
                },0);
            }
        };

        function displayDialectComparisonTable(wordEntry) {
            const container = document.getElementById('dialectComparisonTableContainer');
            if (!container || !wordEntry) return;

            container.innerHTML = ''; 

            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-lime-300 bg-white shadow-sm rounded-lg text-sm';
            
            let headerHtml = `<tr>
                <th class="px-3 py-2 text-left text-xs font-medium text-lime-700 uppercase">‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞</th>
                <th class="px-3 py-2 text-left text-xs font-medium text-lime-700 uppercase">‡∏†‡∏≤‡∏©‡∏≤‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô<br>(${transliterateWordToSymbols(wordEntry.word)})</th>`;
            currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(region => {
                headerHtml += `<th class="px-3 py-2 text-left text-xs font-medium text-lime-700 uppercase">${region}</th>`;
            });
            headerHtml += `</tr>`;
            table.innerHTML = `<thead class="bg-lime-100">${headerHtml}</thead><tbody></tbody>`;
            const tbody = table.querySelector('tbody');

            let orthoRow = `<tr><td class="px-3 py-2 font-medium">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô</td><td class="px-3 py-2 font-mono">${transliterateWordToSymbols(wordEntry.word)}</td>`;
            // Build the phonetic row. Each cell will include a headphone icon to play the sound.
            let phoneticRow = `<tr><td class="px-3 py-2 font-medium">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á</td>`;
            // Standard (base) phonetic form
            const stdPhon = wordEntry.word || '';
            phoneticRow += `<td class="px-3 py-2 font-mono"><div class="inline-flex items-center" data-phonetic="${stdPhon}" data-voiceid="${wordEntry.voiceId || ''}"><span>${stdPhon}</span><button type="button" class="text-blue-500 ml-1 dialect-phonetics-btn" title="‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"><i class="fas fa-headphones"></i></button></div></td>`;

            currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(region => {
                const manualForm = (wordEntry.dialectalForms || []).find(df => df.regionName === region);
                let dialectOrthographic = '<span class="text-gray-400">-</span>';
                let dialectPhonetic = '<span class="text-gray-400">-</span>';
                let source = '<span class="text-xs text-gray-400">(‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏)</span>';
                const basePhoneticForDialect = wordEntry.word; // Use base phonemic form for rule application

                if (manualForm && (manualForm.orthographic || manualForm.phonetic)) {
                    dialectPhonetic = manualForm.phonetic || manualForm.orthographic; // Prefer phonetic if available
                    dialectOrthographic = manualForm.orthographic ? transliterateWordToSymbols(manualForm.orthographic) : transliterateWordToSymbols(dialectPhonetic);
                    source = '<span class="text-xs text-blue-500">(‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á)</span>';
                } else {
                    const rules = currentLanguage.dialectSoundChanges[region] || [];
                    if (rules.length > 0 && basePhoneticForDialect) {
                        const generatedPhonetic = applyDialectSoundChanges(basePhoneticForDialect, rules);
                        dialectPhonetic = generatedPhonetic;
                        dialectOrthographic = transliterateWordToSymbols(generatedPhonetic);
                        source = `<span class="text-xs text-green-500">(‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏é)</span>`;
                    }
                }
                orthoRow += `<td class="px-3 py-2 font-mono">${dialectOrthographic} ${source}</td>`;
                // Sanitize the value for the data attribute (remove HTML tags) but keep original content for display
                const sanitizedDialect = typeof dialectPhonetic === 'string' ? dialectPhonetic.replace(/<[^>]*>/g, '') : '';
                phoneticRow += `<td class="px-3 py-2 font-mono"><div class="inline-flex items-center" data-phonetic="${sanitizedDialect}" data-voiceid="${wordEntry.voiceId || ''}"><span>${dialectPhonetic}</span><button type="button" class="text-blue-500 ml-1 dialect-phonetics-btn" title="‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"><i class="fas fa-headphones"></i></button></div></td>`;
            });
            orthoRow += `</tr>`;
            phoneticRow += `</tr>`;

            tbody.innerHTML = orthoRow + phoneticRow;
            container.appendChild(table);
            container.innerHTML += `<div class="text-right mt-2"><button class="text-xs btn-secondary" onclick="openDialectModalForWord(${wordEntry.id})">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î</button></div>`;
        }

        window.openDialectModalForWord = (wordId) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;
            word.dialectalForms = word.dialectalForms || []; 

            genericModalTitle.textContent = `‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: ${transliterateWordToSymbols(word.word)}`;
            let content = `<p class="text-sm mb-2">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô: <strong>${word.meaning}</strong> (‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô: <strong class="font-mono">${word.word}</strong>)</p>`;

            content += `<div id="dialectFormsContainerModal" class="space-y-3">`; 
            word.dialectalForms.forEach((df, index) => {
                content += renderDialectFormEntry(df, index, wordId); 
            });
            content += `</div>`;
            content += `<button id="addNewDialectFormBtnModal" class="mt-3 text-sm btn-secondary bg-lime-400"><i class="fas fa-plus mr-1"></i>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏π‡∏õ‡∏Ñ‡∏≥‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà</button>`;

            genericModalContent.innerHTML = content;

            document.getElementById('addNewDialectFormBtnModal').onclick = () => {
                if (currentLanguage.regions.length > 0) {
                    let defaultNewRegion = currentLanguage.regions.find(r => r.toLowerCase() !== 'standard' && !word.dialectalForms.some(df => df.regionName === r));
                    if (!defaultNewRegion) defaultNewRegion = currentLanguage.regions.find(r => r.toLowerCase() !== 'standard') || currentLanguage.regions.find(r => r !== 'Standard') || currentLanguage.regions[0];
                    
                    if (!defaultNewRegion || defaultNewRegion.toLowerCase() === 'standard' && currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').length === 0) {
                        alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà 'Standard' ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÅ‡∏´‡πà‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà Standard");
                        return;
                    }

                     word.dialectalForms.push({
                        regionName: defaultNewRegion, 
                        phonetic: '', orthographic: '', meaning_diff: ''
                    });
                    const formsContainer = document.getElementById('dialectFormsContainerModal');
                    formsContainer.innerHTML = ''; 
                     word.dialectalForms.forEach((df, index) => {
                        formsContainer.innerHTML += renderDialectFormEntry(df, index, wordId); 
                    });
                    attachDialectFormListeners(wordId); 
                } else {
                    alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö '‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô' ‡∏Å‡πà‡∏≠‡∏ô");
                }
            };

            genericModalFooter.innerHTML = `<button id="saveDialectChangesBtnModal" class="btn-primary">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á</button>`;
            document.getElementById('saveDialectChangesBtnModal').onclick = () => {
                const updatedDialectForms = [];
                const formElements = genericModalContent.querySelectorAll('.dialect-form-entry');
                formElements.forEach(formEl => {
                    const region = formEl.querySelector('.dialect-region').value;
            // --- Evolution Table ---
            const evolutionTableSection = document.createElement('div');
            evolutionTableSection.className = 'mb-6 p-4 border border-purple-200 rounded-lg bg-purple-50 shadow-sm';
            const tableHeader = document.createElement('h4');
            tableHeader.className = 'text-lg font-semibold text-purple-700 mb-3';
            tableHeader.textContent = '‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå';
            evolutionTableSection.appendChild(tableHeader);

            // Helper: get evolution timeline for a word
            function getEvolutionTimeline(wordObj) {
                return (wordObj && Array.isArray(wordObj.evolutionTimeline)) ? wordObj.evolutionTimeline : [];
            }

            // Table
            const table = document.createElement('table');
            table.className = 'min-w-full divide-y divide-purple-200 bg-white rounded shadow';
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr class="bg-purple-100">
                    <th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">#</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢</th>
                    <th class="px-4 py-2 text-left text-xs font-medium text-purple-700 uppercase tracking-wider">‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£</th>
                </tr>
            `;
            table.appendChild(thead);
            const tbody = document.createElement('tbody');

            // Filter lexicon: show only words with evolutionTimeline (or all if you want)
            const wordsWithEvolution = (currentLanguage.lexicon || []).filter(w => w.evolutionTimeline && w.evolutionTimeline.length > 0);

            if (wordsWithEvolution.length === 0) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = 4;
                td.className = 'text-center text-gray-400 py-4';
                td.textContent = '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå';
                tr.appendChild(td);
                tbody.appendChild(tr);
            } else {
                wordsWithEvolution.forEach((wordObj, idx) => {
                    const tr = document.createElement('tr');
                    tr.className = idx % 2 === 0 ? 'bg-white' : 'bg-purple-50';
                    // #
                    const tdIdx = document.createElement('td');
                    tdIdx.className = 'px-4 py-2 text-sm text-gray-700';
                    tdIdx.textContent = (idx + 1).toString();
                    tr.appendChild(tdIdx);
                    // ‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå
                    const tdWord = document.createElement('td');
                    tdWord.className = 'px-4 py-2 text-sm font-semibold text-purple-800';
                    tdWord.textContent = wordObj.word || '-';
                    tr.appendChild(tdWord);
                    // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢
                    const tdMeaning = document.createElement('td');
                    tdMeaning.className = 'px-4 py-2 text-sm text-gray-700';
                    tdMeaning.textContent = wordObj.meaning || '-';
                    tr.appendChild(tdMeaning);
                    // ‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£
                    const tdEvo = document.createElement('td');
                    tdEvo.className = 'px-4 py-2 text-sm text-gray-700';
                    const timeline = getEvolutionTimeline(wordObj);
                    if (timeline.length === 0) {
                        tdEvo.textContent = '-';
                    } else {
                        // Show as a sequence: base ‚Üí step1 ‚Üí step2 ...
                        tdEvo.innerHTML = timeline.map((step, i) => {
                            // step: { form, era, notes }
                            let txt = `<span class='font-mono bg-purple-100 px-2 py-0.5 rounded'>${step.form || '-'}</span>`;
                            if (step.era) txt += ` <span class='text-xs text-purple-500'>(${step.era})</span>`;
                            if (step.notes) txt += ` <span class='text-xs text-gray-400' title='${step.notes}'>üõà</span>`;
                            if (i < timeline.length - 1) txt += ` <span class='mx-1 text-purple-400'>&rarr;</span> `;
                            return txt;
                        }).join('');
                    }
                    tr.appendChild(tdEvo);
                    tbody.appendChild(tr);
                });
            }

            table.appendChild(tbody);
            evolutionTableSection.appendChild(table);
            container.appendChild(evolutionTableSection);
                    const phonetic = formEl.querySelector('.dialect-phonetic').value.trim();
                    const orthographic = formEl.querySelector('.dialect-orthographic').value.trim();
                    const meaningDiff = formEl.querySelector('.dialect-meaning').value.trim();
                    if (region && (phonetic || orthographic || meaningDiff)) { 
                        updatedDialectForms.push({ regionName: region, phonetic, orthographic, meaning_diff: meaningDiff });
                    }
                });
                word.dialectalForms = updatedDialectForms;
                saveData();
                genericModal.classList.add('hidden');
                 if (activeTab === 'dictionary') {
                     wordDetailModal.classList.add('hidden'); 
                     showWordDetailPopup(wordId); 
                 } else if (activeTab === 'dialects') {
                     renderDialectsUI(tabContentContainer);
                      const activeSearchInput = document.querySelector('#dialectsTabSpecificContent input[type="text"][id^="dialectWordSearch_"]');
                      if(activeSearchInput && activeSearchInput.value){
                        const searchTerm = activeSearchInput.value.trim();
                        let activeWordEntry;
                        const selectedOpt = Array.from(document.querySelector(`datalist[id^="dialectWordDatalist_"]`).options).find(opt => opt.value === searchTerm && opt.dataset.wordid);
                        if (selectedOpt) activeWordEntry = currentLanguage.lexicon.find(w => w.id === parseInt(selectedOpt.dataset.wordid));
                        else activeWordEntry = currentLanguage.lexicon.find(w => transliterateWordToSymbols(w.word) === searchTerm || w.word === searchTerm);
                        if(activeWordEntry) displayDialectComparisonTable(activeWordEntry);
                      }
                 }
            };
            attachDialectFormListeners(wordId); 
            wordDetailModal.classList.add('hidden'); 
            genericModal.classList.remove('hidden');
        };

        function renderDialectFormEntry(dialectForm, index, wordId) { 
            let regionOptions = '';
            const word = currentLanguage.lexicon.find(w => w.id === wordId); 
            const standardPhonetics = word ? (word.word) : ''; // word.word is base phonemic

            currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').forEach(r => { // Only offer non-standard regions here
                regionOptions += `<option value="${r}" ${dialectForm.regionName === r ? 'selected' : ''}>${r}</option>`;
            });
            if (currentLanguage.regions.filter(r => r.toLowerCase() !== 'standard').length === 0) {
                regionOptions = '<option value="">-- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ñ‡∏¥‡πà‡∏ô) --</option>';
            }
            return `
            <div class="p-3 border rounded bg-gray-50 dialect-form-entry" data-index="${index}">
                <div class="flex justify-between items-center mb-1 flex-wrap">
                    <select class="p-1 border rounded text-sm dialect-region flex-grow mb-1 sm:mb-0 mr-0 sm:mr-2">${regionOptions}</select>
                    <div class="flex gap-2">
                        <button class="text-xs btn-secondary bg-cyan-400 hover:bg-cyan-500 text-white px-1.5 py-0.5 rounded" onclick="generateDialectFormForRegionInModal(${wordId}, ${index})">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏é</button>
                        <button class="text-xs text-red-500 hover:text-red-700 remove-dialect-form-btn" data-index="${index}"><i class="fas fa-trash"></i> ‡∏•‡∏ö</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-1">
                    <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Phonetic):</label><input type="text" class="w-full p-1 border rounded text-sm dialect-phonetic font-mono" value="${dialectForm.phonetic || ''}"></div>
                    <div><label class="text-xs">‡∏£‡∏π‡∏õ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô (Orthographic):</label><input type="text" class="w-full p-1 border rounded text-sm dialect-orthographic font-mono" value="${dialectForm.orthographic || ''}"></div>
                </div>
                <div><label class="text-xs mt-1">‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢ (‡∏ñ‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô):</label><input type="text" class="w-full p-1 border rounded text-sm dialect-meaning" value="${dialectForm.meaning_diff || ''}"></div>
            </div>`;
        }

        window.generateDialectFormForRegionInModal = (wordId, formEntryIndex) => {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            if (!word) return;

            const formEntryDiv = genericModalContent.querySelectorAll('.dialect-form-entry')[formEntryIndex];
            if (!formEntryDiv) return;

            const regionName = formEntryDiv.querySelector('.dialect-region').value;
            if (!regionName) { alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ"); return; }

            const rules = currentLanguage.dialectSoundChanges[regionName] || [];
            const basePhonetic = word.word; 

            if (!basePhonetic) {
                alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ");
                return;
            }

            const generatedPhonetic = applyDialectSoundChanges(basePhonetic, rules);
            const generatedOrthographic = transliterateWordToSymbols(generatedPhonetic);

            formEntryDiv.querySelector('.dialect-phonetic').value = generatedPhonetic;
            formEntryDiv.querySelector('.dialect-orthographic').value = generatedOrthographic;
        };

        function attachDialectFormListeners(wordId) {
            const word = currentLanguage.lexicon.find(w => w.id === wordId);
            document.querySelectorAll('.remove-dialect-form-btn').forEach(btn => {
                const newBtn = btn.cloneNode(true); 
                btn.parentNode.replaceChild(newBtn, btn);

                newBtn.onclick = (e) => {
                    e.stopPropagation(); 
                    const indexToRemove = parseInt(e.currentTarget.dataset.index);
                    if (word && word.dialectalForms && word.dialectalForms[indexToRemove] !== undefined) {
                        word.dialectalForms.splice(indexToRemove, 1);
                        
                        const formsContainer = document.getElementById('dialectFormsContainerModal'); 
                        if (formsContainer) {
                            formsContainer.innerHTML = '';
                            word.dialectalForms.forEach((df, idx) => { 
                                formsContainer.innerHTML += renderDialectFormEntry(df, idx, wordId);
                            });
                            attachDialectFormListeners(wordId); 
                        }
                    }
                };
            });

            genericModalContent.querySelectorAll('.dialect-form-entry').forEach((entryDiv, index) => {
                const regionSelect = entryDiv.querySelector('.dialect-region');
                if(regionSelect && word && word.dialectalForms[index]) {
                    regionSelect.onchange = (e) => {
                         if(word.dialectalForms[index]) word.dialectalForms[index].regionName = e.target.value;
                    };
                }
            });
        }

        function renderLangFamilyUI(container) {
            currentLanguage.languageFamily = currentLanguage.languageFamily || { externalNodes: [] };
            currentLanguage.languageFamily.externalNodes = currentLanguage.languageFamily.externalNodes || [];

            const langFamilyContainerId = 'langFamilyTabSpecificContent';
            let langFamilyContainer = container.querySelector(`#${langFamilyContainerId}`);
            if(!langFamilyContainer){
                langFamilyContainer = document.createElement('div');
                langFamilyContainer.id = langFamilyContainerId;
                container.appendChild(langFamilyContainer);
            }
            langFamilyContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-pink-200 rounded-md bg-pink-50 space-y-4';
            
            const externalNodesSection = document.createElement('div');
            externalNodesSection.innerHTML = `<h4 class="font-semibold text-pink-700 mb-2">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å (External Languages/Proto-Languages)</h4>`;
            const extNodesList = document.createElement('div');
            extNodesList.id = 'externalLangNodesListLangFamily';
            extNodesList.className = 'max-h-40 overflow-y-auto space-y-1';
            (currentLanguage.languageFamily.externalNodes).forEach(extNode => {
                extNodesList.innerHTML += `
                    <div class="flex items-center justify-between p-2 mb-1 border rounded bg-white text-sm">
                            fetch('https:(extNode.parentId) || 'N/A'})</span>
                        <div>
                            <button class="text-xs text-blue-500 hover:text-blue-700 mr-1" onclick="editExternalLangNode('${extNode.id}')">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                            <button class="text-xs text-red-500 hover:text-red-700" onclick="removeExternalLangNode('${extNode.id}')">‡∏•‡∏ö</button>
                        </div>
                    </div>`;
            });
            externalNodesSection.appendChild(extNodesList);
            externalNodesSection.innerHTML += `
                <div class="flex gap-2 mt-2 items-end p-2 border-t flex-wrap">
                    <input type="text" id="newExternalNodeNameLangFamily" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å" class="p-1 border rounded text-sm flex-grow min-w-[150px]">
                    <select id="newExternalNodeParentLangFamily" class="p-1 border rounded text-sm flex-grow min-w-[150px]"></select>
                    <button id="addExternalNodeBtnLangFamily" class="btn-secondary bg-pink-400 px-2 py-1 rounded text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å</button>
                </div>
            `;
            section.appendChild(externalNodesSection);


            section.innerHTML += `
                <h4 class="font-semibold text-pink-700 mt-4 pt-3 border-t border-pink-200 mb-2">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á</h4>
                <div id="langFamilyConfigArea" class="mb-4 p-2 bg-white rounded shadow"></div>
                <h4 class="font-semibold text-pink-700">‡∏ú‡∏±‡∏á‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤ (Language Family Tree):</h4>
                <div id="langFamilyTreeContainer" class="pedigree-chart p-2 bg-white rounded shadow min-h-[150px] max-h-[500px] overflow-auto">
                    <p class="text-center text-gray-400">‡∏ú‡∏±‡∏á‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏°‡πà</p>
                </div>`;
            langFamilyContainer.appendChild(section);
            
            populateParentSelectForExternalNode('newExternalNodeParentLangFamily');
            document.getElementById('addExternalNodeBtnLangFamily').addEventListener('click', addExternalLangNode);

            renderLanguageFamilyConfig(); 
            renderLanguageFamilyTree();
        }

        function getParentNameForNode(parentId) {
            if (!parentId) return null;
            const conlangParent = allLanguages.find(l => l.name === parentId);
            if (conlangParent) return conlangParent.name;
            const externalParent = currentLanguage.languageFamily.externalNodes.find(n => n.id === parentId);
            if (externalParent) return externalParent.name;
            return parentId; 
        }
        
        function populateParentSelectForExternalNode(selectElementId, currentExtNodeIdToExclude = null) {
            const select = document.getElementById(selectElementId);
            if (!select) return;
            select.innerHTML = '<option value="">-- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏°‡πà (‡∏£‡∏≤‡∏Å) --</option>';
            allLanguages.forEach(lang => {
                 select.innerHTML += `<option value="${lang.name}">${lang.name} (Conlang)</option>`;
            });
            currentLanguage.languageFamily.externalNodes.forEach(extNode => {
                if (extNode.id !== currentExtNodeIdToExclude) { 
                    select.innerHTML += `<option value="${extNode.id}">${extNode.name} (External)</option>`;
                }
            });
        }

        function addExternalLangNode() {
            const nameInput = document.getElementById('newExternalNodeNameLangFamily');
            const parentSelect = document.getElementById('newExternalNodeParentLangFamily');
            const name = nameInput.value.trim();
            const parentId = parentSelect.value || null;

            if (name) {
                if (currentLanguage.languageFamily.externalNodes.some(n => n.name.toLowerCase() === name.toLowerCase()) || allLanguages.some(l => l.name.toLowerCase() === name.toLowerCase())) {
                    alert(`‡∏ä‡∏∑‡πà‡∏≠ "${name}" ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å)`);
                    return;
                }
                const newNodeId = `ext_${nextExternalNodeId++}`;
                currentLanguage.languageFamily.externalNodes.push({ id: newNodeId, name, parentId });
                nameInput.value = '';
                parentSelect.value = '';
                renderLangFamilyUI(tabContentContainer); 
                saveData();
            } else {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å');
            }
        }
        window.editExternalLangNode = (nodeId) => {
            alert(`‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏©‡∏≤‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å (ID: ${nodeId}) ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏±‡∏í‡∏ô‡∏≤`);
        }

        window.removeExternalLangNode = (nodeId) => {
            currentLanguage.languageFamily.externalNodes = currentLanguage.languageFamily.externalNodes.filter(n => n.id !== nodeId);
            allLanguages.forEach(lang => {
                if (lang.parentLangName === nodeId) lang.parentLangName = null;
            });
            currentLanguage.languageFamily.externalNodes.forEach(extNode => {
                if (extNode.parentId === nodeId) extNode.parentId = null;
            });
            renderLangFamilyUI(tabContentContainer);
            saveData();
        };

        function renderLanguageFamilyConfig() { 
            const configArea = document.getElementById('langFamilyConfigArea');
             if(!configArea) return; 
            configArea.innerHTML = '';
            allLanguages.forEach(lang => {
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 mb-1 border rounded bg-gray-50 text-sm';
                const label = document.createElement('span');
                label.textContent = `${lang.name}: ‡∏†‡∏≤‡∏©‡∏≤‡πÅ‡∏°‡πà (Parent) -> `;
                const select = document.createElement('select');
                select.className = 'p-1 border rounded text-sm parent-lang-select-for-conlang';
                select.dataset.conlangName = lang.name;
                select.innerHTML = '<option value="">-- ‡πÑ‡∏°‡πà‡∏°‡∏µ --</option>';
                
                allLanguages.filter(l => l.name !== lang.name).forEach(parentOption => { 
                    select.innerHTML += `<option value="${parentOption.name}" ${lang.parentLangName === parentOption.name ? 'selected' : ''}>${parentOption.name} (Conlang)</option>`;
                });
                (currentLanguage.languageFamily.externalNodes || []).forEach(extNode => {
                     select.innerHTML += `<option value="${extNode.id}" ${lang.parentLangName === extNode.id ? 'selected' : ''}>${extNode.name} (External)</option>`;
                });

                select.onchange = (e) => {
                    const targetLang = allLanguages.find(l => l.name === e.target.dataset.conlangName);
                    if (targetLang) {
                        targetLang.parentLangName = e.target.value || null; 
                        saveData(); 
                        renderLanguageFamilyTree(); 
                    }
                };
                div.appendChild(label);
                div.appendChild(select);
                configArea.appendChild(div);
            });
        }

        function renderLanguageFamilyTree() {
            const treeContainer = document.getElementById('langFamilyTreeContainer');
            if (!treeContainer) return;
            treeContainer.innerHTML = '';
        
            const allNodes = [
                ...allLanguages.map(l => ({ id: l.name, name: l.name, parentId: l.parentLangName, type: 'conlang' })),
                ...(currentLanguage.languageFamily.externalNodes || []).map(n => ({ ...n, type: 'external' }))
            ];
        
            const roots = allNodes.filter(node => !node.parentId || !allNodes.some(potentialParent => potentialParent.id === node.parentId));
        
            if (roots.length === 0 && allNodes.length > 0) {
                treeContainer.innerHTML = '<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏Å‡∏Ç‡∏≠‡∏á‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏• ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏ß‡∏ô‡∏ã‡πâ‡∏≥</p>';
                allNodes.forEach(node => treeContainer.appendChild(buildLangFamilyNodeRecursive(node, allNodes, new Set())));
                return;
            }
            roots.forEach(rootNode => {
                treeContainer.appendChild(buildLangFamilyNodeRecursive(rootNode, allNodes, new Set()));
            });
            if (treeContainer.children.length === 0) {
                treeContainer.innerHTML = '<p class="text-center text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏©‡∏≤‡πÉ‡∏î‡πÜ</p>';
            }
        }
        
        function buildLangFamilyNodeRecursive(node, allNodes, visited) {
            if (visited.has(node.id)) { 
                const li = document.createElement('li');
                li.innerHTML = `<span class="pedigree-node italic text-xs text-red-500">‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏ã‡πâ‡∏≥ (Cycle): ${node.name}</span>`;
                const ul = document.createElement('ul');
                ul.appendChild(li);
                return ul;
            }
            visited.add(node.id);
        
            const ul = document.createElement('ul');
            const li = document.createElement('li');
            const nodeClass = node.type === 'external' ? 'pedigree-node external-node' : 'pedigree-node';
            li.innerHTML = `<span class="${nodeClass} font-semibold">${node.name}</span>`;
        
            const children = allNodes.filter(childNode => childNode.parentId === node.id);
            if (children.length > 0) {
                const childrenUl = document.createElement('ul');
                children.forEach(childNode => {
                    childrenUl.appendChild(buildLangFamilyNodeRecursive(childNode, allNodes, new Set(visited))); 
                });
                li.appendChild(childrenUl);
            }
            ul.appendChild(li);
            return ul;
        }
        
        function renderSoundChangesInterLangUI(container) {
            const soundChangesContainerId = 'soundChangesTabSpecificContent';
            let soundChangesContainer = container.querySelector(`#${soundChangesContainerId}`);
            if(!soundChangesContainer){
                soundChangesContainer = document.createElement('div');
                soundChangesContainer.id = soundChangesContainerId;
                container.appendChild(soundChangesContainer);
            }
            soundChangesContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-orange-200 rounded-md bg-orange-50 space-y-4';
            
            section.innerHTML = `
                <p class="text-sm text-gray-600">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏£‡∏π‡∏õ‡∏≠‡∏±‡∏Å‡∏©‡∏£ ‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏´‡∏ô‡∏∂‡πà‡∏á (‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á) ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏´‡∏ô‡∏∂‡πà‡∏á (‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á) ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="sourceLangSelectSC" class="block text-sm font-medium text-orange-700">‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (Source):</label>
                        <select id="sourceLangSelectSC" class="w-full p-2 border rounded-md"></select>
                    </div>
                    <div>
                        <label for="targetLangSelectSC" class="block text-sm font-medium text-orange-700">‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á (Target):</label>
                        <select id="targetLangSelectSC" class="w-full p-2 border rounded-md"></select>
                    </div>
                </div>
                <div id="interLangRulesDisplayAreaSC" class="p-3 bg-white rounded shadow">
                    <h4 class="font-semibold text-orange-700 mb-2">‡∏ä‡∏∏‡∏î‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å):</h4>
                    <div id="currentInterLangRulesListSC" class="text-sm space-y-1 mb-2"></div>
                    <div class="flex gap-2 items-end flex-wrap border-t pt-2 mt-2">
                        <input type="text" id="interLangRuleFromSC" placeholder="‡∏à‡∏≤‡∏Å (‡πÄ‡∏ä‡πà‡∏ô p)" class="p-1 border rounded text-sm w-24">
                        <input type="text" id="interLangRuleToSC" placeholder="‡πÄ‡∏õ‡πá‡∏ô (‡πÄ‡∏ä‡πà‡∏ô f)" class="p-1 border rounded text-sm w-24">
                        <input type="text" id="interLangRuleContextSC" placeholder="‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÄ‡∏ä‡πà‡∏ô V_V, #_)" class="p-1 border rounded text-sm flex-grow">
                        <input type="text" id="interLangRuleDescSC" placeholder="‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢" class="p-1 border rounded text-sm flex-grow">
                        <button id="addInterLangRuleBtnSC" class="btn-secondary bg-orange-400 text-sm px-2 py-1 rounded">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                    </div>
                </div>
                <div class="mt-4 p-3 bg-white rounded shadow">
                    <h4 class="font-semibold text-orange-700 mb-2">‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏é:</h4>
                    <label for="sourceWordInputSC" class="block text-sm">‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡∏£‡∏π‡∏õ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á):</label>
                    <input type="text" id="sourceWordInputSC" class="w-full p-2 border rounded-md mb-2">
                    <button id="applyInterLangRulesBtnSC" class="btn-primary bg-orange-500 text-sm px-3 py-1 rounded">‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡∏Å‡∏é</button>
                    <p class="mt-2"><strong>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á:</strong> <span id="targetWordOutputSC" class="font-mono"></span></p>
                </div>
            `;
            soundChangesContainer.appendChild(section);

            const sourceSelect = section.querySelector('#sourceLangSelectSC');
            const targetSelect = section.querySelector('#targetLangSelectSC');
            sourceSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>';
            targetSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤ --</option>';
            allLanguages.forEach(lang => {
                sourceSelect.innerHTML += `<option value="${lang.name}">${lang.name}</option>`;
                targetSelect.innerHTML += `<option value="${lang.name}">${lang.name}</option>`;
            });

            sourceSelect.addEventListener('change', renderInterLangRulesForPair);
            targetSelect.addEventListener('change', renderInterLangRulesForPair);
            document.getElementById('addInterLangRuleBtnSC').addEventListener('click', addInterLangRule);
            document.getElementById('applyInterLangRulesBtnSC').addEventListener('click', applyInterLangRulesTest);
            renderInterLangRulesForPair(); 
        }

        function getActiveInterLangPair() {
            const sourceLangName = document.getElementById('sourceLangSelectSC')?.value;
            const targetLangName = document.getElementById('targetLangSelectSC')?.value;
            if (!sourceLangName || !targetLangName || sourceLangName === targetLangName) return null;
            
            return globalInterLangRules.find(p => p.sourceLangName === sourceLangName && p.targetLangName === targetLangName);
        }
        
        function renderInterLangRulesForPair() {
            const rulesListDiv = document.getElementById('currentInterLangRulesListSC');
            if (!rulesListDiv) return; 
            rulesListDiv.innerHTML = '<p class="text-xs text-gray-400">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏é</p>';
            
            const pair = getActiveInterLangPair();
            if (pair && pair.rules) {
                rulesListDiv.innerHTML = ''; 
                if (pair.rules.length === 0) {
                    rulesListDiv.innerHTML = '<p class="text-xs text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ</p>';
                }
                pair.rules.forEach((rule, index) => {
                    rulesListDiv.innerHTML += `
                        <div class="flex justify-between items-center p-1 border-b">
                            <span>'${rule.from}' <i class="fas fa-arrow-right mx-1"></i> '${rule.to}' ${rule.context ? `(${rule.context})` : ''} ${rule.description ? `- ${rule.description}` : ''}</span>
                            <button class="text-xs text-red-400 hover:text-red-600" onclick="removeInterLangRule(${index})">&times;</button>
                        </div>`;
                });
            }
        }

        function addInterLangRule() {
            const sourceLangName = document.getElementById('sourceLangSelectSC').value;
            const targetLangName = document.getElementById('targetLangSelectSC').value;

            if (!sourceLangName || !targetLangName) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á"); return;
            }
            if (sourceLangName === targetLangName) {
                alert("‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô"); return;
            }

            const from = document.getElementById('interLangRuleFromSC').value.trim();
            const to = document.getElementById('interLangRuleToSC').value.trim(); 
            const context = document.getElementById('interLangRuleContextSC').value.trim();
            const description = document.getElementById('interLangRuleDescSC').value.trim();

            if (!from) { alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å '‡∏à‡∏≤‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏≠‡∏±‡∏Å‡∏©‡∏£'"); return; }

            let pair = globalInterLangRules.find(p => p.sourceLangName === sourceLangName && p.targetLangName === targetLangName);
            if (!pair) {
                const pairId = `il_pair_${nextInterLangPairId++}`; 
                pair = { id: pairId, sourceLangName, targetLangName, rules: [] };
                globalInterLangRules.push(pair);
            }
            
            pair.rules.push({ from, to, context, description });
            saveData(); 
            renderInterLangRulesForPair();

            document.getElementById('interLangRuleFromSC').value = '';
            document.getElementById('interLangRuleToSC').value = '';
            document.getElementById('interLangRuleContextSC').value = '';
            document.getElementById('interLangRuleDescSC').value = '';
        }

        window.removeInterLangRule = (ruleIndex) => {
            const pair = getActiveInterLangPair();
            if (pair && pair.rules && pair.rules[ruleIndex] !== undefined) {
                pair.rules.splice(ruleIndex, 1);
                saveData();
                renderInterLangRulesForPair();
            }
        };

        function applyInterLangRulesTest() {
            const sourceWord = document.getElementById('sourceWordInputSC').value.trim();
            const targetOutputSpan = document.getElementById('targetWordOutputSC');
            if (!sourceWord) { targetOutputSpan.textContent = "(‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥)"; return; }

            const pair = getActiveInterLangPair();
            if (!pair || !pair.rules || pair.rules.length === 0) {
                targetOutputSpan.textContent = "(‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡πà‡∏†‡∏≤‡∏©‡∏≤)";
                return;
            }

            let changedWord = sourceWord;
            pair.rules.forEach(rule => {
                try {
                    const regexPattern = rule.context ? 
                        convertContextToRegex(rule.from, rule.context) : 
                        new RegExp(rule.from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'); 

                    changedWord = changedWord.replace(regexPattern, rule.to);
                } catch (e) {
                    console.warn(`Error applying rule: From "${rule.from}", To "${rule.to}", Context "${rule.context}". Error: ${e.message}`);
                }
            });
            targetOutputSpan.textContent = changedWord;
        }

        function convertContextToRegex(from, contextStr) {
            const V = '[aeiouAEIOU√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√ø]'; 
            const C = '[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]'; 

            let pattern = from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
            
            if (contextStr.startsWith('#_')) { 
                pattern = '^' + pattern;
                contextStr = contextStr.substring(2); 
            }
            if (contextStr.endsWith('_#')) { 
                pattern = pattern + '$';
                contextStr = contextStr.substring(0, contextStr.length - 2); 
            }
            if (contextStr === 'V_V') {
                return new RegExp(`(?<=${V})${pattern}(?=${V})`, 'g');
            }
             if (contextStr.startsWith('C_')) {
                pattern = `(?<=${C})${pattern}`;
                contextStr = contextStr.substring(2);
            }
            if (contextStr.endsWith('_C')) {
                pattern = `${pattern}(?=${C})`;
                contextStr = contextStr.substring(0, contextStr.length-2);
            }
            return new RegExp(pattern, 'g');
        }

        function renderToolsUI(container) {
            const toolsContainerId = 'toolsTabSpecificContent';
            let toolsContainer = container.querySelector(`#${toolsContainerId}`);
            if(!toolsContainer){
                toolsContainer = document.createElement('div');
                toolsContainer.id = toolsContainerId;
                container.appendChild(toolsContainer);
            }
            toolsContainer.innerHTML = '';

            const section = document.createElement('div');
            section.className = 'p-3 border border-gray-300 rounded-md bg-gray-100 space-y-6';

            const translatorSection = document.createElement('div');
            translatorSection.className = 'p-3 bg-white rounded shadow';
            translatorSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üåç ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤ (‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢)</h4>
                <textarea id="translatorInputTools" class="w-full p-2 border rounded-md mb-2" rows="3" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© ‡∏´‡∏£‡∏∑‡∏≠ ‡πÑ‡∏ó‡∏¢) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•..."></textarea>
                <div class="flex gap-2 mb-2 items-center">
                    <select id="translateFromLangTools" class="p-2 border rounded-md">
                        <option value="th">‡πÑ‡∏ó‡∏¢</option><option value="en">‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©</option>
                    </select>
                    <span> <i class="fas fa-arrow-right mx-1"></i> <strong id="translatorTargetLangNameTools">${transliterateWordToSymbols(currentLanguage.name || '‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì')}</strong></span>
                </div>
                <button id="translateButtonTools" class="btn-primary bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded-md text-sm">‡πÅ‡∏õ‡∏•</button>
                <div class="mt-2"><strong>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:</strong><p id="translatorOutputTools" class="p-2 bg-gray-50 rounded border min-h-[40px]"></p></div>`;
            section.appendChild(translatorSection);

             const nameGenSection = document.createElement('div');
             nameGenSection.className = 'p-3 bg-white rounded shadow';
             nameGenSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üë§üó∫Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠ (‡∏Ñ‡∏ô, ‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà)</h4>
                <div class="flex gap-2 mb-2 items-center flex-wrap">
                    <label for="nameTypeSelectTools" class="text-sm">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</label>
                    <select id="nameTypeSelectTools" class="p-1 border rounded-md text-sm"><option value="person">‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏ô</option><option value="place">‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà</option></select>
                    <label for="numNamesToGenerateTools" class="text-sm ml-2">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô:</label>
                    <input type="number" id="numNamesToGenerateTools" value="3" min="1" max="10" class="w-16 p-1 border rounded-md text-sm">
                    <button id="generateNamesButtonTools" class="btn-primary bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded-md text-sm">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠</button>
                </div>
                <ul id="generatedNamesListTools" class="list-disc list-inside text-sm min-h-[40px] p-2 bg-gray-50 rounded border"></ul>`;
            section.appendChild(nameGenSection);

            const sentenceGenSection = document.createElement('div');
            sentenceGenSection.className = 'p-3 bg-white rounded shadow';
            sentenceGenSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üìù ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</h4>
                <div><label class="text-sm">‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ:</label> <select id="sentenceStructureForGenTools" class="p-1 border rounded text-sm"></select></div>
                <button id="generateSentenceBtnTools" class="btn-primary bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded-md text-sm my-2">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ</button>
                <div class="mt-1">
                    <label class="text-sm">‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á (<span class="font-mono">${transliterateWordToSymbols(currentLanguage.name || '‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì')}</span>):</label>
                    <textarea id="generatedConlangSentenceTools" class="w-full p-1 border rounded text-sm" rows="2" readonly></textarea>
                </div>
                <div class="mt-1">
                    <label class="text-sm">‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì):</label>
                    <textarea id="generatedThaiTranslationTools" class="w-full p-1 border rounded text-sm" rows="2" readonly></textarea>
                </div>`;
            section.appendChild(sentenceGenSection);

            const dataMgmtSection = document.createElement('div');
            dataMgmtSection.className = 'p-3 bg-white rounded shadow';
            dataMgmtSection.innerHTML = `
                <h4 class="font-semibold text-gray-700 mb-2">üíæ ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Import/Export)</h4>
                <div class="flex flex-wrap gap-2">
                    <button id="exportCurrentLangBtnTools" class="btn-secondary text-sm"><i class="fas fa-download mr-1"></i>Export ‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (JSON)</button>
                    <button id="exportAllLangsBtnTools" class="btn-secondary text-sm"><i class="fas fa-archive mr-1"></i>Export ‡∏ó‡∏∏‡∏Å‡∏†‡∏≤‡∏©‡∏≤ (JSON)</button>
                    <div>
                        <label for="importAllLangsFileTools" class="btn-secondary text-sm cursor-pointer"><i class="fas fa-upload mr-1"></i>Import ‡∏ó‡∏∏‡∏Å‡∏†‡∏≤‡∏©‡∏≤ (JSON)</label>
                        <input type="file" id="importAllLangsFileTools" class="hidden" accept=".json">
                    </div>
                </div>
                <p class="text-xs text-gray-500 mt-1">‡∏Å‡∏≤‡∏£ Import ‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà</p>`;
            section.appendChild(dataMgmtSection);

            toolsContainer.appendChild(section);

            document.getElementById('translatorTargetLangNameTools').textContent = transliterateWordToSymbols(currentLanguage.name || '‡∏†‡∏≤‡∏©‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì');
            document.getElementById('translateButtonTools').addEventListener('click', translateText);
            document.getElementById('generateNamesButtonTools').addEventListener('click', generateNames);

            const sentenceStructSelect = document.getElementById('sentenceStructureForGenTools');
            sentenceStructSelect.innerHTML = ''; 
            ['SVO', 'SOV', 'VSO', 'VOS', 'OSV', 'OVS'].forEach(s => sentenceStructSelect.innerHTML += `<option value="${s}" ${s === currentLanguage.grammar.sentenceStructure ? 'selected' : ''}>${s}</option>`);
            sentenceStructSelect.value = currentLanguage.grammar.sentenceStructure; 
            document.getElementById('generateSentenceBtnTools').addEventListener('click', generateSentence);

            document.getElementById('exportCurrentLangBtnTools')?.addEventListener('click', () => {
                exportDataAsJSON(currentLanguage, `${currentLanguage.name || 'current_language'}_data.json`);
            });
            document.getElementById('exportAllLangsBtnTools')?.addEventListener('click', () => {
                const dataToExport = {
                    allLanguages: allLanguages,
                    globalInterLangRules: globalInterLangRules
                };
                exportDataAsJSON(dataToExport, 'all_languages_and_rules_backup.json');
            });
            document.getElementById('importAllLangsFileTools')?.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const imported = JSON.parse(e.target.result);
                            if (imported.allLanguages && Array.isArray(imported.allLanguages)) {
                                allLanguages = imported.allLanguages;
                            }
                            if (imported.globalInterLangRules && Array.isArray(imported.globalInterLangRules)) {
                                globalInterLangRules = imported.globalInterLangRules;
                            }
                            // Optionally, update currentLanguage to the first language or keep as is
                            if (allLanguages.length > 0) {
                                currentLanguage = allLanguages[0];
                            }
                            saveData();
                            alert('‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
                            // Optionally, re-render UI if needed
                            location.reload();
                        } catch (err) {
                            alert('‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤');
                        }
                    };
                    reader.readAsText(file);
                    event.target.value = null;
                }
            });
        }

        function translateText() { 
            const input = document.getElementById('translatorInputTools').value.toLowerCase().trim();
            const fromLang = document.getElementById('translateFromLangTools').value; 
            const outputP = document.getElementById('translatorOutputTools');
            if (!input) { outputP.textContent = ''; return; }

            let translatedText = '';
            const wordsToTranslate = input.split(/\s+/);
            wordsToTranslate.forEach(wordToTranslate => {
                let foundEntry = null;
                if (fromLang === 'th') { 
                    foundEntry = currentLanguage.lexicon.find(entry => entry.meaning.toLowerCase() === wordToTranslate);
                } else if (fromLang === 'en') { 
                     foundEntry = currentLanguage.lexicon.find(entry =>
                        (entry.synonyms && entry.synonyms.some(s => s.toLowerCase() === wordToTranslate)) ||
                        entry.meaning.toLowerCase().includes(wordToTranslate) 
                    );
                }
                if (foundEntry) {
                    translatedText += (fromLang === 'th' || fromLang === 'en' ? transliterateWordToSymbols(foundEntry.word) : foundEntry.meaning) + ' ';
                } else {
                    translatedText += `(${wordToTranslate}?) `; 
                }
            });
            outputP.textContent = translatedText.trim();
        }

        function generateNames() { 
            const nameType = document.getElementById('nameTypeSelectTools').value;
            const numNames = parseInt(document.getElementById('numNamesToGenerateTools').value);
            const listElement = document.getElementById('generatedNamesListTools');
            listElement.innerHTML = '';

            if (currentLanguage.phonology.consonants.length === 0 || currentLanguage.phonology.vowels.length === 0) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∞‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô"); return;
            }
            for (let i = 0; i < numNames; i++) {
                const numSyll = (nameType === 'person') ? Math.floor(Math.random() * 2) + 2 : Math.floor(Math.random() * 3) + 2;  
                let nameForm = '';
                for (let j = 0; j < numSyll; j++) { nameForm += generateSyllable(); }
                nameForm = nameForm.charAt(0).toUpperCase() + nameForm.slice(1); 
                const displayName = transliterateWordToSymbols(nameForm);
                listElement.innerHTML += `<li class="text-sm">${displayName} <span class="text-xs text-gray-400">(${nameForm})</span></li>`;
            }
        }

        function generateSentence() {
            const structure = document.getElementById('sentenceStructureForGenTools').value;
            const conlangOutput = document.getElementById('generatedConlangSentenceTools');
            const thaiOutput = document.getElementById('generatedThaiTranslationTools');

            if (currentLanguage.lexicon.length === 0) {
                conlangOutput.value = "(‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤)";
                thaiOutput.value = ""; return;
            }

            let conlangSentence = [];
            let thaiSentence = [];

            const getWordByPOS = (targetPOS) => {
                let candidates = currentLanguage.lexicon.filter(w => w.partOfSpeech.toLowerCase() === targetPOS.toLowerCase());
                if (candidates.length === 0) {
                    candidates = currentLanguage.lexicon.filter(w => w.partOfSpeech.toLowerCase().startsWith(targetPOS.toLowerCase()));
                }
                 if (candidates.length === 0 && targetPOS.toLowerCase() === '‡∏ô‡∏≤‡∏°') { 
                    candidates = currentLanguage.lexicon;
                }
                if (candidates.length === 0 && targetPOS.toLowerCase() === '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤') { 
                    candidates = currentLanguage.lexicon;
                }
                if (candidates.length > 0) return candidates[Math.floor(Math.random() * candidates.length)];
                return null; 
            };

            for (const part of structure) { 
                let wordEntry = null;
                if (part === 'S' || part === 'O') wordEntry = getWordByPOS('‡∏ô‡∏≤‡∏°');
                else if (part === 'V') wordEntry = getWordByPOS('‡∏Å‡∏£‡∏¥‡∏¢‡∏≤');
                
                if (wordEntry) {
                    let wordForm = wordEntry.word;
                    conlangSentence.push(transliterateWordToSymbols(wordForm));
                    thaiSentence.push(wordEntry.meaning);
                } else {
                    conlangSentence.push(`(${part}?)`); 
                    thaiSentence.push(`(${part}?)`);
                }
            }
            conlangOutput.value = conlangSentence.join(' ');
            thaiOutput.value = thaiSentence.join(' ');
        }

        // ========== Begin Sentence System Implementation ==========
        /**
         * Compute the inflected phonetic and orthographic form of a word given a set
         * of selected inflection options.  This helper examines all defined
         * conjugation categories in the order they are declared and applies any
         * manual overrides or inflection rules that match the selected option.  If
         * no rule is found for a particular category the base form is preserved.
         *
         * @param {Object} wordEntry The dictionary entry for the base word.
         * @param {Object} selectedOptions An object mapping categoryId -> option.
         * @returns {Object} An object with `phonetic` (string) and `orthographic` (string) properties.
         */
        function computeInflectedForms(wordEntry, selectedOptions = {}) {
            if (!wordEntry) return { phonetic: '', orthographic: '' };
            let currentPhonetic = wordEntry.word;
            const categories = (currentLanguage.grammar && currentLanguage.grammar.morphology && currentLanguage.grammar.morphology.conjugationCategories) || [];
            categories.forEach(cat => {
                const opt = selectedOptions && selectedOptions.hasOwnProperty(cat.id) ? selectedOptions[cat.id] : null;
                if (!opt) return;
                // Check for manual override on the word entry first
                const key = cat.id + '_' + opt.replace(/\s+/g, '_');
                if (wordEntry.manualInflections && wordEntry.manualInflections[key] && wordEntry.manualInflections[key].phonetic) {
                    currentPhonetic = wordEntry.manualInflections[key].phonetic;
                    return;
                }
                // Otherwise try to find a matching inflection rule
                const rule = ((currentLanguage.grammar && currentLanguage.grammar.morphology && currentLanguage.grammar.morphology.conjugationRules) || []).find(r => {
                    return r.categoryId === cat.id && r.categoryOption === opt && (
                        r.partOfSpeech === wordEntry.partOfSpeech || (wordEntry.partOfSpeech && wordEntry.partOfSpeech.startsWith(r.partOfSpeech + ':'))
                    );
                });
                if (rule) {
                    currentPhonetic = applyInflectionRuleDefinition(currentPhonetic, rule);
                }
            });
            const orthographic = getOrthographicForm({ word: currentPhonetic, customOrthography: null }, true, true);
            return { phonetic: currentPhonetic, orthographic: orthographic };
        }

        /**
         * Render the Sentence System tab.  This UI allows users to build sentences
         * manually by selecting a sentence structure (e.g. SVO), choosing words
         * from the lexicon for each role, optionally selecting inflection options
         * for those words, and then generating the resulting sentence in the
         * constructed language and Thai translation.  Users can save completed
         * sentences for future reference.  If `editId` is provided, the builder
         * will prepopulate itself with the saved sentence associated with that ID.
         *
         * @param {HTMLElement} container The tab content container where UI elements will be appended.
         * @param {String|null} editId Optional ID of an existing sentence to load into the builder.
         */
        function renderSentenceUI(container, editId = null) {
            // Ensure sentences array exists on the current language
            if (!Array.isArray(currentLanguage.sentences)) {
                currentLanguage.sentences = [];
            }
            // Update nextSentenceId based on existing sentences to avoid ID collisions
            currentLanguage.sentences.forEach(s => {
                if (s && typeof s.id === 'string' && s.id.startsWith('sent_')) {
                    const num = parseInt(s.id.slice(5));
                    if (!isNaN(num) && num >= nextSentenceId) {
                        nextSentenceId = num + 1;
                    }
                }
            });
            // Clear the container to prepare new content
            container.innerHTML = '';
            const section = document.createElement('div');
            section.className = 'space-y-4 p-3 border border-indigo-200 rounded-md bg-indigo-50';
            section.innerHTML = `
                <h3 class="text-lg font-semibold text-indigo-700">‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ</h3>
                <div class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                    <label class="text-sm font-medium text-indigo-700">‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ:</label>
                    <select id="sentenceStructureSelect" class="p-2 border border-indigo-300 rounded-md text-sm flex-grow sm:flex-none"></select>
                    <button id="randomFillSentenceBtn" class="btn-secondary bg-indigo-400 hover:bg-indigo-500 px-3 py-1 rounded-md text-sm whitespace-nowrap">‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡∏≥</button>
                </div>
                <div id="sentenceBuilderFields" class="mt-2 space-y-3"></div>
                <div class="flex flex-wrap gap-2 mt-3">
                    <button id="buildSentenceBtn" class="btn-primary bg-indigo-600 hover:bg-indigo-700 px-3 py-2 rounded-md text-sm disabled:opacity-50" disabled>‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ</button>
                    <button id="saveSentenceBtn" class="btn-primary bg-indigo-600 hover:bg-indigo-700 px-3 py-2 rounded-md text-sm disabled:opacity-50" disabled>‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ</button>
                </div>
                <div id="sentenceOutputArea" class="mt-3 p-3 bg-white rounded shadow hidden">
                    <div class="mb-1"><strong class="text-indigo-700">‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ (‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏ß‡∏¥‡∏ò‡∏µ):</strong> <span id="sentenceOutputOrtho" class="font-mono"></span></div>
                    <div class="mb-1 flex items-center"><strong class="text-indigo-700 mr-1">‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ (‡∏™‡∏±‡∏ó‡∏≠‡∏±‡∏Å‡∏©‡∏£):</strong> <div id="sentenceOutputPhoneticContainer" class="inline-flex items-center" data-phonetic=""><span id="sentenceOutputPhonetic" class="font-mono"></span><button type="button" class="text-blue-500 ml-1 dialect-phonetics-btn" title="‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"><i class="fas fa-headphones"></i></button></div></div>
                    <div><strong class="text-indigo-700">‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•:</strong> <input id="sentenceOutputMeaning" class="p-1 border border-indigo-300 rounded-md w-full mt-1 text-sm" /></div>
                </div>
                <div id="savedSentencesContainer" class="mt-4"></div>
            `;
            container.appendChild(section);
            // Builder state tracks the current structure, selections and last built sentence.
            // In addition to the default fields we track whether the verb is intransitive
            // (so that the object can be omitted).  Modifier selections (subject/object
            // adjectives and adverbs) are now stored on each role rather than globally.
            const builderState = {
                structure: (currentLanguage.grammar && currentLanguage.grammar.sentenceStructure) ? currentLanguage.grammar.sentenceStructure : 'SVO',
                roles: [],
                lastBuilt: null,
                verbIsIntransitive: false
            };
            // Populate the structure dropdown with standard options and set current selection
            const structSelect = section.querySelector('#sentenceStructureSelect');
            if (structSelect) {
                structSelect.innerHTML = '';
                ['SVO','SOV','VSO','VOS','OSV','OVS'].forEach(optVal => {
                    const optEl = document.createElement('option');
                    optEl.value = optVal;
                    optEl.textContent = optVal;
                    if (optVal === builderState.structure) optEl.selected = true;
                    structSelect.appendChild(optEl);
                });
                structSelect.addEventListener('change', () => {
                    builderState.structure = structSelect.value;
                    updateBuilderFields();
                    // After rebuilding the fields, ensure the object role row is hidden if the selected verb is intransitive
                    builderState.roles.forEach((r, ridx) => {
                        if (r.role === 'O') {
                            const oRow = section.querySelector(`#sentenceRow_${ridx}`);
                            if (oRow) {
                                oRow.style.display = builderState.verbIsIntransitive ? 'none' : '';
                            }
                        }
                    });
                    // Update the object adjective visibility
                    try {
                        if (typeof updateObjectAdjVisibility === 'function') {
                            updateObjectAdjVisibility();
                        }
                    } catch (e) {}
                    updateBuildButtons();
                });
            }
            // Map sentence role letters to Thai descriptions for clarity
            const roleNames = { 'S': '‡∏õ‡∏£‡∏∞‡∏ò‡∏≤‡∏ô', 'V': '‡∏Å‡∏£‡∏¥‡∏¢‡∏≤', 'O': '‡∏Å‡∏£‡∏£‡∏°' };
            /**
             * Populate a datalist element with lexicon entries.  Each option's value
             * uses the orthographic form for easy reading.  Data attributes store
             * the base form and ID so that when a user selects a value we can
             * retrieve the correct dictionary entry.
             *
             * @param {HTMLDataListElement} datalistEl The datalist to populate
             */
            function populateSentenceDatalist(datalistEl) {
                if (!datalistEl) return;
                datalistEl.innerHTML = '';
                (currentLanguage.lexicon || []).forEach(entry => {
                    const optionEl = document.createElement('option');
                    optionEl.value = getOrthographicForm(entry);
                    optionEl.dataset.wordid = entry.id;
                    optionEl.dataset.baseform = entry.word;
                    datalistEl.appendChild(optionEl);
                });
            }
            /**
             * Refresh the builder fields based on the currently selected structure.  This
             * will recreate input rows for each role (S, V, O) and attach listeners to
             * handle word selection and inflection option changes.  If builderState
             * already has selections (for example when editing a saved sentence), they
             * will be preserved and the inputs and selectors prepopulated.
             */
            function updateBuilderFields() {
                const fieldsContainer = section.querySelector('#sentenceBuilderFields');
                if (!fieldsContainer) return;
                fieldsContainer.innerHTML = '';
                builderState.roles = [];
                // Iterate over each character in the structure string to set up roles
                builderState.structure.split('').forEach((ch, idx) => {
                    // Each role now carries its own modifier (adjective/adverb) selection and position.
                    const roleObj = { role: ch, wordId: null, selectedOptions: {}, modifierId: null, modifierPos: 'before' };
                    // If builderState.roles existed previously (e.g. editing), try to copy previous selections
                    if (builderState.roles && builderState.roles[idx]) {
                        roleObj.wordId = builderState.roles[idx].wordId;
                        roleObj.selectedOptions = Object.assign({}, builderState.roles[idx].selectedOptions);
                    }
                    builderState.roles.push(roleObj);
                    // Create a container for this role row
                    const row = document.createElement('div');
                    row.id = `sentenceRow_${idx}`;
                    row.className = 'p-3 border border-indigo-300 rounded-md bg-white';
                    const label = roleNames[ch] || ('‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó ' + ch);
                    row.innerHTML = `
                        <div class="mb-1"><strong>${label} (${ch})</strong></div>
                        <div class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                            <input type="text" id="sentenceInput_${idx}" list="sentenceDatalist_${idx}" placeholder="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡πÉ‡∏ô‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°" class="p-2 border border-indigo-300 rounded-md flex-grow text-sm" />
                            <datalist id="sentenceDatalist_${idx}"></datalist>
                            <div class="morph-selectors flex flex-wrap gap-2 mt-2 sm:mt-0"></div>
                        </div>`;
                    fieldsContainer.appendChild(row);
                    // Populate datalist for this row
                    const datalistEl = row.querySelector(`datalist#sentenceDatalist_${idx}`);
                    populateSentenceDatalist(datalistEl);
                    // Set input value if a word is already selected
                    if (roleObj.wordId) {
                        const wordEntry = (currentLanguage.lexicon || []).find(w => w.id === roleObj.wordId);
                        if (wordEntry) {
                            const inputEl = row.querySelector(`#sentenceInput_${idx}`);
                            if (inputEl) inputEl.value = getOrthographicForm(wordEntry);
                        }
                    }
                    // Event handlers for the input
                    const inputEl = row.querySelector(`#sentenceInput_${idx}`);
                    if (inputEl) {
                        inputEl.addEventListener('change', () => { updateWordSelection(idx); });
                        inputEl.addEventListener('blur', () => { updateWordSelection(idx); });
                    }
                    // Render morph selectors if a word is already selected
                    if (roleObj.wordId) {
                        renderMorphSelectors(idx);
                    }
                    // Add adjective/adverb selectors within this row based on the role
                    if (['S','O','V'].includes(ch)) {
                        // Create a container for modifier controls
                        const modContainer = document.createElement('div');
                        modContainer.className = 'modifier-controls mt-2 flex flex-col sm:flex-row gap-2 items-start sm:items-center';
                        // Label indicating type of modifier
                        const lbl = document.createElement('span');
                        lbl.className = 'text-sm';
                        lbl.textContent = (ch === 'V') ? '‡∏Ñ‡∏≥‡∏ß‡∏¥‡πÄ‡∏®‡∏©‡∏ì‡πå:' : '‡∏Ñ‡∏≥‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå:';
                        modContainer.appendChild(lbl);
                        // Select element for the modifier word
                        const modSelect = document.createElement('select');
                        modSelect.className = 'p-2 border border-indigo-300 rounded-md flex-grow text-sm';
                        modSelect.dataset.roleIndex = idx;
                        const emptyOpt = document.createElement('option');
                        emptyOpt.value = '';
                        emptyOpt.textContent = '--‡πÑ‡∏°‡πà‡∏°‡∏µ--';
                        modSelect.appendChild(emptyOpt);
                        // Populate options from the lexicon based on part of speech
                        (currentLanguage.lexicon || []).forEach(entry => {
                            const posLower = (entry.partOfSpeech || '').toLowerCase();
                            const isAdj = posLower.includes('adj') || posLower.includes('adject') || posLower.includes('‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå');
                            const isAdv = posLower.includes('adv') || posLower.includes('adverb') || posLower.includes('‡∏ß‡∏¥‡πÄ‡∏®‡∏©');
                            if ((ch === 'V' && isAdv) || ((ch === 'S' || ch === 'O') && isAdj)) {
                                const opt = document.createElement('option');
                                opt.value = entry.id;
                                opt.textContent = getOrthographicForm(entry);
                                modSelect.appendChild(opt);
                            }
                        });
                        // If a modifier was previously selected for this role, set it
                        if (roleObj.modifierId) {
                            modSelect.value = roleObj.modifierId;
                        }
                        modSelect.addEventListener('change', function() {
                            const rIdx = parseInt(this.dataset.roleIndex);
                            const val = this.value;
                            builderState.roles[rIdx].modifierId = val ? parseInt(val) : null;
                            updateBuildButtons();
                        });
                        modContainer.appendChild(modSelect);
                        // Select element for modifier position (before/after)
                        const posSelect = document.createElement('select');
                        posSelect.className = 'p-2 border border-indigo-300 rounded-md text-sm';
                        posSelect.dataset.roleIndex = idx;
                        const beforeOpt = document.createElement('option');
                        beforeOpt.value = 'before';
                        beforeOpt.textContent = '‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤';
                        posSelect.appendChild(beforeOpt);
                        const afterOpt = document.createElement('option');
                        afterOpt.value = 'after';
                        afterOpt.textContent = '‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á';
                        posSelect.appendChild(afterOpt);
                        posSelect.value = roleObj.modifierPos || 'before';
                        posSelect.addEventListener('change', function() {
                            const rIdx = parseInt(this.dataset.roleIndex);
                            builderState.roles[rIdx].modifierPos = this.value;
                            updateBuildButtons();
                        });
                        modContainer.appendChild(posSelect);
                        // Append the modifier controls container to the row
                        row.appendChild(modContainer);
                    }
                });
                updateBuildButtons();
            }
            /**
             * Update the word selection for a given role based on the current value of
             * its input field.  This function looks up the dictionary entry that
             * corresponds to the input either via the datalist option data attributes
             * or by matching the orthographic/base forms.  Once a word is selected
             * the morph selectors for that row are rebuilt.
             *
             * @param {number} index The index of the role in builderState.roles
             */
            function updateWordSelection(index) {
                const role = builderState.roles[index];
                const row = section.querySelector(`#sentenceRow_${index}`);
                if (!row) return;
                const inputEl = row.querySelector(`#sentenceInput_${index}`);
                const datalistEl = row.querySelector(`datalist#sentenceDatalist_${index}`);
                if (!inputEl || !datalistEl) return;
                const value = inputEl.value.trim();
                let selectedWordEntry = null;
                // Try to match by datalist option first (exact match)
                const matchOpt = Array.from(datalistEl.options || []).find(opt => opt.value === value || (opt.dataset.baseform && opt.dataset.baseform === value));
                if (matchOpt && matchOpt.dataset.wordid) {
                    selectedWordEntry = (currentLanguage.lexicon || []).find(w => w.id === parseInt(matchOpt.dataset.wordid));
                }
                // Fallback search in lexicon by orthographic or base form
                if (!selectedWordEntry && value) {
                    selectedWordEntry = (currentLanguage.lexicon || []).find(w => {
                        return getOrthographicForm(w) === value || w.word === value;
                    });
                }
                if (selectedWordEntry) {
                    builderState.roles[index].wordId = selectedWordEntry.id;
                } else {
                    builderState.roles[index].wordId = null;
                    builderState.roles[index].selectedOptions = {};
                }
                // If this role is the verb, determine whether it is intransitive.  Use
                // the partOfSpeech field to check for keywords indicating intransitivity.
                if (builderState.roles[index] && builderState.roles[index].role === 'V') {
                    builderState.verbIsIntransitive = false;
                    if (selectedWordEntry && selectedWordEntry.partOfSpeech) {
                        const posLower = selectedWordEntry.partOfSpeech.toLowerCase();
                        if (posLower.includes('intrans') || posLower.includes('‡∏≠‡∏Å‡∏£‡∏£‡∏°')) {
                            builderState.verbIsIntransitive = true;
                        }
                    }
                    // Show or hide the object row depending on verb transitivity
                    builderState.roles.forEach((r, ridx) => {
                        if (r.role === 'O') {
                            const oRow = section.querySelector(`#sentenceRow_${ridx}`);
                            if (oRow) {
                                oRow.style.display = builderState.verbIsIntransitive ? 'none' : '';
                            }
                        }
                    });
                    // Update the object adjective visibility if the helper exists
                    try {
                        if (typeof updateObjectAdjVisibility === 'function') {
                            updateObjectAdjVisibility();
                        }
                    } catch (e) {}
                }
                // Re-render morph selectors for this role
                renderMorphSelectors(index);
                updateBuildButtons();
            }
            /**
             * Render the inflection selectors for a given role based on the word
             * selected.  These selectors allow the user to choose inflection
             * categories/options for the word (e.g. tense, number).  If no word is
             * selected the selectors are cleared.  When options are changed the
             * builderState is updated accordingly.
             *
             * @param {number} index The index of the role in builderState.roles
             */
            function renderMorphSelectors(index) {
                const role = builderState.roles[index];
                const row = section.querySelector(`#sentenceRow_${index}`);
                if (!row) return;
                const container = row.querySelector('.morph-selectors');
                if (!container) return;
                container.innerHTML = '';
                if (!role.wordId) return;
                const wordEntry = (currentLanguage.lexicon || []).find(w => w.id === role.wordId);
                if (!wordEntry) return;
                const pos = wordEntry.partOfSpeech || '';
                const categories = (currentLanguage.grammar && currentLanguage.grammar.morphology && currentLanguage.grammar.morphology.conjugationCategories) || [];
                const applicableCats = categories.filter(cat => {
                    return cat.appliesToPOS.includes(pos) || cat.appliesToPOS.some(applied => pos.startsWith(applied + ':'));
                });
                applicableCats.forEach(cat => {
                    const select = document.createElement('select');
                    select.className = 'p-2 border border-indigo-300 rounded-md text-xs';
                    select.dataset.catId = cat.id;
                    select.dataset.roleIndex = index;
                    let optionsHtml = `<option value="">-- ${cat.name} --</option>`;
                    (cat.options || []).forEach(opt => {
                        optionsHtml += `<option value="${opt}">${opt}</option>`;
                    });
                    select.innerHTML = optionsHtml;
                    // Set previous selection if present
                    if (role.selectedOptions && role.selectedOptions.hasOwnProperty(cat.id)) {
                        select.value = role.selectedOptions[cat.id];
                    }
                    select.addEventListener('change', function() {
                        const catId = this.dataset.catId;
                        const rIdx = parseInt(this.dataset.roleIndex);
                        const val = this.value;
                        if (!builderState.roles[rIdx].selectedOptions) builderState.roles[rIdx].selectedOptions = {};
                        if (val) {
                            builderState.roles[rIdx].selectedOptions[catId] = val;
                        } else {
                            delete builderState.roles[rIdx].selectedOptions[catId];
                        }
                        updateBuildButtons();
                    });
                    container.appendChild(select);
                });
            }
            /**
             * Enable or disable the build and save buttons based on the current
             * selections.  The build button requires all roles to have a word
             * selected.  The save button requires that a sentence has been
             * successfully built (stored in builderState.lastBuilt).
             */
            function updateBuildButtons() {
                const buildBtn = section.querySelector('#buildSentenceBtn');
                const saveBtn = section.querySelector('#saveSentenceBtn');
                const allHaveWords = builderState.roles.every(r => {
                    // When the verb is intransitive the object role can be empty
                    if (builderState.verbIsIntransitive && r.role === 'O') return true;
                    return !!r.wordId;
                });
                if (buildBtn) buildBtn.disabled = !allHaveWords;
                if (saveBtn) saveBtn.disabled = !builderState.lastBuilt;
            }
            /**
             * Generate the sentence based on the current selections.  The result is
             * displayed in the output area and stored in builderState.lastBuilt so
             * that it can be saved.  If a word is missing an alert will be shown.
             */
            function buildSentence() {
                // Determine if all required words are selected.  If the verb is intransitive,
                // the object role can be omitted.
                const allHave = builderState.roles.every(r => {
                    if (builderState.verbIsIntransitive && r.role === 'O') return true;
                    return !!r.wordId;
                });
                if (!allHave) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á');
                    return;
                }
                // Arrays to collect orthographic, phonetic and meaning parts.
                const orthoParts = [];
                const phoneticParts = [];
                const meaningParts = [];
                // Helper to append a word's inflected forms to the arrays.
                function appendWord(entry, opts = {}) {
                    if (!entry) return;
                    const inf = computeInflectedForms(entry, opts);
                    orthoParts.push(inf.orthographic || '');
                    phoneticParts.push(inf.phonetic || '');
                    meaningParts.push(entry.meaning || '');
                }
                // Iterate through the roles and inject per-role modifiers (adjectives/adverbs).
                builderState.roles.forEach(role => {
                    // Skip the object if the selected verb is intransitive
                    if (builderState.verbIsIntransitive && role.role === 'O') {
                        return;
                    }
                    const wordEntry = (currentLanguage.lexicon || []).find(x => x.id === role.wordId);
                    if (!wordEntry) return;
                    // Identify modifier entry and position for this role
                    const modId = role.modifierId;
                    const modPos = role.modifierPos || 'before';
                    const modEntry = modId ? (currentLanguage.lexicon || []).find(x => x.id === modId) : null;
                    // Prepend modifier if it comes before the head
                    if (modEntry && modPos === 'before') {
                        appendWord(modEntry);
                    }
                    // Append the main word with any inflection options
                    appendWord(wordEntry, role.selectedOptions);
                    // Append modifier if it comes after the head
                    if (modEntry && modPos === 'after') {
                        appendWord(modEntry);
                    }
                });
                const orthoStr = orthoParts.join(' ').trim();
                const phoneticStr = phoneticParts.join(' ').trim();
                const meaningStr = meaningParts.join(' ').trim();
                const outputArea = section.querySelector('#sentenceOutputArea');
                const outOrtho = section.querySelector('#sentenceOutputOrtho');
                const outPhon = section.querySelector('#sentenceOutputPhonetic');
                const outMeaning = section.querySelector('#sentenceOutputMeaning');
                if (outOrtho) outOrtho.textContent = orthoStr;
                if (outPhon) {
                    outPhon.textContent = phoneticStr;
                    // Update the phonetic container's data attribute so audio plays the correct string
                    const phonContainer = section.querySelector('#sentenceOutputPhoneticContainer');
                    if (phonContainer) {
                        phonContainer.setAttribute('data-phonetic', phoneticStr);
                        // Determine voice for the sentence: use the first available voiceId from any word in the sentence
                        let selectedVoiceForSentence = null;
                        if (builderState && Array.isArray(builderState.roles)) {
                            for (const roleItem of builderState.roles) {
                                const wid = roleItem.wordId;
                                if (wid) {
                                    const w = (currentLanguage.lexicon || []).find(e => e.id === wid);
                                    if (w && w.voiceId) {
                                        selectedVoiceForSentence = w.voiceId;
                                        break;
                                    }
                                }
                            }
                        }
                        if (!selectedVoiceForSentence) {
                            // Fallback to default
                            selectedVoiceForSentence = DEFAULT_VOICE_ID;
                        }
                        phonContainer.setAttribute('data-voiceid', selectedVoiceForSentence || '');
                    }
                }
                if (outMeaning) {
                    outMeaning.value = meaningStr;
                }
                if (outputArea) outputArea.classList.remove('hidden');
                builderState.lastBuilt = { orthographic: orthoStr, phonetic: phoneticStr, meaning: meaningStr };
                updateBuildButtons();
            }
            /**
             * Save the last built sentence into the language‚Äôs sentences array.  A
             * unique ID is assigned using nextSentenceId.  After saving, the
             * saved sentences list is refreshed.  The save button is disabled
             * again until a new build is performed.
             */
            function saveSentence() {
                if (!builderState.lastBuilt) return;
                const newId = 'sent_' + (nextSentenceId++);
                // Use the current value of the translation input for the translation
                const translationInput = section.querySelector('#sentenceOutputMeaning');
                const translationValue = translationInput ? translationInput.value : (builderState.lastBuilt ? builderState.lastBuilt.meaning : '');
                const newSent = {
                    id: newId,
                    structure: builderState.structure,
                    components: builderState.roles.map(r => ({
                        role: r.role,
                        wordId: r.wordId,
                        selectedOptions: Object.assign({}, r.selectedOptions || {})
                    })),
                    translation: translationValue
                };
                currentLanguage.sentences.push(newSent);
                saveData();
                renderSavedSentences();
                builderState.lastBuilt = null;
                const saveBtn = section.querySelector('#saveSentenceBtn');
                if (saveBtn) saveBtn.disabled = true;
            }
            /**
             * Render the list of saved sentences in the language.  Each saved
             * sentence will be displayed with its orthographic form, translation,
             * structure and action buttons for editing or deletion.
             */
            function renderSavedSentences() {
                const containerEl = section.querySelector('#savedSentencesContainer');
                if (!containerEl) return;
                containerEl.innerHTML = '<h4 class="text-md font-semibold text-indigo-700 mb-2">‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</h4>';
                const sentencesArr = currentLanguage.sentences || [];
                if (!Array.isArray(sentencesArr) || sentencesArr.length === 0) {
                    containerEl.innerHTML += '<p class="text-sm text-gray-500">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ</p>';
                    return;
                }
                sentencesArr.forEach(sent => {
                    // Compute forms each time for up-to-date inflections
                    let orthoParts = [];
                    let meaningParts = [];
                    sent.components.forEach(comp => {
                        const w = (currentLanguage.lexicon || []).find(x => x.id === comp.wordId);
                        if (!w) {
                            orthoParts.push('(?)');
                            meaningParts.push('(?)');
                        } else {
                            const inf = computeInflectedForms(w, comp.selectedOptions || {});
                            orthoParts.push(inf.orthographic);
                            meaningParts.push(w.meaning || '');
                        }
                    });
                    const orthoStr = orthoParts.join(' ');
                    const meaningStr = meaningParts.join(' ');
                    const row = document.createElement('div');
                    row.className = 'p-3 border border-indigo-300 rounded-md bg-white flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2';
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'flex-grow';
                    infoDiv.innerHTML = `<div class="font-mono text-sm text-indigo-700">${orthoStr}</div><div class="text-sm text-gray-700">${meaningStr}</div><div class="text-xs text-gray-500">‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á: ${sent.structure}</div>`;
                    const actions = document.createElement('div');
                    actions.className = 'flex gap-2';
                    const editBtn = document.createElement('button');
                    editBtn.className = 'text-indigo-500 hover:text-indigo-700 text-sm';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ';
                    editBtn.addEventListener('click', () => { editSentence(sent.id); });
                    const delBtn = document.createElement('button');
                    delBtn.className = 'text-red-500 hover:text-red-700 text-sm';
                    delBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    delBtn.title = '‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ';
                    delBtn.addEventListener('click', () => {
                        if (confirm('‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
                            deleteSentence(sent.id);
                        }
                    });
                    actions.appendChild(editBtn);
                    actions.appendChild(delBtn);
                    row.appendChild(infoDiv);
                    row.appendChild(actions);
                    containerEl.appendChild(row);
                });
            }
            // Attach click handlers for buttons
            const buildBtnEl = section.querySelector('#buildSentenceBtn');
            if (buildBtnEl) buildBtnEl.addEventListener('click', buildSentence);
            const saveBtnEl = section.querySelector('#saveSentenceBtn');
            if (saveBtnEl) saveBtnEl.addEventListener('click', saveSentence);
            const randomBtnEl = section.querySelector('#randomFillSentenceBtn');
            if (randomBtnEl) randomBtnEl.addEventListener('click', () => {
                // For each role, pick a random appropriate word from lexicon
                builderState.roles.forEach((r, idx) => {
                    let wordEntry = null;
                    // Determine POS from role
                    if (r.role === 'S' || r.role === 'O') {
                        let candidates = (currentLanguage.lexicon || []).filter(w => (w.partOfSpeech || '').toLowerCase().startsWith('‡∏ô‡∏≤‡∏°'));
                        if (candidates.length === 0) candidates = currentLanguage.lexicon || [];
                        if (candidates.length > 0) wordEntry = candidates[Math.floor(Math.random() * candidates.length)];
                    } else if (r.role === 'V') {
                        let candidates = (currentLanguage.lexicon || []).filter(w => (w.partOfSpeech || '').toLowerCase().startsWith('‡∏Å‡∏£‡∏¥‡∏¢‡∏≤'));
                        if (candidates.length === 0) candidates = currentLanguage.lexicon || [];
                        if (candidates.length > 0) wordEntry = candidates[Math.floor(Math.random() * candidates.length)];
                    }
                    if (!wordEntry && (currentLanguage.lexicon || []).length > 0) {
                        wordEntry = (currentLanguage.lexicon || [])[Math.floor(Math.random() * (currentLanguage.lexicon || []).length)];
                    }
                    if (wordEntry) {
                        builderState.roles[idx].wordId = wordEntry.id;
                        builderState.roles[idx].selectedOptions = {};
                        const inputEl = section.querySelector(`#sentenceInput_${idx}`);
                        if (inputEl) inputEl.value = getOrthographicForm(wordEntry);
                        renderMorphSelectors(idx);
                    }
                });
                builderState.lastBuilt = null;
                const outArea = section.querySelector('#sentenceOutputArea');
                if (outArea) outArea.classList.add('hidden');
                updateBuildButtons();
            });
            // Initial render of fields
            updateBuilderFields();
            // ==================== Custom Modifiers UI ====================
            // After rendering the base sentence fields, append a section for selecting
            // adjectives (for subject and object) and an adverb.  Each modifier
            // includes a position selector allowing placement before or after its head.
            const modifierSection = document.createElement('div');
            modifierSection.id = 'sentenceModifiers';
            modifierSection.className = 'mt-3 space-y-3';
            modifierSection.innerHTML = `
                <div class="p-3 border border-indigo-300 rounded-md bg-white">
                    <div class="mb-1"><strong>‡∏Ñ‡∏≥‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå ‡∏õ‡∏£‡∏∞‡∏ò‡∏≤‡∏ô:</strong></div>
                    <div class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                        <select id="subjectAdjSelect" class="p-2 border border-indigo-300 rounded-md flex-grow text-sm">
                            <option value="">--‡πÑ‡∏°‡πà‡∏°‡∏µ--</option>
                        </select>
                        <select id="subjectAdjPosSelect" class="p-2 border border-indigo-300 rounded-md text-sm">
                            <option value="before">‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤</option>
                            <option value="after">‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á</option>
                        </select>
                    </div>
                </div>
                <div class="p-3 border border-indigo-300 rounded-md bg-white">
                    <div class="mb-1"><strong>‡∏Ñ‡∏≥‡∏ß‡∏¥‡πÄ‡∏®‡∏©‡∏ì‡πå:</strong></div>
                    <div class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                        <select id="adverbSelect" class="p-2 border border-indigo-300 rounded-md flex-grow text-sm">
                            <option value="">--‡πÑ‡∏°‡πà‡∏°‡∏µ--</option>
                        </select>
                        <select id="adverbPosSelect" class="p-2 border border-indigo-300 rounded-md text-sm">
                            <option value="before">‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤</option>
                            <option value="after">‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á</option>
                        </select>
                    </div>
                </div>
                <div class="p-3 border border-indigo-300 rounded-md bg-white" id="objectAdjContainer">
                    <div class="mb-1"><strong>‡∏Ñ‡∏≥‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå ‡∏Å‡∏£‡∏£‡∏°:</strong></div>
                    <div class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                        <select id="objectAdjSelect" class="p-2 border border-indigo-300 rounded-md flex-grow text-sm">
                            <option value="">--‡πÑ‡∏°‡πà‡∏°‡∏µ--</option>
                        </select>
                        <select id="objectAdjPosSelect" class="p-2 border border-indigo-300 rounded-md text-sm">
                            <option value="before">‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤</option>
                            <option value="after">‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á</option>
                        </select>
                    </div>
                </div>
            `;
            // Do not append the standalone modifier section; per-role modifier controls are now within each sentence row
            // section.appendChild(modifierSection);
            // Populate the adjective and adverb selects based on the lexicon.
            function populateModifierSelects() {
                const subjAdjSel = section.querySelector('#subjectAdjSelect');
                const objAdjSel = section.querySelector('#objectAdjSelect');
                const advSel = section.querySelector('#adverbSelect');
                const resetSelect = (sel) => {
                    if (!sel) return;
                    const first = sel.options && sel.options[0];
                    sel.innerHTML = '';
                    if (first) sel.appendChild(first);
                };
                resetSelect(subjAdjSel);
                resetSelect(objAdjSel);
                resetSelect(advSel);
                (currentLanguage.lexicon || []).forEach(entry => {
                    const pos = (entry.partOfSpeech || '').toLowerCase();
                    // Identify adjectives
                    if (pos.includes('adj') || pos.includes('adject') || pos.includes('‡∏Ñ‡∏∏‡∏ì‡∏®‡∏±‡∏û‡∏ó‡πå')) {
                        const opt = document.createElement('option');
                        opt.value = entry.id;
                        opt.textContent = getOrthographicForm(entry);
                        if (subjAdjSel) subjAdjSel.appendChild(opt.cloneNode(true));
                        if (objAdjSel) objAdjSel.appendChild(opt.cloneNode(true));
                    }
                    // Identify adverbs
                    if (pos.includes('adv') || pos.includes('adverb') || pos.includes('‡∏ß‡∏¥‡πÄ‡∏®‡∏©')) {
                        const opt2 = document.createElement('option');
                        opt2.value = entry.id;
                        opt2.textContent = getOrthographicForm(entry);
                        if (advSel) advSel.appendChild(opt2);
                    }
                });
            }
            // Removed call to populateModifierSelects() because modifier UI is now per-role
            // Removed global modifier event listeners and visibility helpers; modifiers are handled within each row.
            // Render saved sentences list
            renderSavedSentences();
            // If an edit ID is provided, populate builder with that saved sentence
            if (editId) {
                const toEdit = (currentLanguage.sentences || []).find(s => s.id === editId);
                if (toEdit) {
                    builderState.structure = toEdit.structure;
                    if (structSelect) structSelect.value = toEdit.structure;
                    updateBuilderFields();
                    // Copy values into builder
                    toEdit.components.forEach((comp, idx) => {
                        if (builderState.roles[idx]) {
                            builderState.roles[idx].role = comp.role;
                            builderState.roles[idx].wordId = comp.wordId;
                            builderState.roles[idx].selectedOptions = Object.assign({}, comp.selectedOptions || {});
                            const inputEl = section.querySelector(`#sentenceInput_${idx}`);
                            const wordEntry = (currentLanguage.lexicon || []).find(w => w.id === comp.wordId);
                            if (inputEl && wordEntry) {
                                inputEl.value = getOrthographicForm(wordEntry);
                            }
                            renderMorphSelectors(idx);
                        }
                    });
                    builderState.lastBuilt = null;
                    const outArea = section.querySelector('#sentenceOutputArea');
                    if (outArea) outArea.classList.add('hidden');
                    updateBuildButtons();
                }
            }
        }
        /**
         * Delete a sentence by its ID from the current language and refresh the
         * sentence tab if it is currently active.  This function is attached to
         * the window object so that it can be referenced from inline onclick
         * handlers generated in the saved sentences list.
         *
         * @param {String} id The identifier of the sentence to remove
         */
        window.deleteSentence = function(id) {
            const arr = currentLanguage.sentences || [];
            const idx = arr.findIndex(s => s.id === id);
            if (idx > -1) {
                arr.splice(idx, 1);
                saveData();
                if (activeTab === 'sentence') {
                    renderSentenceUI(tabContentContainer);
                }
            }
        };
        /**
         * Begin editing a saved sentence.  This will reload the sentence tab and
         * prepopulate the builder with the contents of the selected sentence.  The
         * function is attached to the window object so that it can be referenced
         * from inline onclick handlers.  Editing always switches to the sentence
         * tab if not already active.
         *
         * @param {String} id The identifier of the sentence to edit
         */
        window.editSentence = function(id) {
            // Ensure we are on the sentence tab; switching tabs triggers re-render
            if (activeTab !== 'sentence') {
                switchTab('sentence');
            }
            // After switching, the tab‚Äôs content will be regenerated.  Use a small
            // timeout to allow the content to mount before loading the edit state.
            setTimeout(() => {
                renderSentenceUI(tabContentContainer, id);
            }, 50);
        };
        // ========== End Sentence System Implementation ==========

        function exportDataAsJSON(data, filename) {
            const jsonData = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function importAllLanguagesData(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedPayload = JSON.parse(e.target.result);
                        let importedLanguagesArray;
                        let importedGlobalRules = [];

                        if (Array.isArray(importedPayload)) { 
                            importedLanguagesArray = importedPayload;
                            console.warn("Importing old format (array of languages).");
                        } else if (importedPayload && Array.isArray(importedPayload.allLanguages)) { 
                            importedLanguagesArray = importedPayload.allLanguages;
                            if (Array.isArray(importedPayload.globalInterLangRules)) {
                                importedGlobalRules = importedPayload.globalInterLangRules;
                            }
                        } else {
                             alert('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                            return;
                        }

                        if (importedLanguagesArray.every(lang => lang.hasOwnProperty('name'))) {
                           if (confirm(`‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (${importedLanguagesArray.length} ‡∏†‡∏≤‡∏©‡∏≤)? ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î!`)) {
                                allLanguages = []; 
                                globalInterLangRules = importedGlobalRules; 

                                importedLanguagesArray.forEach(importedLang => {
                                    allLanguages.push(ensureDeepStructure(importedLang, DEFAULT_LANGUAGE_STATE));
                                });

                                if (allLanguages.length > 0) {
                                    switchLanguage(allLanguages[0].name); 
                                } else { 
                                    currentLanguage = ensureDeepStructure({}, DEFAULT_LANGUAGE_STATE);
                                    nextWordId = 1;
                                    updateUI(); 
                                }
                                saveData(); 
                                alert('‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
                            }
                        } else {
                            alert('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: language objects ‡∏ö‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏°‡∏µ property "name"');
                        }
                    } catch (error) {
                        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå JSON: ' + error.message);
                        console.error("Import error:", error);
                    }
                };
                reader.readAsText(file);
                event.target.value = null; 
            }
        }

        function renderWordEvolutionUI(container) {
            const evolutionContainer = document.createElement('div');
            evolutionContainer.className = 'p-3 border rounded bg-gray-50';

            // Autocomplete search for base word
            let datalistId = 'evoWordSearchDatalist_' + Date.now();
            let datalistOptions = '';
            (currentLanguage.lexicon || []).forEach(w => {
                let ortho = getOrthographicForm(w, false, false);
                let base = w.word;
                datalistOptions += `<option value="${ortho} (${base}) - ${w.meaning}" data-wordid="${w.id}">`;
            });
            // Era options
            let eraOptions = '';
            (currentLanguage.evolution.eras || []).forEach(era => {
                eraOptions += `<option value="${era.id}">${era.name}</option>`;
            });
            evolutionContainer.innerHTML = `
                <h3 class="text-lg font-semibold mb-3">‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥</h3>
                <div class="mb-3">
                    <label class="block text-sm font-medium">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå (‡∏à‡∏≤‡∏Å‡∏û‡∏à‡∏ô‡∏≤‡∏ô‡∏∏‡∏Å‡∏£‡∏°):</label>
                    <input id="evoBaseWordSearch" class="p-1 border rounded text-sm w-full" list="${datalistId}" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏≥...">
                    <datalist id="${datalistId}">${datalistOptions}</datalist>
                </div>
                <div class="mb-3">
                    <label class="block text-sm font-medium">‡πÄ‡∏û‡∏¥‡πà‡∏°/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢:</label>
                    <div class="flex gap-2 mb-2">
                        <input id="newEraNameInput" class="p-1 border rounded text-sm" placeholder="‡∏ä‡∏∑‡πà‡∏≠‡∏¢‡∏∏‡∏Ñ‡πÉ‡∏´‡∏°‡πà">
                        <button id="addEraBtnEvo" class="btn-secondary text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏¢‡∏∏‡∏Ñ</button>
                    </div>
                    <select id="evoEraSelect" class="p-1 border rounded text-sm">${eraOptions}</select>
                    <button id="removeEraBtnEvo" class="btn-secondary text-xs ml-2">‡∏•‡∏ö‡∏¢‡∏∏‡∏Ñ</button>
                </div>
                <div class="mb-3">
                    <label class="block text-sm font-medium">‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∏‡∏Ñ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å:</label>
                    <div id="evoEraRulesList" class="mb-2"></div>
                    <div class="flex gap-2 mb-2">
                        <input id="evoRuleFromInput" class="p-1 border rounded text-sm" placeholder="‡∏à‡∏≤‡∏Å (‡πÄ‡∏ä‡πà‡∏ô a)">
                        <input id="evoRuleToInput" class="p-1 border rounded text-sm" placeholder="‡πÄ‡∏õ‡πá‡∏ô (‡πÄ‡∏ä‡πà‡∏ô e)">
                        <input id="evoRuleContextInput" class="p-1 border rounded text-sm" placeholder="‡∏ö‡∏£‡∏¥‡∏ö‡∏ó (‡πÄ‡∏ä‡πà‡∏ô _#)">
                        <button id="addEvoRuleBtn" class="btn-secondary text-xs">‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏é</button>
                    </div>
                </div>
                <div class="mb-3">
                    <button id="generateEvolutionBtn" class="btn-primary text-sm">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≤‡∏¢‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£</button>
                </div>
                <div id="evoEvolutionResult" class="p-3 border rounded bg-white"></div>
            `;

            container.appendChild(evolutionContainer);

            // Add era
            document.getElementById('addEraBtnEvo').onclick = () => {
                const name = document.getElementById('newEraNameInput').value.trim();
                if (!name) { alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏¢‡∏∏‡∏Ñ'); return; }
                const id = 'era_' + Date.now();
                currentLanguage.evolution.eras.push({ id, name, soundChangeRules: [] });
                renderWordEvolutionUI(container);
                saveData();
            };
            // Remove era
            document.getElementById('removeEraBtnEvo').onclick = () => {
                const eraId = document.getElementById('evoEraSelect').value;
                if (!eraId) return;
                currentLanguage.evolution.eras = currentLanguage.evolution.eras.filter(e => e.id !== eraId);
                renderWordEvolutionUI(container);
                saveData();
            };
            // Add rule
            document.getElementById('addEvoRuleBtn').onclick = () => {
                const eraId = document.getElementById('evoEraSelect').value;
                const from = document.getElementById('evoRuleFromInput').value.trim();
                const to = document.getElementById('evoRuleToInput').value.trim();
                const context = document.getElementById('evoRuleContextInput').value.trim();
                if (!eraId || !from) { alert('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏∏‡∏Ñ‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏≠‡∏Å "‡∏à‡∏≤‡∏Å"'); return; }
                const era = currentLanguage.evolution.eras.find(e => e.id === eraId);
                if (!era) return;
                era.soundChangeRules = era.soundChangeRules || [];
                era.soundChangeRules.push({ from, to, context });
                renderWordEvolutionUI(container);
                saveData();
            };
            // Show rules for selected era
            const updateEraRulesList = () => {
                const eraId = document.getElementById('evoEraSelect').value;
                const era = currentLanguage.evolution.eras.find(e => e.id === eraId);
                const listDiv = document.getElementById('evoEraRulesList');
                if (!era) { listDiv.innerHTML = '<span class="text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏∏‡∏Ñ</span>'; return; }
                listDiv.innerHTML = '';
                (era.soundChangeRules || []).forEach((rule, idx) => {
                    const ruleDiv = document.createElement('div');
                    ruleDiv.className = 'flex gap-2 items-center mb-1';
                    ruleDiv.innerHTML = `<span class="text-xs bg-gray-200 rounded px-2 py-1">${rule.from} ‚Üí ${rule.to} <span class="text-gray-400">[${rule.context||'-'}]</span></span> <button class="text-xs text-red-500" data-idx="${idx}">‡∏•‡∏ö</button>`;
                    ruleDiv.querySelector('button').onclick = () => {
                        era.soundChangeRules.splice(idx,1);
                        renderWordEvolutionUI(container);
                        saveData();
                    };
                    listDiv.appendChild(ruleDiv);
                });
                if ((era.soundChangeRules||[]).length === 0) listDiv.innerHTML = '<span class="text-gray-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏é</span>';
            };
            document.getElementById('evoEraSelect').onchange = updateEraRulesList;
            updateEraRulesList();

            // --- Autocomplete logic for base word search ---
            let selectedBaseWordId = null;
            const evoBaseWordSearch = document.getElementById('evoBaseWordSearch');
            evoBaseWordSearch.addEventListener('input', function(e) {
                const val = e.target.value;
                // Try to match to a lexicon entry
                const opt = Array.from(document.getElementById(datalistId).options).find(o => o.value === val);
                if (opt && opt.dataset.wordid) {
                    selectedBaseWordId = opt.dataset.wordid;
                } else {
                    selectedBaseWordId = null;
                }
            });

            // Generate evolution chain and tree
            document.getElementById('generateEvolutionBtn').onclick = () => {
                let baseWordId = selectedBaseWordId;
                if (!baseWordId) {
                    // fallback: try to match by value
                    const val = evoBaseWordSearch.value;
                    const opt = Array.from(document.getElementById(datalistId).options).find(o => o.value === val);
                    if (opt && opt.dataset.wordid) baseWordId = opt.dataset.wordid;
                }
                if (!baseWordId) { alert('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô'); return; }
                const baseWord = currentLanguage.lexicon.find(w => w.id == baseWordId);
                if (!baseWord) { alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥'); return; }
                let resultHtml = `<div class="mb-2"><strong>‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô:</strong> <span class="font-mono">${getOrthographicForm(baseWord)} (${baseWord.word})</span> <span class="text-xs text-gray-500">${baseWord.meaning}</span></div>`;
                let form = baseWord.word;
                // Sort eras by order of addition
                const eras = [...(currentLanguage.evolution.eras||[])];
                let chain = [{ era: null, form, ortho: getOrthographicForm(baseWord), word: baseWord }];
                for (let i=0; i<eras.length; ++i) {
                    const era = eras[i];
                    let formBefore = form;
                    (era.soundChangeRules||[]).forEach(rule => {
                        try {
                            let regex = rule.from;
                            if (rule.context) {
                                regex = convertContextualRuleToRegex(rule.from, rule.to, rule.context);
                            }
                            form = form.replace(regex, rule.to);
                        } catch(e) {}
                    });
                    chain.push({ era, form, ortho: transliterateWordToSymbols(form), word: baseWord });
                }
                // Render as horizontal tree
                resultHtml += `<div class="overflow-x-auto"><div style="display:flex;align-items:center;gap:16px;">`;
                chain.forEach((node, idx) => {
                    if (node.era) {
                        resultHtml += `<div class="flex flex-col items-center"><div class="text-xs text-gray-500 mb-1">${node.era.name}</div><div class="font-mono bg-purple-50 border rounded px-2 py-1">${node.ortho}</div><div class="text-xs text-gray-400 mt-1">[${node.form}]</div></div>`;
                    } else {
                        resultHtml += `<div class="flex flex-col items-center"><div class="text-xs text-gray-500 mb-1">‡∏Ñ‡∏≥‡∏ê‡∏≤‡∏ô</div><div class="font-mono bg-green-50 border rounded px-2 py-1">${node.ortho}</div><div class="text-xs text-gray-400 mt-1">[${node.form}]</div></div>`;
                    }
                    if (idx < chain.length-1) {
                        resultHtml += `<div class="text-2xl text-gray-400">‚Üí</div>`;
                    }
                });
                resultHtml += `</div></div>`;
                document.getElementById('evoEvolutionResult').innerHTML = resultHtml;
            };
        }

        function updateBaseEra() {
            const baseEraId = document.getElementById('baseEraSelect').value;
            currentLanguage.evolution.baseEra = baseEraId;
            saveData();
            renderEvolutionTree();
        }

        function updateWordEra() {
            const wordEraId = document.getElementById('wordEraSelect').value;
            currentLanguage.evolution.wordEra = wordEraId;
            saveData();
            renderEvolutionTree();
        }

        function renderEvolutionTree() {
            const treeContainer = document.getElementById('wordEvolutionTree');
            if (!treeContainer) return;

            const baseEra = currentLanguage.evolution.eras.find(e => e.id === currentLanguage.evolution.baseEra);
            const wordEra = currentLanguage.evolution.eras.find(e => e.id === currentLanguage.evolution.wordEra);

            if (!baseEra || !wordEra) {
                treeContainer.innerHTML = '<p class="text-sm text-red-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡∏ê‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏¢‡∏∏‡∏Ñ‡∏™‡∏°‡∏±‡∏¢‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô</p>';
                return;
            }

            treeContainer.innerHTML = `<p class="text-sm">Tree Diagram: ${baseEra.name} ‚Üí ${wordEra.name}</p>`;
            // Add logic to generate and display the actual tree diagram here
        }
        function submitWordTypeForm() {
            const checkboxes = document.querySelectorAll('input[name="wordType"]:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            alert("‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥: " + selectedTypes.join(", "));
        }

 function playIPA(ipaText) {
    const encoded = encodeURIComponent(ipaText);
    const url = `https://www.capyschool.com/th/reader?ipa=${encoded}`;
    window.open(url, '_blank');
}
       
    </script>
    <!-- AWS Polly Integration and Voice Controls -->
    <script>
    // Identity and region configuration for AWS Polly
    AWS.config.region = 'us-east-1';
    AWS.config.credentials = new AWS.CognitoIdentityCredentials({
        IdentityPoolId: 'us-east-1:26efe72d-52dc-48c6-9b9e-406755272318',
    });
    const polly = new AWS.Polly({ apiVersion: '2016-06-10' });

    // Language map to Thai names
    const languageMap = {
        "American English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡∏™‡∏´‡∏£‡∏±‡∏ê)", "Australian English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡∏≠‡∏≠‡∏™‡πÄ‡∏ï‡∏£‡πÄ‡∏•‡∏µ‡∏¢)",
        "British English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡∏™‡∏´‡∏£‡∏≤‡∏ä‡∏≠‡∏≤‡∏ì‡∏≤‡∏à‡∏±‡∏Å‡∏£)", "Indian English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡∏≠‡∏¥‡∏ô‡πÄ‡∏î‡∏µ‡∏¢)",
        "New Zealand English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡∏ô‡∏¥‡∏ß‡∏ã‡∏µ‡πÅ‡∏•‡∏ô‡∏î‡πå)", "South African English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡πÅ‡∏≠‡∏ü‡∏£‡∏¥‡∏Å‡∏≤‡πÉ‡∏ï‡πâ)",
        "Welsh English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡πÄ‡∏ß‡∏•‡∏™‡πå)", "Arabic": "‡∏≠‡∏≤‡∏´‡∏£‡∏±‡∏ö", "Chinese Mandarin": "‡∏à‡∏µ‡∏ô‡∏Å‡∏•‡∏≤‡∏á",
        "Cantonese": "‡∏à‡∏µ‡∏ô‡∏Å‡∏ß‡∏≤‡∏á‡∏ï‡∏∏‡πâ‡∏á", "Danish": "‡πÄ‡∏î‡∏ô‡∏°‡∏≤‡∏£‡πå‡∏Å", "Dutch": "‡∏î‡∏±‡∏ï‡∏ä‡πå", "French": "‡∏ù‡∏£‡∏±‡πà‡∏á‡πÄ‡∏®‡∏™",
        "Canadian French": "‡∏ù‡∏£‡∏±‡πà‡∏á‡πÄ‡∏®‡∏™ (‡πÅ‡∏Ñ‡∏ô‡∏≤‡∏î‡∏≤)", "German": "‡πÄ‡∏¢‡∏≠‡∏£‡∏°‡∏±‡∏ô", "Hindi": "‡∏Æ‡∏¥‡∏ô‡∏î‡∏µ",
        "Icelandic": "‡πÑ‡∏≠‡∏ã‡πå‡πÅ‡∏•‡∏ô‡∏î‡πå", "Italian": "‡∏≠‡∏¥‡∏ï‡∏≤‡∏•‡∏µ", "Japanese": "‡∏ç‡∏µ‡πà‡∏õ‡∏∏‡πà‡∏ô", "Korean": "‡πÄ‡∏Å‡∏≤‡∏´‡∏•‡∏µ",
        "Norwegian": "‡∏ô‡∏≠‡∏£‡πå‡πÄ‡∏ß‡∏¢‡πå", "Polish": "‡πÇ‡∏õ‡πÅ‡∏•‡∏ô‡∏î‡πå", "Brazilian Portuguese": "‡πÇ‡∏õ‡∏£‡∏ï‡∏∏‡πÄ‡∏Å‡∏™ (‡∏ö‡∏£‡∏≤‡∏ã‡∏¥‡∏•)",
        "European Portuguese": "‡πÇ‡∏õ‡∏£‡∏ï‡∏∏‡πÄ‡∏Å‡∏™ (‡∏¢‡∏∏‡πÇ‡∏£‡∏õ)", "Romanian": "‡πÇ‡∏£‡∏°‡∏≤‡πÄ‡∏ô‡∏µ‡∏¢", "Russian": "‡∏£‡∏±‡∏™‡πÄ‡∏ã‡∏µ‡∏¢","Portuguese": "‡πÇ‡∏õ‡∏£‡∏ï‡∏∏‡πÄ‡∏Å‡∏™",
        "Spanish": "‡∏™‡πÄ‡∏õ‡∏ô", "Castilian Spanish": "‡∏™‡πÄ‡∏õ‡∏ô (‡∏Ñ‡∏≤‡∏™‡∏ï‡∏µ‡∏•)", "Mexican Spanish": "‡∏™‡πÄ‡∏õ‡∏ô (‡πÄ‡∏°‡πá‡∏Å‡∏ã‡∏¥‡πÇ‡∏Å)",
        "US Spanish": "‡∏™‡πÄ‡∏õ‡∏ô (‡∏™‡∏´‡∏£‡∏±‡∏ê‡∏Ø)", "US English": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (‡∏™‡∏´‡∏£‡∏±‡∏ê‡∏Ø)", "Swedish": "‡∏™‡∏ß‡∏µ‡πÄ‡∏î‡∏ô",
        "Turkish": "‡∏ï‡∏∏‡∏£‡∏Å‡∏µ", "Welsh": "‡πÄ‡∏ß‡∏•‡∏™‡πå"
    };

    // Default voice to be used when no explicit selection is provided. We choose the French voice "L√©a".
    const DEFAULT_VOICE_ID = 'Lea';

    let pollyVoices = [];

    function loadPollyVoices() {
        polly.describeVoices({ Engine: 'standard' }, function(err, data) {
            if (err) {
                console.error('Could not get voices', err);
                return;
            }
            pollyVoices = (data.Voices || []).sort((a, b) => {
                const langA = languageMap[a.LanguageName] || a.LanguageName;
                const langB = languageMap[b.LanguageName] || b.LanguageName;
                const nameA = `${langA} - ${a.Name} (${a.Gender[0]})`;
                const nameB = `${langB} - ${b.Name} (${b.Gender[0]})`;
                return nameA.localeCompare(nameB, 'th');
            });
            populateVoiceSelects();
        });
    }

    function populateVoiceSelects() {
        document.querySelectorAll('select.voice-select').forEach(sel => {
            const previous = sel.value;
            // Preserve any data-selected-voice attribute before rebuilding options
            const selectedAttr = sel.getAttribute('data-selected-voice');
            sel.innerHTML = '';
            pollyVoices.forEach(voice => {
                const langName = languageMap[voice.LanguageName] || voice.LanguageName;
                const text = `${langName} - ${voice.Name} (${voice.Gender === 'Female' ? '‡∏´‡∏ç‡∏¥‡∏á' : '‡∏ä‡∏≤‡∏¢'})`;
                const option = document.createElement('option');
                option.value = voice.Id;
                option.textContent = text;
                sel.appendChild(option);
            });
            // Determine which voice to select: explicit data-selected-voice attribute takes highest precedence,
            // then previously selected value (if still present), otherwise fall back to default voice.
            let targetVoice = null;
            if (selectedAttr && Array.from(sel.options).some(opt => opt.value === selectedAttr)) {
                targetVoice = selectedAttr;
            } else if (previous && Array.from(sel.options).some(opt => opt.value === previous)) {
                targetVoice = previous;
            }
            if (!targetVoice) {
                const preferred = pollyVoices.find(v => v.Id === DEFAULT_VOICE_ID);
                targetVoice = preferred ? preferred.Id : (pollyVoices.length > 0 ? pollyVoices[0].Id : '');
            }
            sel.value = targetVoice;
        });
    }

    // updateVoiceSelects alias for backward compatibility
    function updateVoiceSelects() {
        populateVoiceSelects();
    }

    function speakWithPolly(ipaText, voiceId) {
        if (!ipaText) return;
        const clean = String(ipaText).replace(/[\\/ÀàÀå]/g, '').trim();
        const ssml = `<speak><phoneme alphabet='ipa' ph='${clean}'></phoneme></speak>`;
        const presigner = new AWS.Polly.Presigner({}, polly);
        const params = {
            OutputFormat: 'mp3',
            SampleRate: '16000',
            Text: ssml,
            TextType: 'ssml',
            // Use provided voiceId if available, otherwise fall back to our predefined default.
            VoiceId: voiceId || DEFAULT_VOICE_ID || (pollyVoices.length > 0 ? pollyVoices[0].Id : 'Salli')
        };
        presigner.getSynthesizeSpeechUrl(params, (err, url) => {
            if (err) {
                console.error('AWS Polly Error:', err);
            } else {
                const audio = new Audio(url);
                audio.play().catch(e => console.warn('Autoplay blocked:', e));
            }
        });
    }

    // Override global speakPhonetics to Polly version
    window.speakPhonetics = function(ipa, voiceId) {
        speakWithPolly(ipa, voiceId);
    };

    // Attach global click handler for audio controls
    document.addEventListener('click', function(e) {
        const target = e.target.closest('.modal-phonetics-btn, .dict-phonetics-btn, .dialect-phonetics-btn, .dialect-audio-btn');
        if (target) {
            // Determine the wrapper that holds data-phonetic attribute
            let wrapper = target.closest('[data-phonetic]');
            let phon = '';
            let voiceSel = null;
            if (wrapper) {
                phon = wrapper.getAttribute('data-phonetic') || '';
                voiceSel = wrapper.querySelector('select.voice-select');
            }
            // If wrapper not found or no phonetic attribute, try to find input
            if (!phon) {
                const input = target.closest('div').querySelector('input[type="text"]');
                if (input) phon = input.value || '';
            }
            // If a voice selector wasn't found via the wrapper, look for one in the same container as the clicked control
            if (!voiceSel) {
                const parentDiv = target.closest('div');
                if (parentDiv) {
                    voiceSel = parentDiv.querySelector('select.voice-select');
                }
            }
            // Determine voice: prefer explicit selection; otherwise use stored voiceId attribute on wrapper
            let voiceName = null;
            if (voiceSel && voiceSel.value) {
                voiceName = voiceSel.value;
            } else if (wrapper) {
                const attrVoice = wrapper.getAttribute('data-voiceid');
                if (attrVoice) {
                    voiceName = attrVoice;
                }
            }
            speakPhonetics(phon, voiceName);
        }
    });

    // Accent toggle logic: toggles the visibility of voice selection dropdowns for phonetics.
    document.addEventListener('click', function(e) {
        const toggleBtn = e.target.closest('.accent-toggle-btn');
        if (toggleBtn) {
            const container = toggleBtn.closest('[data-phonetic]');
            if (container) {
                const select = container.querySelector('select.voice-select');
                if (select) {
                    const isHidden = select.classList.contains('hidden') || select.style.display === 'none';
                    if (isHidden) {
                        select.classList.remove('hidden');
                        select.style.display = 'inline-block';
                    } else {
                        select.classList.add('hidden');
                        select.style.display = 'none';
                    }
                }
            }
        }
    });

    // When the user selects a new accent in a dropdown that should auto-hide, hide it afterwards.
    document.addEventListener('change', function(e) {
        const sel = e.target;
        if (sel && sel.matches('select.voice-select') && sel.dataset.hideAfterSelect === 'true') {
            setTimeout(() => {
                sel.classList.add('hidden');
                sel.style.display = 'none';
            }, 0);
        }
    });

    document.addEventListener('DOMContentLoaded', function() {
        // Load voices after credentials
        AWS.config.credentials.get(function(err) {
            if (err) {
                console.error('Cognito creds error:', err);
            } else {
                loadPollyVoices();
            }
        });
    });
    </script>
</body>
</html>
